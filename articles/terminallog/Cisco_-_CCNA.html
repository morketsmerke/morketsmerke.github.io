<!DOCTYPE html>
<html>
  <head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://i.ibb.co/khy45hh/mm.png">
		<link rel="stylesheet" type="text/css" href="/style.css">
		<style>
			.code-block {
				text-align: left;
			}
			ul {
				text-align: left;
			}
      p {
        text-align: justify;
      }
      .exam_tip {
        border: solid 1px black;
      }
      body {
        width: 99%;
        height: 100vh;
      }
      .main {
        width: 100%;
      }
		</style>
	</head>
	<body>
		<div class="main">
    <div id="tableOfContent">
      <h1>Cisco Systems - Cisco Certified Network Associate</h1>
      <ul class="toc">
        <li><a href="#0.introduction">0. Wstęp</a></li>
        <li><a href="#1.module1">1. Moduł 1: Wprowadzenie do sieci komputerowych - ITN</a>
          <ul class="toc">
          <li><a href="#1.1.networkingtoday">1.1. Sieci dzisiaj</a></li>
          <li><a href="#1.2.basicswitchandendpointconfig">1.2. Podstawowa konfiguracja przełącznika oraz urządzenia końcowego</a>
          <li><a href="#1.3.protocolsandmodels">1.3. Protokoły i modele</a></li>
          <li><a href="#1.partialexam">Egzamin cząstkowy</a></li>
          <li><a href="#1.4.physicalayer">1.4. Warstwa fizyczna</a></li>
          <li><a href="#1.5.numbersystems">1.5. Systemy liczbowe</a></li>
          <li><a href="#1.6.datalinklayer">1.6. Warstwa łącza danych</a></li>
          <li><a href="#1.7.ethernetswitching">1.7. Przełączanie Ethernetu</a></li>
          <li><a href="#1.8.networklayer">1.8. Wartstwa sieciowa</a></li>
          <li><a href="#1.9.adresresolution">1.9. Rozwiązywanie adresów</a></li>
          <li><a href="#1.10.basicrouterconfig">1.10. Podstawowa konfiguracja routera</a></li>
          <li><a href="#1.11.ipv4adressing">1.11. Adresacja IPv4</a></li>
          <li><a href="#1.12.ipv6adressing">1.12. Adresacja IPv6</a></li>
          <li><a href="#1.13.icmpprotocol">1.13. Protokół ICMP</a></li>
          <li><a href="#1.14.transportlayer">1.14. Warstwa transportowa</a></li>
          <li><a href="#1.15.applicationlayer">1.15. Warstwa aplikacji</a></li>
          <li><a href="#1.16.networksecurityfundamentals">1.16. Wprowadzenie do bezpieczeństwa sieci</a></li>
          <li><a href="#1.17.buildingasmallnetwork">1.17. Budowanie małej sieci</a></li>
          <!--<li><a href="#1.examplepartialexam">Przykładowy egzamin cząstkowy - Tematy: 16-17</a></li>-->
          <li><a href="#1.mockexam">1. Egzamin próbny - ITN</a></li>
          <li><a href="#1.finalexam">1. Egzamin finałowy - ITN</a></li>
          <li><a href="#1.ptsa">1. Finałowy egzamin praktyczny - Packet Tracer - ITN</a></li>
          </ul>
        </li>
        <li><a href="#2.module2">2. Moduł 2: Podstawy przełaczania, routingu oraz sieci bezprzewodowych - SRWE</a>
          <ul class="toc">
            <li><a href="#2.1.basicdeviceconfiguration">2.1. Podstawowa konfiguracją urządzenia</a></li>
            <li><a href="#2.2.switchingconcepts">2.2. Koncepcje przełączania</a></li>
            <li><a href="#2.3.vlannetworks">2.3. Sieci VLAN</a></li>
            <li><a href="#2.4.intervlanrouting">2.4. Routing między VLAN-ami</a></li>
            <li><a href="#2.5.stpconcepts">2.5. Koncepcje STP</a></li>
            <li><a href="#2.6.etherchannel">2.6. Technologia EtherChannel</a></li>
            <li><a href="#2.7.dhcpv4">2.7. DHCPv4</a></li>
            <li><a href="#2.8.slaacanddhcpv6">2.8. SLAAC i DHCPv6</a></li>
            <li><a href="#2.9.fhrpconcepts">2.9. Koncepcje FHRP</a></li>
            <li><a href="#2.10.securityconcepts">2.10. Koncepcje bezpieczeństwa</a></li>
            <li><a href="#2.11.configureswitchsecurity">2.11. Konfiguracja zabezpieczeń przełącznika</a></li>
            <li><a href="#2.12.wlanconcepts">2.12. Koncepcje WLAN</a></li>
            <li><a href="#2.13.wlanconfiguration">2.13. Konfiguracja siec WLAN</a></li>
            <li><a href="#2.14.routingconcepts">2.14. Koncepcje routingu</a></li>
            <li><a href="#2.15.staticiprouting">2.15. Statyczny routing IP</a></li>
            <li><a href="#2.16.staticanddefaultroutestroubleshooting">2.16. Rozwiązywanie problemów związanych z trasami statycznymi oraz z trasami domyślnymi</a></li>
            <li><a href="#2.finalexam">2. Egzamin końcowy - SRWE</a></li>
            <li><a href="#2.finalpractice">2. Egzamin praktyczy - SRWE</a></li>
          </ul>
        </li>
        <li><a href="#3.module3">3. Moduł 3: Sieci korporacyjne, bezpieczeństwo i automatyzacja</a>
        <ul class="toc">
          <li><a href="#3.1.oneareaospfconcepts">3.1 Koncepcje jednoobszarowego OSPFv2</a></li>
          <li><a href="#3.2.oneareaospfconfiguration">3.2. Konfiguracja jednoobszarowego OSPFv2</a></li>
          <li><a href="#3.3.networksecurityconcepts">3.3. Koncepcje bezpieczeństwa sieci</a></li>
          <li><a href="#3.4.aclconcepts">3.4. Koncepcje ACL</a></li>
          <li><a href="#3.5.configurationacllistforipv4">3.5. Konfiguracja list ACL dla IPv4</a></li>
          <li><a href="#3.6.natforipv4">3.6. NAT dla IPv4</a></li>
          <li><a href="#3.7.wanconcepts">3.7. Koncepcje sieci WAN</a></li>
          <li><a href="#3.8.vpnandipseconcepts">3.8. Koncepcje VPN oraz IPSec</a></li>
          <li><a href="#3.9.qosconcepts">3.9. Koncepcje QoS</a></li>
          <li><a href="#3.10.networkmanagement">3.10. Zarządzanie siecią</a></li>
          <li><a href="#3.11.desigingnetworks">3.11. Projektowanie sieci</a></li>
          <li><a href="#3.12.networkstroubleshooting">3.12. Rozwiązywanie problemów z sieciami</a></li>
          <li><a href="#3.13.virtualization">3.13. Wirtualizacja</a></li>
          <li><a href="#3.14.networkautomatization">3.14. Automatyzacja sieci</a></li>
          <li><a href="#3.finalpractice">3. Egzamin praktyczny - ENSA</a></li>
        </ul>
        </li>
      </ul>
      <p>
        Źródła:
      </p>
      <ol>
        <li>Kurs CCNAv7: Introduction to Networks - netacad.com. Dostęp do
          kursu zapewniony podczas kursów Cisco CCNA na jeden z uczelnii
          wyższych w Polsce. <em>Autor nieznany/wielu autorów na przestrzeni
          lat.</em>
        </li>
      </ol>
    <p class="footer">
        ~xf0r3m<br />
				2024; COPYLEFT; ALL RIGHTS REVERSED;
		</p>
      </div>
      <div id="content">
      <div id="contentHeader">
<pre id="divisionBaner">
            _               _
        _  | |  _       _  | |  _
    _  | | | | | |  _  | | | | | |  _
   |_| |_| | | |_| |_| |_| | | |_| |_|
           |_|             |_| 
    ____   ___   ____     ____    ___  
   / ___| |_ _| / ___|   / ___|  / _ \ 
  | |      | |  \___ \  | |     | | | |
  | |___   | |   ___) | | |___  | |_| |
   \____| |___| |____/   \____|  \___/ 
                                     
</pre>
        <p id="contentHeaderLink" class="header_link">
	    &#9760;&nbsp;<a href="https://morketsmerke.github.io">morketsmerke</a>&nbsp;&#9760;
        </p>
      </div>
      <h1 id="0.introduction">0. Wstęp</h1>
      <p>
        Pod koniec wakacji zeszłego roku w pracy (tej nowej, której szukałem
        przygotowując materiał o RHCSA), kierownik podsłał mi propozycje kursu
        z certyfikacji Cisco CCNA, która odbywała się na wydziale informatyki
        jednej z miejscowych uczelni wyższych w kraju. Pomyślałem sobie, że 
        może być
        ciekawie, ale poźniej trochę ekscytacja opadła po pierwsze, ponieważ 
        sieci nigdy nie były obiektem jakiś moich większych zainteresowań.
        Dalej nie wiem jako to się stało, że pracuje jako administrator sieci.
        Więc po dłużyszych działaniach biurokratycznych (kurs w pełni 
        finansowany
        przez pracodawce - umowa szkoleniowa - lojalka - 5500 brutto albo przez
        3 lata zostajesz w firmie), zapisałem się na kurs. Na pierwszych
        zajęciach nawet nie byłem, zmęczony byłem podróżom z i do stolicy.
        Dostałem maila od wykładowcy z dostępem do wydziałowego moodle-a oraz
        platformy netacad.com. Gdzie można było pobrać Packet Tracer, same
        wykłady prowadzone na wydziale były super, dużo gadania, dyskusji
        czy luźnych rozkmin, a i gdzieś tam miałem szanse dotknąć sprzetu
        Po trzecim temacie przyszedł czas tzw. egzaminów cząstkowych -
        zwykłych testów, które należało zaliczyć. Wyszystko ładnie pięknie, ale
        z czegoś się trzeba przygotować, nie uważam, że wykładowca nas nie
        przygotował, ale pierwszy egzamin cząstkowy, już pokazywał że wiedza
        z wykładów jest ciekawa i na pewno niesie ze sobą wiecej wartości
        merytorycznej niż to co oferuje firma Cisco.
        Same materiały zapewnione przez Cisco do nauki dla kursantów są
        wątłej jakości, tłumaczenie na język polski to ło Matko, ło Jezu.
        A prezentacje w PowerPoint w języku angielskim, potrafią nie zawierać
        przykładów, czy zawierać błędy w poleceniach lub opisy mogą niepasować
        do niektórych terminów (ale nie to, że merytorycznie coś jest nie tak,
        są po prostu zamienione w tabeli miejscami XD), same egzaminy również
        zawierają pokrętnie napisane pytania. Na przykład pytania o topologię
        hybrydową, o której nie ma ani słowa materiałach. Albo brak poprawnej
        odpowiedzi odnośnie działania zapory pakietów czy zapory stanowej.
        Także mentalnie trzeba się przygotować do tego, że chociaż by się
        nie wiadomo jak mocno starać, to i tak nie uzyskać się maksymalnej
        ilości punktów, albo kolejne ciekawa rzecz, wg. kryteriów oceniania
        kursu CCNA firmy Cisco, to pracownik, który próbuje złamać hasło innego
        pracownika jest słabością a nie atakiem. Także wiecie z czym macie
        doczynienia, dlatego I DON'T GIVE A SHIT czy zdam czy niezdam. Mi
        zostanie wiedza z kursów i miło spędzony czas na wykładach a
        pracodawcy wystarczy zaświadczenie o ukończeniu kursu wydane przez
        uniwersytet. Kiedyś nie było to możliwe, kiedyś trzeba było mieć
        wszystko zaliczone, aby iść dalej teraz już nie.
      </p>
      <p>
        Przedstawione tutaj informacje mogą nie tyle mijać się z celem, co być
        nie kompletne na dzień dzisiejszy. Celem tego kursu najwidoczniej nie
        jest nauka z zakresu sieci komputerowych (poniekąd), tylko uzyskanie
        certyfikatów, chcąc certyfikować ludzi na całym świecie trzeba utworzyć
        pewien standard, a zdający muszą zdawać zgodnie z tym standardem
        (kluczem). 
      </p>
      <h1 id="1.module1">1. Moduł 1: Wprowadzenie do sieci komputerowych</h1>
      <h1 id="1.1.networkingtoday">1.1. Sieci dzisiaj</h1>
      <p>
        W dzisiejszym świecie wszystko chce być podłączone do Internetu, czy
        korzystać z zasobów rozległych sieci. Nie zawsze tak było. Czasy się
        zmieniają, i to czy podążymy za nimi to już nasza decyzja. Każdy
        obecnie ma smartfon w kieszeni, u większości osób na ścianie wiszą
        telewizory, które służą do oglądania stricte kanałów telewizyjny a
        platform streamingowych. Czy kto kolwiek zadał sobie to pytanie jak
        to wszystko funkcjonuje chociaż raz. Raczej nie, po co sobie 
        zaprzątać tym głowe. Ten rozdział nie będzie o tym, ponieważ to 
        są materiały przygotowe przez Cisco, więc można go 
        potraktować z przymrużeniem oka.
      </p>
      <h2 id="1.1.1.networkcomponents">1.1.1. Komponenty sieciowe</h2>
      <p>
        Każdy komputer w sieci nazywany jest hostem lub urządzeniem końcowym.
        Serwery są komputerami, które dostarczają informacji urządzeniom
        końcowym, np. serwery pocztowe, serwery WWW czy serwery plików.
        Klienci to komputery, które wysyłają żądania do serwerów aby
        otrzymać odpowiednie informacje.
      </p>
      <p>
        Możliwe jest aby jedno urządzenie było jednocześnie klieten oraz
        serwerem. Jest to połączenie <em>Peer-to-Peer</em>. Tego typu
        rozwiązania są dobre do małych sieci.
      </p>
      <p>
        Po za hostem w sieciach istnieją jeszcze urządzenia pośrednie. Ich
        zadaniem jest łączyć ze sobą hosty. Do takich urządzeń możemy
        zaliczyć routery, przełączniki, zapory sprzętowe, czy access pointy.
      </p>
      <p>
        Do łączenia ze sobą hostów wykorzystuje się media. To media
        transmisyjne pozwalają na przesył informacji między komponentami
        sieciowymi. Z pośród mediów transmisyjnych możemy wyróżnić okablowanie
        miedziane - wykorzystujące impulsy elektryczne, okablowanie
        światłowodowe - wykorzysujące impulsy świetlne czy powietrze
        wykorzysujące fale radiowe oraz mikrofalowe.
      </p>
      <h2 id="1.1.2.commontypesofnetworks">1.1.2. Powszechne rodzaje sieci</h2>
      <p>
        Sieci mają różne rozmiary. Sieci domowe zazwyczaj łączą ze sobą kilka
        komputerów/urządzeń. Sieci klasy SOHO, mogą wcale nie różnić się od
        sieci domowych. Mogą być to oddziały firmy, a jedyną róznicą może być
        dobrej
        klasy łącze, aby można było bezpiecznie i bez trudu komunikować się
        z siecią w siedzibie firmy. Średnie i duże firmy mogą łączyć ze
        sobą setki jak nie tysiące komputerów w tym kilka budynków. Największe
        sieci to te o zasięgu globalnym, np. Internet.
      </p>
      <p>
        Sieci można podzielić na podstawie: zasiegu, liczby podłączonych 
        użytkowników, liczby i rodzaju dostępnych usług czy obszaru
        odpowiedzialności. Istnieją dwa rodzaje najczęściej spotykanych 
        sieci: sieci lokalne (LAN) oraz sieci rozległe (WAN). Sieci lokalne
        obejmują co najwyżej obszar kilku budynków, gdzie sieci rozległe
        mogą łączyć ze sobą naprawdę odległe sieci lokalne.
      </p>
      <p>
        Internet jest zbiorem połączonych ze sobą sieci LAN i WAN. LAN-y
        razej łączą się przez inne sieci WAN. Intenet nie należy do nikogo,
        chociaż są grupy takie jak ICANN oraz IETF, które zajmują się
        przestrzenią adresową czy rozwojem protokółów. 
      </p>
      <p>
        Intranet jest zbiorem LAN-ów oraz WAN-ów w obrębie jednej organizacji
        oznacza to również, że do tej sieci mają dostęp tylko określeni
        członkowie organizacji oraz inni, którzy mogą się zautoryzować.
        Firmy korzystają z ekstranetu aby zapewnić dostęp do wybranych zasobów
        ściśle określonym użytkownikom.
      </p>
      <h2 id="1.1.3.internetconnections">1.1.3. Połączenia z Internetem</h2>
      <p>
        Obecnie zwykli użytkownicy w domach oraz duże organizację mogą łączyć
        się z internetem w różny sposób. Każdy głównie korzysta ze sposobów na
        który pozwalają warunki technicze naszej lokalizacji oraz zasób
        naszego portfela.
      </p>
      <p>
        Użytkownicy domowi wykorzystują takie łącza jak: 
        kablówka/sieć osiedlowa, DSL, połączenia radiowe oraz połączenia sieci
        komórkowej.
      </p>
      <p>
        Organizacje mają o wiele wieksze potrzeby oraz wymagania dotyczące
        łączności internetowej dlatego też wymagane jest dobre jakości stałe
        łącze dlatego też odpowiednimi dla nich łączami będzie biznesowa wersja
        DSL, łącze dzierżawcze oraz sieć miejska, która może skupiać 
        najważniejsze ośrodki badawczo-przemysłowe w danym mieście.
      </p>
      <p>
        Dziś internet staje się podobnie niezbędnym medium jak prąd czy woda.
        Obecnie rezygnuje się z telefonów czy telewizji na rzecz własnie
        internetu. Za pomocą właśnie internetu możemy prowadzić rozmowy
        telefoniczne czy oglądać telewizje. Takie zajwisko nazywane jest
        <strong>konwergencją</strong> sieci. Sieć telewizyjna oraz sieć 
        telefonicza zostały połączone w jedną jak stał się internet.
      </p>
      <h3 id="1.1.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/1.5.7-packet-tracer---network-representation_pl-PL.pdf">Reprezentacja sieci - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/1.5.7-packet-tracer---network-representation_pl-PL.pka">Reprezentacja sieci - zadanie</a>
      </p>
      <h2 id="1.1.4.reliablenetworks">1.1.4. Niezawodność sieci</h2>
      <p>
        Architektura sieciowa odnosi się do technologii wspierających
        infrastrukturę, która przenosi dane przez sieć. Istnieją cztery
        podstawowe cechy charakterystyczne, które muszą być podwaliną każdej
        architektury sieciowej, aby móc spełnić oczekiwania użytkowników. Są
        nimi: <strong>odporność na błędy</strong>,
        <strong>skalowalność</strong>, <strong>QoS</strong> czy
        <strong>bezpieczeństwo</strong>.
      </p>
      <p>
        Sieci z odpornością na błędy ograniczają wpływ problemu po przez
        zmniejszenie dotkniętych nim urządzeń. W sieciach taką tolerancją
        błędów, może być zapewnienie połączeń nadmiarowych. Oczwywiście wymaga
        to zastosowania bardziej zaawansowanych technologii.
      </p>
      <p>
        Skalowalne sieci komputerowe, można w prosty i szybki sposób
        rozszerzyć bez wpływu na wydajność pozostałych użytkowników.
        Projektanci sieci projektują ją zgodnie ze standardami oraz powszechnie
        wykorzystywanymi protokołami, aby zapewnić jej skalowalność.
      </p>
      <p>
        OoS - ang. <em>Quality of Service</em> jest podstawowym mechanizmem
        używanym do zapewnienia niezawodności dostarczenia danych do wszystkich
        użytkowników. Za pomocą zastosowanej polityki QoS routery mogą regulować
        przesył ruchu danych czy przesyłanie głosu.
      </p>
      <p>
        Są dwa główne rodzaje bezepieczeństwa sieci jaki trzeba zapewnić:
        <strong>bezpieczeństwo infrastruktury sieciowej</strong> oraz
        <strong>bezpieczeństwo informacji</strong>. Na bezpiczeństwo sieci
        składa się fizyczne zabezpieczenie urządzeń sieciowych oraz ochronę
        przed nieuprawnionym dostępem do nich. Natomiast bezpieczeństwo
        informacji polega na zabepieczeniu informacji lub danych przesyłanych
        przez sieć. Są trzy podstawowe cele bezpieczeństwa sieci:
        <strong>poufność</strong> - tylko określeni odbiorcy mogą odczytać
        przesyłane dane, <strong>integralność</strong> - zapewnienie, że dane
        nie zostały zmienione podczas transmisji oraz
        <strong>dostępność</strong> - zapewnienie o niezawodnym
        dostępie do danych przez autoryzowanych użytkowników.
      </p>
      <h2 id="1.1.5.networktrends">1.1.5. Trendy sieciowe</h2>
      <p>
        Role sieci wymagają ciągłych zmian, ciągłego dostosowania aby nądąrzyć
        za ciągle pojawiąjcymi się na rynku urządzeniami. Możemy wyróżnić kilka
        nowych trendów, majacych wpływ na organizację:
      </p>
      <ul>
        <li><strong>Bring Your Own Device</strong> (BYOD)</li>
        <li><strong>Współpraca online</strong></li>
        <li><strong>Komunikacja wideo</strong><li>
        <li><strong>Przetwarzanie chmurowe</strong></li>
      </ul>
      <p>
        Bring Your Own Device (BYOD), ang. <em>przynieś swoje urządzenie</em>,
        pozwala użytkownikom używać ich własnych urządzenie co daje im więcej
        możliwości oraz większą elastyczność. BYOD pozwala użytkownikom
        końcowym na używanie ich własnych (ulubionych) narzędzi. BYOD oznacza
        dowolne urządzenie w posiadaniu rożnych osób, używane gdzie kolwiek.
      </p>
      <p>
        Współpraca online pozwala wspólną pracę nad wieloma projektami z
        różnymi ludźmi na odległość z pośrednictwem sieci. Do tego celu
        często wykorzystywan są takie aplikacje jak MS Teams czy Cisco Webex.
        Takie podjeście swietnie odnajduje się biznesie czy edukacji.
      </p>
      <p>
        Połączenia wideo mogą być wykonywane przez kogo kolwiek gdzie kolwiek
        jest są one poteżnym narzędziem do komunikacji z innymi. Konferencje
        wideo stały się wręcz wymogiem do efektywnej współpracy.
      </p>
      <p>
        Przetwarzanie chmurowe pozwala na przechowywanie osobistych danych na
        na serwerach w internecie. Możliwe jest również dostarczanie zasobów
        komputerów (np. w celach wirtualizacji) jak i samych aplikacji.
        Przetwarzanie chmurowe jest obsługiwane najczęsciej przez ogromne
        korporacje takie jak Amazon czy Google. Mozemy wyróżnić cztery rodzaje
        <em>chmur</em>:
      </p>
      <ul>
        <li><strong>Publiczne</strong>, z których każdy może korzystać, za
          darmo lub opłatą według zużycia zasobów.</li>
        <li><strong>Prywatne</strong>, do wykorzystania przez spcyficzne
          organizacje takie jak np. rząd.</li>
        <li><strong>Hybrydowe</strong>, łączące ze soba funkcję na przykład
          chmur prywatnych jak i tych niestandardowych.</li>
        <li><strong>Niestandardowe</strong>, tworzona dla specjalnych potrzeb
          organizacji. Może być prywatna i np. wykorzystywać zasoby chmury
          publicznej.</li>
      </ul>
      <h2 id="1.1.6.networksecurity">1.1.6. Bezpieczeństwo sieci</h2>
      <p>
        Bezpieczeństwo jest integralną częścią sieci, bez znaczenia na
        jej wielkość. Musi ono zostać zaimplentowane w taki sposób aby nie
        wpłyneło za bardzo na wymagania dotyczące łączności. Zabezpieczenie
        sieci angażuje wiele protokołów, technologii, urządzeń, narzędzi czy
        technik w celu zabepieczenia danych oraz złagodzenia zagrożeń, które
        mogą pochodzić jak najbardziej z zewnątrz ale ich źródło może być
        równie dobrze z wewnątrz organizacji.
      </p>
      <p>
        Z pośród zagrożeń zewnętrznych możemy wymień takie jak:
      </p>
      <ul>
        <li>Wirusy, robaki czy konie trojańskie</li>
        <li>Oprogramowanie typu <em>spyware</em> czy <em>adware</em></li>
        <li>Ataki typu <em>0-day</em></li>
        <li>Ataki podmiotu zagrożenia</li>
        <li>Ataki odmowy usługi</li>
        <li>Ataki kradzieży oraz fałszowania danych</li>
        <li>Kradzież tożsamości</li>
      </ul>
      <p>
        Natomiast zagrożenia wewnętrzne to między innymi:
      </p>
      <ul>
        <li>Zgubione lub ukradzone urządzenia</li>
        <li>Przypadkowe nadużycia przez pracowników</li>
        <li>Złośliwy pracownik</li>
      </ul>
      <p>
        Zabepieczenia powinny obejmować wiele warstw, składać się z większej
        ilości rozwiązań. Dla małej sieci domowej, wystarczy dobrej jakości
        program antywirusowy zainstalowany na urządzeniach końcowych oraz
        firewall blokujący nieautoryzowanych dostęp do sieci.
      </p>
      <p>
        Przy czym dla większych sieci stosuje się nieco bardziej wyrafinowane
        rozwiązania takie jak: dedykowany firewall, listy kontroli dostępu
        (ACL), systemy zapobiegania włamaniom (IPS), wirtualne sieci prywatne
        (VPN). Zrozumienie bezpieczeństa sieci rozpoczyna się od dobrego
        zrozumienie infrastruktury sieci, w tym przełączników oraz routerów.
      </p>
      <h2 id="ch1summary">Podsumowanie</h2>
      <p>
        Tym rozdziałem rozpoczynamy kurs. W ramach tego rodziału poznaliśmy
        współczene trendy sieciowe oraz to jak w obecnych czas istotne jest
        połączenie z Intenetem za pośrednictwem nawet najmniejszej sieci.
      </p>
      <h1 id="1.2.basicswitchandendpointconfig">1.2. Podstawowa konfiguracja przełącznika oraz urządzenia końcowego</h1>
      <p>
        W tym rodzdziale nie bedziemy skupiać się na konfiguracji urządzenia
        końcowego, jakby tytuł sugerował. To wydaje mi się, że każdy potrafi,
        prawda? Skupimy się na zapoznaniu z system IOS, będącym oprogramowaniem
        urządzeń firmy Cisco oraz jak wyglądają takie podstawowe czynności,
        które należy wykonać na tym urządzeniu przed już bardziej ukierunkowaną
        na konkretne urządzenie konfiguracją.
      </p>
      <h2 id="1.2.1.ciscoiosaccess">1.2.1. Dostęp do systemu Cisco IOS</h2>
      <p>
        Słowem wstępu systemy komputerowe składają się z sprzętu oraz
        oprogramowania. Aby uruchamiać specyficzne oprogramowanie potrzebujemy
        platformy programowej zapewniającej wszystkie niezbędne składniki do
        uruchomienia wybranych programów. Tym jest właśnie system operacyjny.
        Systemy operacyjne składają się z jądra, przestrzeni użytkownika oraz
        powłoki. Powłoka z kolei jest to interfejs pozwalający na
        prowadzenie interakcji z systemem operacyjnym a co za tym idzie z
        naszym sprzętem komputerowym. Powłoką może być interfejs graficzny lub
        program dający dostęp do wiersza polecenia oraz interpretujący co
        zostało w nim zapisane. Systemami składającymi się z jadra oraz powłoki
        są najczęściej systemy wbudowane takie jak Cisco IOS.
      </p>
      <p>
        Dostęp do IOS możemy uzyskać na 3 sposoby: połaczeniem konsolowym
        za pomocą kabli szeregowych połączanych do portu szeregowego
        komputera oraz do portu konsolowego urządzenia. Jeśli urządzenie jest
        przywrócone do ustawień fabrycznych to raczej może nie być innej
        możliwości. Połączenia szeregowe w przypadku urządzeń Cisco mogą być
        zestawione przy użyciu istniejącego okablowania sieciowego.
        Innym sposobem jest wykorzystanie połączeń przy użyciu protokołów
        SSH oraz Telnet. Przyczym warto mieć na uwadzę, że Telnet nie jest
        bezpiecznym protokołem, ponieważ przesyła on informacje za pomocą
        jawnego tekstu. Programów do połączenia się z urządzeniami Cisco jest
        kilka, najpopularniejszym z nich jest chyba program 
        <strong>PuTTY</strong>, zapewnia on wspracie dla wszystkich
        wymienionych rodzajów połączeń.
      </p>
      <h2 id="1.2.2.iosnavigation">1.2.2. Nawigacja po systemie IOS</h2>
      <p>
        Po połączeniu z naszym urządzeniem do dyspozycji będziemy mieć dwa
        tryby wykonywania poleceń <strong>tryb użytkownika EXEC</strong>
        znak zachęty może wyglądać wówczas tak:
      </p>
<pre class="code-block">
Router&gt;
Switch&gt;
</pre>
      <p>
        Tryb ten jest domyślnym uruchamiany zaraz po podłączeniu się do
        urządzenia o ile urządzenie nie wymaga logowania. Tryb ten zapewnia
        ograniczoną liczbę poleceń i pozwala na wydanie kilku poleceń
        monitorujących.
      </p>
      <p>
        Innym trybem jest <strong>tryb uprzywilejowany EXEC</strong>, jest 
        coś w rodzaju
        administratora urządzenia, ten tryb pozwala na zmianę trybów
        konfiguracji, w tym trybie znaki zachęty mogą wyglądać w ten sposób:
      </p>
<pre class="code-block">
Router#
Switch#
</pre>
      <p>
        W urządzeniach Cisco, mamy dostępny
        <strong>tryb konfiguracji globalnej</strong>, wykorzystywany do
        konfiguracji parametrów urządzenia. Ten
        tryb posiada dwa podtryby: <strong>tryb konfiguracji linii</strong>,
        za jego pomocą konfigurujemy dostęp do urządzenia. Drugin podtrybem
        jest <strong>tryb konfiguracji interfejsu</strong>.
      </p>
      <p>
        Po podłączeniu się do urządzenia, automatycznie przechodzimy do trybu
        użytkownika EXEC, chcąc przejść do trybu uprzywilejowanego wydajemy
        polecenie <code class="code-inline">enable</code>. W tym trybie możemy
        już skonfigurować kilka opcji, jeśli jednak interesuje nas konfiguracja
        dostępu do urządzenia (a powinna), to żeby przjeść do trybu
        konfiguracji globalnej wydajemy polecenie
        <code class="code-inline">configure terminal</code>, z tego trybu
        możemy powrócić wydając polecenie 
        <code class="code-inline">exit</code>. Przjście do konfiguracji dostępu
        wymaga polecenia <code class="code-inline">line</code> oraz podania
        trybu dostępu, który chcemy skonfigurować. Dla połączenia szeregowego
        podajemy <code class="code-inline">console 0</code> dla połączeń
        zdalnych podajemy <code class="code-inline">vty</code>, czyli konsole
        wirtualną, następnie ilość jednoczesnych połączeń dla 5 podajemy
        <code class="code-inline">0 4</code>.
      </p>
      <p>
        Poszczególne tryby możemy opuścić za pomocą polecenia
        <code class="code-inline">exit</code>, wówczas powrócimy do trybu
        poprzedniego. Jeśli chcemy zakończyć konfigurację i powrócić do
        trybu uprzywilejowanego EXEC wydajemy polecenie
        <code class="code-inline">end</code>. Warto zwrócic uwagę na to, że
        wraz ze zmienymi trybami zmieniają się znaki zachęty, więc wiemy
        gdzie jesteśmy.
      </p>
<pre class="code-block">
Switch&gt;enable
Switch#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#line console 0
Switch(config-line)#exit
Switch(config)#int vlan1
Switch(config-if)#end
Switch#
%SYS-5-CONFIG_I: Configured from console by console

Switch#
</pre>
      <h2 id="1.2.3.commandstructure">1.2.3. Struktura poleceń</h2>
      <p>
        Polecenia składają się z samego polecenia, często identyfikującego
        program, który będzie uruchamiany. Następnie występują słowa kluczowe
        oraz argumenty, często będące opcjami oraz modyfikatorami działania
        głównego polecenia (programu).
      </p>
      <p>
        IOS posiada funkcje pomocy wywoływaną za pomocą znaku zapytania
        (<strong>?</strong>). Za jego pomocą możemy dostępne w danym trybie
        polecenia, lub sprawdzić dostępne argumenty dla podanych polecen.
      </p>
      <p>
        Podczas wpisywanie poleceń możemy posłużyć się skrótami poleceń,
        podając tyle znaków, aby powłoka IOS mogła je jednoznacznie
        zidentyfikować. 
      </p>
<pre class="code-block">
Switch#con
% Ambiguous command: "con"
Switch#con?
configure  connect  
Switch#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#
</pre>
      <p>
        IOS wprowadza również kilka skrótów klawiszowych. Dobrze odnajdą się
        tutaj użytkownicy powłoki BASH, gdyż IOS jest kompatybilny z
        GNU Readline. Pod Tab-em mamy dopełnianie poleceń. W przypadku
        stronicowania (<code class="code-inline">"--More--"</code>) mamy do
        dyspozycji klawisz <em>Enter</em>, który pozwoli na wyświetlenie
        kolejnej linii stronicowanego tekstu lub <em>Spacją</em> kolejną
        stronę. Każde naciśniecie innego klawisza spowoduje zakończenie
        wyświetlania i przejście do trybu EXEC. Zakończenie wprowadzania
        konfiguracji możemy dokonąć albo za pomocą wyżej wymienionych poleceń,
        albo za pomocą skrótów takich Ctrl+z lub Ctrl+c. Do przerwania
        polecenia ping, traceroute czy odwzorowania nazw domenowych należy
        wykorzystać kombinację klawiszy <strong>Ctrl+Shift+6</strong>
      </p>
      <h3 id="1.2.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.3.7-packet-tracer---navigate-the-ios_pl-PL.pdf">Nawigacja w IOS - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.3.7-packet-tracer---navigate-the-ios_pl-PL.pka">Nawigacja w IOS - zadanie</a>
      </p>
      <h3 id="1.2.3.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/2.3.8-lab---navigate-the-ios-by-using-tera-term-for-console-connectivity_pl-PL.pdf">Nawigacja w IOS za pomocą Tera Term przez konsolę</a>
      </p>
      <h2 id="1.2.4.basicdeviceconfiguration">1.2.4. Podstawowa konfiguracja urządzeń</h2>
      <p>
        Jedno z podstawowych czynności jakie należy wykonać dokonując
        pierwszej konfiguracji urządzenia z system IOS jest zmiana jego nazwy.
        Dokonujemy tego za pomocą polecenia
        <code class="code-inline">hostname</code>, podają wybraną nazwę jako
        argument polecenia. Nazwy muszą zaczynać się od litery, nie zawierać
        spacji, muszą zakończyć się literą lub cyfrą, zawierać tylko litery,
        cyfry lub myślniki. Nazwa nie może przekraczać 64 znaków. Aby
        przywrócić domyślną nazwę należy użyć polecenia:
        <code class="code-inline">no hostname</code>.
      </p>
      <p>
        Następną czynnością jest zabezpieczenie dostępu do urządzenia, przy
        użyciu hasła. Te czynności musimy wykonać w trybie konfiguracji
        linii za równo dla konsoli szeregowej jak i konsoli wirtualnych
        wykorzystywanych przez połączenia SSH oraz Telnet. W trybie
        konfiguracji globalnej
        (<code class="code-inline">configure terminal</code>), przechodzimy
        do konfiguracji linii połączenia szergowego
        (<code class="code-inline">line console 0</code>), teraz możemy
        ustawić hasło, pamiętając o zasadach bezpiecznych haseł. Ustawiamy
        hasło (<code class="code-inline">password</code>) oraz włączamy
        dostęp do trybu EXEC za pomocą polecenia
        <code class="code-inline">login</code>. Tę samą czynność powtarzamy dla
        konsoli wirtualnych, przyczym warto pamiętać, że IOS pozwala na 
        16 jednoczesnych połączeń więc do przejścia w tryb konfiguracji linii
        wykorzystujemy następujące polecenie
        <code class="code-inline">line vty 0 15</code>
      </p>
<pre class="code-block">
Switch#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#line console 0
Switch(config-line)#password cisco
Switch(config-line)#login
Switch(config-line)#exit
Switch(config)#line vty 0 15
Switch(config-line)#password cisco
Switch(config-line)#login
Switch(config-line)#exit
</pre>
      <p>
        Hasła, które widnieją na powyższym przykładnie do najtrudniejszych
        nie należą nie mniej jednak co z tego jeśli hasło będzie trudne. Jeśli
        są one przechowywane w postaci jawnego tekstu. Aby się o tym przekonać,
        możemy wyświetlić obecną konfigurację za pomocą polecenia
        <code class="code-inline">show running-config</code>, wydanego w
        uprzywilejowanym trybie EXEC.
      </p>
<pre class="code-block">
...
line con 0
 password cisco
 login
!
line vty 0 4
 password cisco
 login
line vty 5 15
 password cisco
 login
...
</pre>
      <p>
        Hasła te możemy zaszyfrować wydając w trybie konfiguracji globalnej
        polecenie
        <code class="code-inline">service password-encryption</code>.
      </p>
<pre class="code-inline">
Switch(config)#service password-enc
Switch(config)#service password-encryption
Switch(config)#exit
Switch#
%SYS-5-CONFIG_I: Configured from console by console

Switch#show running-config
...
!
line con 0
 password 7 0822455D0A16
 login
!
line vty 0 4
 password 7 0822455D0A16
 login
line vty 5 15
 password 7 0822455D0A16
 login
...
</pre>
      <p>
        Kiedy dostęp do trybu użytkownika jest chroniony hasłem, możemy
        zabezpieczyć tryb uprzywilejowany wydając odpowiednie polecenie
        w trybie konfiguracji globalnej.
      </p>
<pre class="code-block">
Switch(config)#enable secret class
Switch(config)#exit
</pre>
      <p>
        Przy czym <code class="code-inline">class</code> jest własnie tym
        ustawionym hasłem. Ostatnią czynnością będzie ustawienie informacji
        na temat tego, że jeśli ktoś się podłączy do naszego urządzenia, to że
        nie życzymy sobie żadnego nieupoważnionego dostępu. Do tego celu
        wykorzystamy polecenie
        <code class="code-inline">banner motd # wiadomość #</code>, polecenie
        to wydajemy w trybie konfiguracji globalnej. Komunikat musi znajdować
        się między krzyżykami (<strong>#</strong>) i nie musi być to włącznie
        jedna linia (stąd znak początku i końca wiadamości).
      </p>
<pre class="code-block">
Switch(config)#banner motd # Osobom nieupowaznionym, wstep wzbroniony! #
Switch(config)#exit
</pre>
      <h2 id="1.2.5.savingconfig">1.2.5. Zapisywanie konfiguracji</h2>
      <p>
        Już we wcześniejszych przykładach wyświetlaliśmy obecnie działającą
        konfigurację. Ta konfiguracja rezyduje w pamieci RAM, która jest
        pamięcią ulotną. Jeśli urządzenia straci zasilanie i ono powróci
        to utracimy całą tą konfigurację, dlatego też urządzenia Cisco mają
        pamięć NVRAM, która jest nie ulotna. Ale to w naszej gestii jest aby
        tę konfigurację zapisać, chyba że dojdzie do sytuacji, że nie będziemy
        chcieli jej zapisać. Nie mniej jednak, aby zapisać konfirgurację w
        NVRAM należy w trybie uprzywilejowanym EXEC wydać następujące
        polecenie:
      </p>
<pre class="code-block">
Switch#copy running-config startup-config
Destination filename [startup-config]? 
Building configuration...
[OK]
Switch#
</pre>
      <p>
        Jeśli podejrzewamy, że obecna konfiguracja jest wadliwa możemy wrócić
        do konfiguracji startowej z NVRAM, wydając w trybie uprzywilejowanym
        EXEC polecenie:
      </p>
<pre class="code-block">
Switch#reload
Proceed with reload? [confirm]
</pre>
      <p>
        Przywrócenie urządzenia do ustawień fabrycznych dokonujemy za pomocą
        dwóch poleceń wydanych w trybie uprzywilejowanym EXEC.
      </p>
<pre class="code-block">
Switch#erase startup-config 
Erasing the nvram filesystem will remove all configuration files! Continue? [confirm]
[OK]
Erase of nvram: complete
%SYS-7-NV_BLOCK_INIT: Initialized the geometry of nvram
Switch#reload
Proceed with reload? [confirm]
</pre>
      <p>
        Korzystając z programu PuTTY możemy rejestrować naszą sesję połączenia
        z urządzeniem do pliku. W ten sposób możemy zrzucić sobie
        konfigurację do pliku tekstowego. Ustawienia <em>session/logging</em>.
      </p>
      <h2 id="1.2.6.configureipadressing">1.2.6. Konfiguracja adresacji IP</h2>
      <p>
        Z racji tego, że pomineliśmy konfigurację hostów z systemem Windows 10.
        Możemy przejść od razu do systemu IOS. W przypadku przełączników
        występuje coś takiego jak <strong>SVI</strong> - wirtualny interfejs
        przełącznika i to jemu nadajemy adres w przypadku tego urządzenia.
        W trybie konfiguracji globalnej przechodzimy do interfejsu <em>vlan1</em>
        następnie za pomocą polecenia
        <code class="code-inline">ip address 192.168.1.2 255.255.255.0</code>
        nadajemy mu adres IP, następnie musimy aktywować ten interfejs za
        pomocą polecenia <code class="code-inline">no shutdown</code>. Poniżej
        znajduje się przykład, pokazujący te czynności.
      </p>
<pre class="code-block">
Switch(config)#int vlan1
Switch(config-if)#ip addr 192.168.1.2 255.255.255.0
Switch(config-if)#no shutdown

Switch(config-if)#
%LINK-5-CHANGED: Interface Vlan1, changed state to up

Switch(config-if)#
Switch(config-if)#exit
</pre>
      <h3 id="1.2.6.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.5.5-packet-tracer---configure-initial-switch-settings_pl-PL.pdf">Konfiguracja ustawień początkowych przełączników - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.5.5-packet-tracer---configure-initial-switch-settings_pl-PL.pka">Konfiguracja ustawień początkowych przełączników - zadanie</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.7.6-packet-tracer---implement-basic-connectivity_pl-PL.pdf">Realizacja podstawowej łączności - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.7.6-packet-tracer---implement-basic-connectivity_pl-PL.pka">Realizacja podstawowej łączności - zadanie</a>
      </p>
      <h2 id="ch2summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy z system IOS firmy Cisco, poznaliśmy
        składnie poleceń, funkcję pomocy oraz przydatne skróty klawiszowe.
        Na koniec skonfigurowaliśmy przełącznik w podstawowym stopniu.
      </p>
      <h3 id="1.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.9.1-packet-tracer---basic-switch-and-end-device-configuration_pl-PL.pdf">Podstawowa konfiguracja przełącznika i urządzenia końcowego - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.9.1-packet-tracer---basic-switch-and-end-device-configuration_pl-PL.pka">Podstawowa konfiguracja przełącznika i urządzenia końcowego - zadanie</a>
      </p>
      <h3 id="1.2.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/2.9.2-lab---basic-switch-and-end-device-configuration_pl-PL.pdf">Podstawowa konfiguracja przełącznika i urządzenia końcowego</a>
      </p>
      <h1 id="1.3.protocolsandmodels">1.3. Protokoły i modele</h1>
      <p>
        Za pomocą protokół oraz modeli możemy wyjaśnić w jaki sposób urządzenia
        podłączone do sieci mogą uzyskać dostęp do jej zasobów.
      </p>
      <h2 id="1.3.1.therules">1.3.1. Zasady</h2>
      <p>
        Sieci komputerowe mogą być rożne pod względem wielkości oraz złożoności.
        Nie jest wystarczające połączenie między nimi, potrzebne jest również
        ustalenie wspólnych metod komunikacji. W każdej komunikacji istnieją
        trzy elementy: źródło (nadawca), cel (odbiorca) oraz kanał (medium),
        który umożliwia komunikację między jej składnikami.
      </p>
      <p>
        Większość komunikacji zarządzana jest za pomocą protokołów. Protokoły
        są zestawem zasad, które należy przestrzegać, aby komunikacja mogła
        dojść do skutku i te zasady mogą być rożne w zależności od protokołu, a
        strony komunikacji muszą je zaakceptować.
      </p>
      <p>
        Protokoły chcąc brać udział w komunikacji sieciowej muszą spełnić takie
        wymagania jak: kodowanie wiadomości, jej formatowanie oraz
        enkapsulacja, wielkość wiadomości czy możliwości jej dostarczenia
        są istotnym czynnikiem tutaj może być to rozłożenie etapów komunikacji
        w czasie.
      </p>
      <p>
        Kodowanie jest proces zmiany formy wiadomości do celów transmisji.
        Natomiast dekodowanie jest procesem odwrotnym do kodowania. Wiadomość
        powraca do pierwotnej formy w celu interpretacji.
      </p>
      <p>
        Wysyłana wiadomość musi mieć odpowiednią formę lub strukture. Zależy
        to od medium przez jakie jest przesyłana. Wiadomości przesyłane przez
        sieci muszą zostać skonwertowane do postaci bitów. Bity te są poźniej
        zamieniane na impulsy świetlne, dźwięk czy impulsy elektryczne. 
        Odbiorca musi ten proces odwrócić, aby móc odczytać wiadomość.
      </p>
      <p>
        Jak wspomniano istotny w komunikacji może być czas, w tym takie
        zagadnienia jak <strong>kontrola przepływu</strong>, która zarządza
        prędkością transmisji. Definiuje jak dużo informacji można przesłać i
        z jaką prędkością może ona zostać dostarczona. Inną wartoscią jest
        czas odpowiedzi, który określa ile jedna ze stron może czekać na
        odpowiedź od drugiej. Kolejnym czynnikiem definiującym poniekąd czas
        jest dostęp do łącza, w którym określane jest kiedy można wysłać
        wiadomość. Zapobiega to tworzeniu kolizji - sytuacji kiedy dwóch
        nadawców zaczyna nadawać na tym samym kanale w tym samym czasie. 
        Niektóre algorytmy
        dostępu do łącza wykrywają kolizje i organizują retransmisje
        uszkodzonych danych inne posiadają mechnizmy pozwalające na ich
        uniknięcie.
      </p>
      <p>
        Istnieje kilka sposobów na dostarczenie wiadomości. Najprostszą z nich
        <strong>unikast</strong>, mamy jednego nadawcę oraz jednego odbiorcę.
        W inny przypadku wiadomość może trafić do wielu odbiorców będących
        częścią tej samej grupy - <strong>multikast</strong>. Ostatni rodzaj
        dostarczenia to wiadomość skierowana do wszystkich odbiorców - 
        <strong>broadkast</strong>.
      </p>
      <h2 id="1.3.2.protocols">1.3.2. Protokoły</h2>
      <p>
        Protokoły sieciowe składają ze zbioru reguł. Mogą one określać
        zastosowania programowe oraz sprzetowe, jak i oba. Każdy protokół
        posiada własne funkcje, format czy zasady.
      </p>
      <p>
        Urządzenia wykorzystują uzgodnione protokoły. Mogą mieć one takie
        funkcje jak: adresacja - pozwalająca na identyfikację nadawcy i 
        odbiorcy; niezawodność - gwarancje dostarczenia danych; kontrolę
        przepływu - określającą optymalną prędkość dla przesyłanych danych;
        sekwencyjność - unikalne oznaczanie danych podczas transmisji;
        detekcję błędów - określenie czy jakieś dane nie zostały uszkodzone
        podczas transmisji oraz interfejs aplikacji - pozwalający na
        komunikację aplikacji z pośrednictwem tego protokołu.
      </p>
      <p>
        W komunikacji sieciowej wymagane jest stosowanie kilku protokołów,
        Każdy znich posiada swój format danych. Takimi protokłami są Ethernet,
        Internet Protocol (IP), Transmission Control Protocol (TCP) czy
        Hypertext Transfer Protocol (HTTP)
      </p>
      <h2 id="1.3.3.protocolsuites">1.3.3. Zestawy protokołów</h2>
      <p>
        Protokoły muszą być w stanie współpracować z innymi protokołami.
        <strong>Zestawy protokołów</strong> to grupa powiązanych ze sobą
        protokołów niezbędnych do komunikacji lub zbiór reguł współpracujących
        ze sobą w celu rozwiązania problemów. Protokoły są często postrzegane
        w kategoriach warstw: warstw wyższych czy niższych, które mają
        za zadanie przenieść dane oraz dostarczyć usługi warstwom wyższym.
      </p>
      <p>
        Obecnie mamy kilka różnych zestawów protokołów. Najczęściej spotykany,
        zarzązany przez IETF - 
        <strong>Internet Protocol Suite lub TCP/IP</strong>,
        <strong>Open Systems Interconnection protocols</strong>, rozwijany
        przez organizacje takie jak ISO wraz z ITU. Pozostałe takie
        <strong>Apple Talk</strong> czy <strong>Novell NetWare</strong> nie są
        już rozwijane ani stosowane w szerszej skali.
      </p>
      <p>
        Protokoły TCP/IP operują na warstwie aplkacji, transportu, czy 
        internetu. Protokołami dostępu do łącza, a zarazem najpopularniejszymi
        dla sieci LAN są Ethernet oraz WLAN (sieć bezprzewodowa). 
      </p>
      <p>
        Protokół TCP/IP jest stosem protokołów wykorzystywanym przez sieć
        Internet i zawierającą wiele protokołów. Jest to otwarty ogólnodostępny
        standard, który może zostać użyty przez dowolnego producenta. Jest on
        oparty na standardach przyjętych przez przedsiębiorstwa sieciowe oraz
        aktualizowany przez instytucje standaryzujące w celu zapewniania
        interoperatywności.
      </p>
      <p>
        Proces komunikacji w stosie TCP/IP wygląda następująco, że przeglądarka
        internetowa enkapsuluje stronę (przy użyciu TCP/IP) i wysyła ją do
        klienta. Klient
        dekapsuluje przy użyciu stosu TCP/IP i przekazuje do przeglądarki.
      </p>
      <h2 id="1.3.4.standardsorganizations">3.4. Organizacje standaryzujące</h2>
      <p>
        Otwarte standardy zapewniają interoperacyjność, konkurencyjność i
        innowacyjność. Organizacje standaryzujące są niepowiązane z żadnym z
        producentów sprzętu, organizacjami non-profit. Powołane aby 
        rozwijać koncepcje otwartych standardów.
      </p>
      <p>
        Wśród organizacji pracujących nad standardami internetowymi możemy
        wyróżnić dwie podstawowe: <strong>Internet Engineering Task Force
        (IETF)</strong> czy <strong>Internet Engieering Research Task Force
        (IRTF)</strong> - zajmują się one rozwojem oraz utrzymaniem
        wielu kluczowych technologii internetowych w tym stosu TCP/IP. Innymi
        organizacjami zajmującymi się Internet jest <strong>Internet
        Corporation for Assigned Names and Numbers (ICANN)</strong> oraz
        <strong>Internet Assigned Numbers Authority (IANA)</strong>, te
        organizacje
        zajmują się zarądzaniem różnego rodzaju numeracją, jak np. adresy IP,
        numery portów czy nazwami domenowymi.
      </p>
      <p>
        Innym rodzajemy standardów są standardy elektroniczne czy
        komunikacjyne, Do najpopularniejszych należą:
      </p>
      <ul>
        <li><strong>Institute of Electrical and Electronics Engineers (IEEE)</strong>
          - powołane w celach utworzenia standardów dla sektorta energetycznego,
            ochrony zdrowia, telekomunikacji oraz sieci komputerowych.</li>
        <li><strong>Electronic Industries Alliance (EIA)</strong> - opracowuje
          standardy dla okablowania elektrycznego, złączy czy standardu stojaków
          oraz szaf 19-calowych, w których montowane są urządzenia sieciowe
          oraz serwery.</li>
        <li><strong>Telecomunications Industry Association (TIA)</strong> -
          Rozwija standardy w osprzęcie radiowym, stacjach bazowych telefonii
          komórkowej, urządzenia typu VoIP, komunikacji satelitarnej oraz
          wielu innych.</li>
        <li><strong>International Telecommunications Union-Telecommunication
          Standardization Sector (ITU-T)</strong> - określa standardy np.
          dla kompresji wideo, protokołu Telewizji Internetowej (IPTV) czy
          łączy szerokopasmowych takich jak DSL.</li>
      </ul>
      <h3 id="1.3.4.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/3.4.4-lab---research-networking-standards_pl-PL.pdf">Badanie standardów sieciowych</a>
      </p>
      <h2 id="1.3.5.referencemodels">1.3.5. Model odniesienia</h2>
      <p>
        Przez złożoność koncepcji wyjaśnienie oraz zrozumienie jak
        działa sieci, może być trudne. W tym celu posługujemy się modelem
        odniesienia, modelem warstwowym. Do tego celu można wykorzystać
        <strong>model ISO/OSI</strong> oraz <strong>model TCP/IP</strong>.
        Generalnie posługujemy się modelem TCP/IP, jeśli nie musimy zagłębić
        się zasady działania aplikacji. Warstwa SSL dla HTTP to ta sama
        warstwa modelu TCP/IP ale inna w modelu ISO/OSI. W nomenklatrzue
        rozwiązań firmy Cisco również używa się modelu ISO/OSI.
      </p>
      <p>
        Model odniesienia pomaga w projektowaniu protokołów, umożliwia
        współpracę producentów urządzeń, chroni przed wpływem technologii
        z innych warstw na siebie, dostarcza wspólnego języka do opisu funkcji
        oraz możliwości sieci.
      </p>
      <p>
        Model referencyjny OSI prezentuje się następująco:
      </p>
      <ul>
        <li><strong>Warstwa aplikacji</strong> - Zawiera protokoły wykorzystywane do
          komunikacji między procesami.</li>
        <li><strong>Warstwa prezentacji</strong> - Dostarcza ogólnej
          prezentacji danych przesyłanych między aplikacjami.</li>
        <li><strong>Warstwa sesji</strong> - dostarcza usług dla warstwy
          prezentacji i zarządza wymianą danych.</li>
        <li><strong>Warstwa transportowa</strong> - określa usługi dla
          segmentacji, transferu oraz ponownego złożenia danych dla
          poszczególnych połączeń.</li>
        <li><strong>Warstwa sieciowa</strong> - dostarcza usług w celu
          wymiany indywidualnych fragmentów danych poprzez sieć.</li>
        <li><strong>Warstwa łącza danych</strong> - określa metody wymiany
          ramek danych przez popularne media.</li>
        <li><strong>Warstwa fizyczna</strong> - określa znaczenie dla
          aktywacji, zarządzania i deaktywacji połączeń fizycznych.</li>
      </ul>
      <p>
        Natomiast model TCP/IP jest podobobny. Nie skupia on sie za bardzo na
        protokołach i aplikacjach oraz na warstwie fizycznej. Dlatego też z 7
        warstw zostały 4. Warstwy sesji, prezentacji oraz aplikacji zostały
        połączone w jedną warstwę aplikacji, natomiast warstwa fizyczna i
        łącza danych zostały połączone w jedną warstwę dostępu do łącza.
      </p>
      <h3 id="1.3.5.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/3.5.5-packet-tracer---investigate-the-tcp-ip-and-osi-models-in-action_pl-PL.pdf">Badanie modeli TCP/IP i OSI w działaniu - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/3.5.5-packet-tracer---investigate-the-tcp-ip-and-osi-models-in-action_pl-PL.pka">Badanie modeli TCP/IP i OSI w działaniu - zadanie</a>
      </p>
      <h2 id="1.3.6.dataencapsulation">1.3.6. Enkapsulacja danych</h2>
      <p>
        Segmentacja jest procesem rozbijania wiadmości na mniejsze jednostki.
        Multipleksacja jest procesem wysyłania wielu segmentów jednocześnie.
        Segmentacja ma dwie podstawowe zalety: zwiększa prędkość oraz 
        zwiększa wydajność.
      </p>
      <p>
        Sekwencyjnosć wiadomości jest procesem numeracji segmentów, zapewnia
        to możliwość dostarczenia wiadomości w takiej samej kolejności jak
        została wysłana.
      </p>
      <p>
        Enkapsulacja to proces, w którym protokoły dodają swoje dane, na każdym
        etapie tego procesu, PDU - <strong>jednostka danych protokołu</strong>
        (ang. <em>Protocol Data Unit</em>) ma inną nazwę aby odwzorować 
        jej funkcje. Nie ma jednej ogólnej nazwy dla PDU, chociaż stosuje w 
        mowie potocznej określenie <strong>pakiet</strong>. Są one nazywane
        powiązane protokołami stosu TCP/IP, opuszczając stos PDU nazywane są
        kolejno:
      </p>
      <ol>
        <li>Dane (strumień danych)</li>
        <li>Segment</li>
        <li>Pakiet</li>
        <li>Ramka</li>
        <li>Bity</li>
      </ol>
      <p>
        Enkapsulacja jest procesem, który jest przeprowadzany od z góry na dół.
        Górne poziomy przekazuje dane/PDU w dół do dolnych warstw, które
        obudowywują dane z góry w dane kontrolne PDU obecnej warstwy, aż do
        formy strumienia bitów. 
      </p>
      <p>
        Deenkapsulacja jest procesem odwrotnym, tutaj strumień bitów zamieniany
        jest do postacji ramki, kiedy dane wędrują w górę poszczególne warstwy
        dokonują przetwarzania swoich danych kontrolnych, a następnie usuwają
        swoje dane kontrolne i przekazują dane wyżej, aż do aplikacji.
      </p>
      <h2 id="1.3.7.dataaccess">1.3.7. Dostęp do danych</h2>
      <p>
        Obie warstwy: łacza danych oraz warstwa sieciowa, wykorzystują adresy
        aby dostaczyć dane od źródła do celu. Warstwa sieciowa wykorzystuje
        adresy IP do adresacji pakietów, w przypadku warstwy łącza danych
        wykorzystywane są adresy fizyczne kart sieciowych (adresy MAC).
      </p>
      <p>
        Pakiet IP zawiera dwa adresy IP, adres źródłowy określający twórcę
        wiadomości oraz adres docelowy określający odbiorcę.
      </p>
      <p>
        Adres protokół warstwy sieciowej dzielą się na dwie części: część
        sieciową (dla IPv4) lub prefiks (dla IPv6) oraz cześć hosta
        (dla IPv4) lub identyfikator interfejsu (IPv6). Urządzenia w tej samej
        sieci, mają takie same części sieciowe lub prefiksy.
      </p>
      <p>
        Urządzenia w tej samej sieci Ethernet, do adresacji ramek wykorzystają
        już właściwe dla adresy MAC przypisane do fizycznych kart sieciowych.
        Jeśli odbiorca znajduje się w innej sieci, to wówczas adres MAC nadawcy
        ulegnie zmianie, na adres MAC routera, tak aby odbiorca wiedział gdzie
        ma odesłać odpowiedź.
      </p> 
      <p>
        Ciekawie jest przypadku warstwy sieciowej, to jeśli odbiorca pakietu
        nie należy do naszej sieci wówczas pakiet IP zostanie zaadresowany
        docelowym adresm IP odbiorcy, ale ramka zostanie zaadresowana adresem
        <strong>bramy domyślnej</strong> - routera, który zapewnia nam dostęp
        do innej sieci. Każdy z hostów zawiera informacje jak ma adresować
        pakiety IP i przez jakie interfejsy (karty sieciowe) je wysłać.
        Brama domyślna jest hostem do którego należy przesłać pakiety, kiedy
        host nie wie gdzie ma je przesłać. Jest to trasa ostatniej szansy.
        Router przekazując ten pakiet już do sieci docelowej lub na swoją
        bramę przepakuje go w nową ramkę, opatrzoną w adresy fizyczne
        nadawcy (swojego interfejsu WAN) oraz odbiorcy. Ten pakiet może przejść
        kilka takich etapów zanim trafi do odbiorcy. Podobnie jest z
        odpowiedzią.
      </p>
      <h3 id="1.3.7.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/3.7.9-lab---install-wireshark_pl-PL.pdf">Instalacja programu Wireshark</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/3.7.10-lab---use-wireshark-to-view-network-traffic_pl-PL.pdf">Wykorzystanie programu Wireshark do badania ruchu sieciowego</a>
      </p>
      <h2 id="ch3summary">Podsumowanie</h2>
      <p>
        W tym rozdziale poznalismy w jaki sposób przebiega komunikacja i jakie
        warunki trzeba spełnić. Poznaliśmy protokoły, ich stosy oraz
        organizacje standaryzujące. Dowiedzielismy czym są modele odniesienia
        i doczego służą. Zapoznalismy się z enkapsulacją danych oraz jak
        faktycznie wygląda dostęp do danych.
      </p>
      <h1 id="1.partialexam">Egzamin cząstkowy</h1>
      <p>
        Po omówieniu 3 rozdziału spotkamy się z przedsmakiem egzaminu końcowego
        mianowicie egzaminem cząstkowym obejmującym od 2 do 3 tematów. W
        większości przypadków będą to trzy tematy. Egzamin składa się z pytań
        jednokrotnego oraz 2 lub 3-krotnego wyboru oraz pytań polegających
        na przypasowaniu definicji do pojęcia - oczywiście jest to pojęcie
        względne, ponieważ nie zawsze definicje oraz pojęcia faktycznie nimi
        będą. Taki przypadek możemy spotkać na podstawie przypisania opisu
        do konkretnego adresu. Egzaminy cząstkowe łączą test teoretyczny z
        zadaniem praktycznym do wykonania w Packet Tracerze. Na całość mamy
        60 minut. Liczba pytań wacha się od 30 do 35 pytań.
      </p>
      <p>
        Wszystkie egzaminy zdajemy na platformie
        <a href="netacad.com">netacad.com></a>. Mamy możliwość jednego
        podejścia oraz jednej poprawki przy czym poprawkę musi umożliwić nam
        prowadzący kurs. Do wyboru są dwa języki: ojczysty oraz język
        angielski. Z językiem ojczystym jak jest każdy wie. Przy czym warto
        dodać, że końcowy egzamin praktyczny jest wyłącznie w języku
        angielskim.
      </p>
      <h1 id="1.4.physicalayer">1.4. Warstwa fizyczna</h1>
      <p>
        Warstwa fizyczna skupia w sobie wiele technologii związanych z
        fizycznym podłączeniem hostów oraz standardów tych połączeń.
      </p>
      <h2 id="1.4.1.purposeofthephysicallayer">1.4.1. Przeznaczenie wartstwy sieciowej</h2>
      <p>
        Aby w ogóle komunikacja sieciowa mogła zajść potrzebne są połączenia
        fizyczne między jej stronami. W zależości od konfiguracji sieci
        połączenia mogą być przewodowe lub bezprzewodowe. Podłączenie do sieci
        uzyskujemy za pomocą urządzeń kart sieciowych wbudowanych w nasze
        urządzenia, oczywiście nie wszystkiego rodzaju połaczenia fizyczne
        mają taka samą wydajność.
      </p>
      <p>
        Warstwa fizyczna znajmuje się transportem bitów przez media sieciowe,
        odbiera ona ramkę z warstwy łącza danych koduje ją za pomocą serii
        sygnałów, które są następnie transmitowane za pomocą lokalnego medium.
        Warstwa fizyczna kodując i dekodując ramkę, kończy proces enkapsulacji
        lub rozpoczyna proces deenkapsulacji.
      </p>
      <h2 id="1.4.2.physicallayercharacteristics">1.4.2. Charakterystyka warstwy fizycznej</h2>
      <p>
        Standardy zastosowane w sprzęcie sieciowym są zarządzane przez wiele
        organizacji takich jak: ISO, EIA/TIA, ITU-T, ANSI, IEEE.
      </p>
      <p>
        Standardy warstwy fizycznej operują na dwóch płaszczyznach:
        kompnentów fizycznych, kodowania oraz sygnałów. Komponenty takie jak
        urządzenia sprzętowe, media czy różnego rodzaju wtyczki są
        odpowiedzialne z transmisję sygnału reprezentującego bity. Karty
        sieciowe, złacza, wtyczki czy same przewody są uwzględnione w
        standardach warstwy fizycznej.
      </p>
      <p>
        Kodowanie ma celu dostosowanie strumienia bitów do formatu
        rozpoznawalnego przez następne urządzenia w sieci poprzez użycie
        przewidywalnych schematów, które mogą być przez nie rozpoznane.
        Kodowanie obejmuje takie metody jak: Manchester, 4B/5B czy 8B/10B.
      </p>
      <p>
        Sygnały natomiast są sposobem reprezentacji bitów (wartości 1 oraz 0)
        w medium transmisyjnym. Metoda wybranej syganlizacji może być bardzo
        różna i często jest uzależniona oraz wykorzystywanego medium.
      </p>
      <p>
        Szerokość pasma jest możliwością nośną pasma. Dla cyfrowych szerokości
        pasma mierzona jest na podstawie ilości danych, które mogą zostać
        przesłane z jednego miejsca w drugie w określonej ilości czasu. Jak
        dużo bitów można przesłać w przeciągu jednej sekundy 
        (<strong>bps</strong>, <em>bits per second</em>). Właściwosci medium,
        wykorzystane technologie czy prawa fizyki mają wpływ na dostępną
        szerokość. Z szerokością pasma są związane pewne pojęcia.
      </p>
      <ul>
        <li><strong>Opóźnienia</strong> (ang. <em>latency</em>) - ilość czasu
          wraz opóźnieniami potrzebna danym do pokonania trasy z jedne do
          drugiego punktu.</li>
        <li><strong>Przepustowość</strong> (ang. <em>Throughput</em>) - miara
          transferu bitów przez medium transmisji w określonym odstępie czasu.</li>
        <li><strong>Przepustowość na poziomie aplikacji</strong>
          (ang. <em>Goodput</em>) - miara użytecznych danych przesłanych w
          w danej jednostce czasu.</li>
      </ul>
      <h2 id="1.4.2.coppercabling">1.4.2. Okablowanie miedziane</h2>
      <p>
        Okablowanie jest najczęściej stosowanym rodzajem okablowania w sieciach
        obecnie, jest ono tanie i łatwe do instalacji. 
      </p>
      <p>
        Posiada ono również swoje wady takie jak osłabienie sygnału wynikające
        z zadługiego pojedynczego odcinka przewodu oraz wrażliwość na róznego
        rodzaje zakłócenia elektromagnetycze w tym przesłuchy. 
      </p>
      <p>
        Ze względu na to, że okablowanie miedziane jest tak popularne pojawiły
        się rozwiązania powyższych problemów takich jak: wytyczne pojedynczego
        odcinka kabla, ekranowanie przewodów wraz uziemieniem skręcenie ze sobą
        poszczególnych przewodów w pary eliminując przesłuchy.
      </p>
      <p>
        Rodzaje kabli miedzianych:
      </p>
      <ul>
        <li><em>Unshielded Twisted-Pair Cable</em> - Kabel UTP</li>
        <li><em>Shielded Twisted-Pair Cable</em> - Kabel STP</li>
        <li><em>Coaxial Cable</em> - Kabel koncetryczny</li>
      </ul>
      <p>
        Kable UTP są najczęsciej spotykami przewodami sieciowymi, są one
        najczęściej zakończone za pomocą wtyku <strong>RJ-45</strong>,
        najczęściej łączą hosty z urządzeniami pośrednimi, jakimi jak
        przełączniki.
      </p>
      <p>
        Kable UTP składają się z zewnętrznej izolacji chroniącej kabel przed
        uszkodzeniami zewnętrznymi oraz skręconych par przewódów
        (skręcenie ma zadanie zniwelować przesłuchy) w kolorowych izolacjach
        mających na celu identyfikację każdego z przewodów, każdej z żył.
      </p>
      <p>
        Kable STP są rozszerzeniem kabli UTP o dodatkowe środki
        przeciwdziałające zakłóceniom, jak za folia aluminiowa otaczająca
        poszczególne pary czy siatka miedziana otaczająca wszystkie przewody.
      </p>
      <p>
        Ostatnim rodzajem kabli miedzianych są kable koncentryczne
        wykorzystywane do antent sieci bezprzewodowych oraz kablowych
        technologiach dostęp do Internetu, takich jak DOCSIS. Taki table
        składa się z zewnętrznej grubszej izolacji, siatki miedzianej
        niewelującej zakłócenia, plastikowej elastycznej izolacji przewodnika
        oraz przewodnika.
      </p>
      <h2 id="1.4.3.utpcabling">1.4.3. Okablowanie UTP</h2>
      <p>
        Kabel UTP składa się z 4 par oznaczonych kolorami przewodów skrecony
        ze soba wewnątrz giętkiej plastikowej izolacji. Kable UTP nie posiadają
        żadnej dodatkowej ochrony przez zakłóceniami. Zastosowane w kablach
        UTP takie rozwiązania jak <strong>znoszenie</strong>, każdy przewód w
        parze ma inną polaryzację, przez co skręcone ze sobą skutecznie znoszą
        zakłócenia generowane przez siebie czy wariacja w
        w ilości skręceń na ok. 30cm zapobiera przesłuchą powodowany przez
        inne pary przewodów pomagają w niwelowaniu przesłuchów. 
      </p>
      <p>
        Kable UTP podlegają standaryzacji, którą zarządza organizacja EIA/TIA.
        Definiują ona standarad TIA/EIA-568 w którym znajdują się takie
        zagadnienia jak: Typ kabla, jego długość, rodzaje wykorzystywanych
        wtyczek, metody terminacji przewódu (w tym instalacji) sposoby
        testowania. Parametrami elektrycznimi kabli UTP zajęła się organizacja
        IEEE i do dyspozycji mamy takie kategorie jak: kategoria 3,
        kategoria 5 lub 5e czy kategoria 6.
      </p>
      <p>
        Terminując kable, mamy dyspozycji dwa standardy oraz dwa rodzaje
        takiego zarobionego przewodu. Mianowicie standardy takie jak
        TIA/EIA T568B oraz T568A definiują ułożenie kolorowych przewodów we
        wtyczce. Obecnie standardem jest T568B, T568A wyszedł z użycia jednak
        przydaje się jego znajomość gdy musimy za pomocą sieci spiąć ze sobą
        dwa komputery. W wyżej wymienionych standardardach możemy ułożyć
        przewody w następujący sposób:
      </p>
      <ul>
        <li><strong>T568A</strong> -
          <ol>
            <li>biało-zielony</li>
            <li>zielony</li>
            <li>biało-pomarańczowy</li>
            <li>niebieski</li>
            <li>biało-niebieski</li>
            <li>pomarańczowy</li>
            <li>biało-brązowy</li>
            <li>brązowy</li>
          </ol></li>
        <li><strong>T568B</strong> - 
          <ol>
            <li>biało-pomarańczowy</li>
            <li>pomarańczowy</li>
            <li>biało-zielony</li>
            <li>niebieski</li>
            <li>biało-niebieski</li>
            <li>zielony</li>
            <li>biało-brązowy</li>
            <li>brązowy</li>
          </ol>
        </li>
      </ul>
      <p>
        Dwie możliwości zrobienia wtyczek, dają nam dwa rodzaje kabli:
      </p>
      <ul>
        <li><strong>Kabel prosty</strong> - zakończony z obu stron zgodnie ze
          jednym standardem. Obecnie wykorzystywany zgodnie ze standardem jest
          T568B, kabel wykorzystywany do większości połączeń.</li>
        <li><strong>Kabel krosowy</strong> - zakończony przy użyciu różnych
          standardów. Dzis może zostać wykorzystany do połączenia
          bezpośredniego, pomiędzy dwoma komputerami lub dwoma takimi samymi
          urządzeniami Cisco.</li>
      </ul>
      <h2 id="1.4.5.fiberopticcabing">1.4.5. Okablowanie światłowodowe.</h2>
      <p>
        Okablowanie światłowodowe nie jest tak popularne jak UTP, ze względu
        na drogi osprzęt oraz trudności w instalacji. Jest wstanie przesyłać
        dane na długie dystanse oraz z dużą szybkością, całkowicie odporne na
        zakłócenia elektromagnetyczne. Światłowody służa przewodzenia implusów
        świetlnych pomiędzy dwoma ich końcami z minimalną utratą sygnału, są
        zrobione z cienkich włókien bardzo czystego szkła, do zakodowania
        bitów w impulsy światła wykorzystują diody laserowe lub diody led.
      </p>
      <p>
        Światłowody dzielą sie na jedno i wielomodowe. W budowie różnią się
        w średnicy rdzenia, w światłowodzie jednomodowym jest on o wiele
        cieńszy, gdyż będzie on obsługiwać tylko jeden promień świetlny.
        Wykorzystanie światłowodów jednomodowych jest również dużo droższe, ale
        przesyłaja dane z ogromną prędkością na długi dystans. W światłowodach
        wielomodowych zachodzi zjawisko dyspersji, czyli rozpraszania się
        światła, dlatego też światłowody wielomodowe są stosowane na
        ograniczony dystans, ale dla wielu firm jest on zupełnie wystarczający.
      </p>
      <p>
        Z okablowaniem światłowodowym możemy spotkać się kilku rożnych
        rodzajach firm:
      </p>
      <ul>
        <li><strong>Sieci dużych firm</strong> - wykorzystanie światłowodu jako
          sieć szkieletowa w celu połączanie infastruktury.</li>
        <li><strong>Technologia FTTH</strong> - Usługa szerokopasmowego
          połączenia dla domów oraz małych firm.</li>
        <li><strong>Sieci długodystansowe</strong> - sieci łączące kraje czy
          większe miasta.</li>
        <li><strong>Podwodne światłowody morskie</strong> - swiatłowody o
          dużej przepustowości do połączeń transoceanicznych.</li>
      </ul>
      <p>
        Okablowanie światłowodowe jest wykorzystywane głównie jako sieć
        szkieletowa łączaca ze soba punkty dostępowe w wewnątrz budynku czy
        między budnkami na większym terenie.
      </p>
      <h2 id="1.4.6.wirelessmedia">1.4.6. Medium bezprzewodowe</h2>
      <p>
        Działanie sieci bezprzewodowych opiera się na nośności bitów danych
        z wykorzystaniem sygnałów elektromagnetycznych na częstotliwości
        radiowej lub mikrofalowej. Sieci tego typu zwiększają mobilność, jednak
        nie bez wad. 
      </p>
      <p>
        Głównymi problemami sieci bezprzewodowych jest zasięg, który może
        ograniczać nam dostęp za pośrednictwem tego medium. Kolejnym czynnikiem
        mogą być zakłócenia, które może powodować wiele urządzeń.
        Bezpieczeństwo jest również cechą decydującą, nawet jeśli nasza sieć
        działa na niewielkim obszarze, to napastnik może wyposażyć się w taki
        sprzęt który pozwoli mu zebranie kilku istotnych informacji. Dość
        istotną sprawą jest samo działanie sieci bezprzewodowej, urządzenia
        podłączone do takiej sieci współdzielą to samo łącze, więc jesli
        będzie ich stosunkowo dużo to przepustowość może spaśc dość znacząco.
      </p>
      <p>
        Organizacja IEEE wraz z inną instytucją standaryzjąca sporządziła
        serię standardów dla sieci bezprzewodowych. Opisują one miedzy
        innymi: metody kodowania sygnałów, częstotliwość oraz moc nadawania,
        odbiór sygnału oraz dekodowanie transmisji czy wytyczne dotyczące
        anten. Takim standardami są:
      </p>
      <ul>
        <li><strong>WiFi (IEEE 802.11)</strong> - technologia Wireless LAN</li>
        <li><strong>Bluetooth (IEEE 802.15)</strong></li>
        <li><strong>WiMAX (IEEE 802.16)</strong></li>
        <li><strong>Zigbee (IEEE 802.15.4)</strong></li>
      </ul>
      <p>
        Ogólnie to podłączenie sie do sieci WLAN może wymagać takich urzązeń
        jak punkt dostępowy, umożliwiający dostęp użytkownikom WLAN-u do sieci
        kablowej oraz karty sieciowe sieci bezprzewodowej. Przy zakupie
        sprzetu bezprzewodowego należy pamiętać aby ten sprzęt był kompatybilny
        ze sobą, często wystarczy zgodność obu wyżej wymienionych urządzeń
        z jednym ze standardów sieci bezprzewodowej.
      </p>
      <p>
        Przy rozważaniu wdrożenia sieci bezprzewodowej, trzeba również
        uwzględnić dla niej odpowiednią politykę bezpieczeństwa.
      </p>
      <h3 id="1.4.6.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/4.6.5-packet-tracer---connect-a-wired-and-wireless-lan_pl-PL.pdf">Łączenie przewodowych oraz bezprzewodowych sieci LAN - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/4.6.5-packet-tracer---connect-a-wired-and-wireless-lan_pl-PL.pka">Łączenie przewodowych oraz bezprzewodowych sieci LAN - zadanie</a>
      </p>
      <h3 id="1.4.6.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/4.6.6-lab---view-wired-and-wireless-nic-information_pl-PL.pdf">Wyświetlanie informacji o przewodowych i bezprzewodowych kartach sieciowych</a>
      </p>
      <h2 id="ch4summary">Podsumowanie</h2>
      <p>
        W tym rodziale rozpoczeliśmy analizowac model sieciowy ISO/OSI.
        Zapoznalismy się z funkcjami warstwy fizycznej. Scharakteryzowaliśmy
        każde medium jakie możemy spotkać w sieci.
      </p>
      <h1 id="1.5.numbersystems">1.5. Systemy liczbowe</h1>
      <p>
        Z systemami liczbowymi, spotykamy się na co dzień licząc lub
        wykorzystując jego cyfry. Ludzie naturalnie wykorzystują bowiem system
        dzięsiętny, które podstawą jest liczba 10 oraz znaki od 0-9. W
        przypadku komputerów, wykorzystywane jest ich znacznie więcej a takimi
        podstawowymi są: system binarny oraz system heksadecymalny oba te
        systemy znajdują swoje zastosowanie w sieci.
      </p>
      <h2 id="1.5.1.binarynumbersystem">1.5.1. Binarny system liczbowy</h2>
      <p>
        Binarny system liczbowy składa się z 1 oraz 0 nazywanych bitami.
        Adresy protokołu IP zapisem poniękąd binarnym, adres składa się z
        ciągu 32-bitów podzielonych na cztery sekcje zwane oktetami. Każdy
        oktet składa się 8 bitów lub jednego 1 bajtu. Jednak ludzie w celu
        uproszczenia sobie nieco pracy wykorzysują zapis dziesiętny,
        konwertując poszczególne oktety. Dlatego też oktety adresów IP 
        posiadają zakres wartości od 0 do 255.  
      </p>
      <p>
        Binarny system liczbowy podobnie do systemu dziesiętnego jest systemem
        pozycyjnym. Pozycyjność polega na tym, że cyfry reprezentują wartości
        na podstawie pozycji, na której się znajdują w sekwencji cyfr (liczbie).
        Spójrzmy na poniższy przykład, prostą liczbą dzięsiętną, którą możemy
        rozpatrzyć pod kątem pozyjności może być: 1234.
      </p>
<pre class="code-block">
1 x 10^3 (1000) = 1000
  +
2 x 10^2 (100)  = 200
  +
3 x 10^1 (10)   = 30
  +
4 x 10^0 (1)    = 4
</pre>
      <p>
        Podobnie jest z cyframi binarnymi, tak jak tutaj brano po uwagę potęgę
        wykładnika jakim jest liczba 2. Rozważmy sobie przykład liczby:
        10110010.
      </p>
<pre class="code-block">
1 x 2^7 (128) = 128
  +
0 x 2^6 (64)  = 0
  +
1 x 2^5 (32)  = 32
  +
1 x 2^4 (16)  = 16
  +
0 x 2^3 (8)   = 0
  +
0 x 2^2 (4)   = 0
  +
1 x 2^1 (2)   = 2
  +
0 x 2^0 (1)   = 0
              = 178
</pre>
      <p>
        Analizując pozycyjność cyfr binarnych, przypadkiem dowiedzieliśmy się
        w jaki sposób możemy dokonąć konwersji wstecznej z cyfr binarnych na
        postać dziesiętną.
      </p>
      <p>
        Konwersji liczb dziesiętnych możemy dokonać w na dwa sposóby. Jednym
        z nich może być metoda pisemna. Polega ona na dzieleniu liczby przez
        dwa do momentu uzyskania 0, przyczym wiemy, że nie wszystkie liczby
        dzielą się na dwie równe częsci. Ta pozostałosc to reszta z dzielenia
        i przeważnie w wyniku dzielnia przez dwa jej wartość nie będzie
        wynosić więcej niż 1. Dlatego też reszta z dzielenia albo będzie
        występować (wówczas, będzie wynosić 1) albo jej nie będzie ponieważ
        cyfra podzieli się równo. Czy ten schemat nam coś przypomina. Tak,
        reszta z dzielenia to nasza wartość binarna. Ale tutaj jest pewien
        haczyk.
      </p>
<pre class="code-block">
178 / 2 = 89 | 0
89  / 2 = 44 | 1
44  / 2 = 22 | 0  /\
22  / 2 = 11 | 0  ||
11  / 2 = 5  | 1  ||
5   / 2 = 2  | 1  ||
2   / 2 = 1  | 0   
1   / 2 = 0  | 1
</pre>
      <p>
        Otóż wartości reszty z dzielnia są odczytywane z dołu do góry.
        178<sub>DEC</sub> = 10110010<sub>BIN</sub>.
      </p>
      <p>
        Inny sposóbem jest próba oszacowania. Bierzemy na 178 i szukamy
        nawiększej potęgi dwójki mniejszej od naszej liczby w tym przypadku
        jest 128.
        Następnie sprawdzamy czy nasza liczba 
        jest większa bądź równa 128. No tak. Zatem zapisujemy skranie po
        lewej
        stronie 1 i odejmujemy od naszej liczby bazowej 128 (178-128) pozostaje
        nam 50 itd. tak jak na przykładzie.
      </p>
<pre class="code-block">
178 &gt;= 128 = 1
178 - 128 = 50
50 &gt;= 64 = 0
50 &gt;= 32 = 1
50 - 32 = 18
18 &gt;= 16 = 1
18 - 16 = 2
2 &gt;= 8 = 0
2 &gt;= 4 = 0
2 &gt;= 2 = 1
2 - 2 = 0
0 &gt;= 1 = 0

10110010
</pre>
      <p>
        Postać binarna zamienianej liczby powstaje z wyników warunków
        logicznych jeśli przyjmiemy, że <em>Tak</em> to 1 a <em>Nie</em> to 0.
        Ta metoda pozwala na przeliczanie liczb w pamięci. Metodę odwrotnej
        konwersji już poznalismy przy poznawania pozycyjności.
      </p>
      <h2 id="1.5.2.hexadecimalnumbersystem">1.5.2. System szesnastkowy</h2>
      <p>
        System heksadecymalny w przypadku sieci może przydzać się do
        zrozumienia IPv6. System ten wykorzysuje jako bazę 16 cyfr 0-9 oraz
        od A-F. Jedna cyfrę heksadecymalną możemy wyrazić za pomocą 4 binarnych
        bitów. System ten jest wykorzystywany tak jak wcześniej wspomniano do
        IPv6 oraz adresów fizycznych.
      </p>
      <p>
        Chcąc skonwertować liczbę dziesiętna na heksadecymalną, możemy posłużyć
        się metodą pisemną tylko zamiast 2 użyć liczby 16. Raczej nie bedzie
        takie potrzeby aby to robić. Innym rodzajem konwersji możebyć
        przeliczenie z systemu binarnego na szesnastkowy. Tutaj nie trzeba
        nic przeliczać, wystarczy odwołać się do tabelki o poniżej.
      </p>
<pre class="code-block">
0000 = 0
0001 = 1
0010 = 2
0011 = 3
0100 = 4
0101 = 5
0110 = 6
0111 = 7
1000 = 8
1001 = 9
1010 = A
1011 = B
1100 = C
1101 = D
1110 = E
1111 = F
</pre>
      <p>
        Jeśli mamy przeliczyć cyfrę dziesiętna to możemy zrobić to bezpośrednio
        przez metodę pisemną lub pośrednio, zamienić ją na system binarny bo
        taki jest prosty do przeliczenia a następnie zgodnie z tablą powyżej
        zamienić 8 bitów binarnych na dwie cyfry heksadecymalne dające
        żądana liczbę. Pamiętamy że nasze 178 to 10110010 to chcąc zamienić tę
        liczbę na system szesnastkowy możey zrobić to tak:
      </p>
<pre class="code-block">
178 = 1011 0010
       B     2
178 = B2

B = 1011
2 = 0010
B2 = 10110010 = 178
</pre>
      <h2 id="ch5summary">Podsumowanie</h2>
      <p>
        W tym jakże, krótkim rozdziale poznaliśmy dwa podstawowe system
        liczbowe wykorzystywane także w sieciach. Nauczyliśmy się konwersji
        z systemu 10 na binarny oraz z systemu binarnego na szesnastkowym i
        odwrotnie. Konwersja systemów a w szczególności z dziesiętnego na
        binarny będzie nam potrzebna do podziału sieci na podsieci oraz
        metody VLSM.
      </p>
      <h1 id="1.6.datalinklayer">1.6. Warstwa łącza danych</h1>
      <p>
        Warstwa łącza danych jest pierwszą warstwą, w której możemy spotkać się
        jaką komunikacją logiczną. Sztandarowym protokołe tej warstwy jest
        Ethernet a podstawową jednostką przesyłanych danych jest ramka.
      </p>
      <h2 id="1.6.1.purposeofdatalinklayer">1.6.1. Przeznaczenie warstwy łącza danych</h2>
      <p>
        Warstwa łącza danych jest odpowiedzialna za komunikację pomiędzy
        kartami sieciowymi, pozwala warstwą wyższym na dostęp do medium
        fizycznego oraz enkapsuluje pakiety warstwy 3 w ramki warstwy drugiej
        oraz dokonuje detekcji błędów i odrzuca uszkodzone ramki.
      </p>
      <p>
        Standardy IEEE 802 LAN/MAN określają typ sieci (Ethernet, WLAN, WPAN
        itd.). Warstwa łącza danych składa się z dwóch podwarstw:
        <strong>Logical Link Control</strong> (LLC) oraz
        <strong>Media Access Control</strong> (MAC). Podwarstwa LLC zapewnia
        komunikację pomiędzy oprogramowaniem sieciowym z warstw wyższych a
        sprzętem z warstwy niższej, natomiast podwastwa MAC odpowiedzialna jest
        za enkapsulację danych oraz dostęp do łącza fizycznego.
      </p>
      <p>
        Pakiety wymieniane między hostami, mogą doświadaczać wielu zmian
        na poziomie warstw niższych, dla porównania jeśli router odbierze
        ramkę to musi ją za akceptować na swojej karcie sieciowej, następnie
        zdekapsulować aby uzyskać potrzebne mu dane. Po wykonaniu czynności
        pakiet jest enkapsulowany ponownie w nową ramkę i przekazany za pomocą
        medium transmisjnego do następnej sieci. 
      </p>
      <p>
        Protokoły warstw łacza danych zostały zdefiniowane przez takie
        organizacje inżynieryjne jak: <em>Institute of Electrical and Electronic
        Engineers</em> (<strong>IEEE</strong>),
        <em>International Telecomunications Union</em> (<strong>ITU</strong>),
        <em>International Organizations for Standarization</em> 
        (<strong>ISO</strong>)
        <em>American National Standards Institute</em> (<strong>ANSI</strong>).
      </p>
      <h2 id="1.6.2.topologies">1.6.2. Topologie</h2>
      <p>
        Toplogia sieciowa jest układ między urządzenia sieci oraz połączeniami
        występującymi między nimi. Rozróżniamy dwa rodzaje topologi:
      </p>
      <ul>
        <li><strong>Fizyczna</strong> - przedstawiająca fizyczne połaczenia
          miedzy urządzeniami, np. użyte medium transmisji czy rodzaj 
          podłączenia między nimi.</li>
        <li><strong>Logiczna</strong> - przedstawiająca połaczenia wirtualne,
          interfejsy czy adresację IP.</li>
      </ul>
      <p>
        W sieciach rozległych możemy wyróżnić kilka topologi fizycznych takich
        jak:
      </p>
      <ul>
        <li><strong>Point-to-point</strong> - najprostsza i naczęsciej
          spotykana topologia WAN. Składa się ona ze stałego połączenia
          pomiędzy dwoma punktami końcowymi.</li>
        <li><strong>Hub and spoke</strong> - podobna do topologii gwiazdy
          gdzie centralne urządzenie pośrednicy pomiędzy połączeniami
          <em>point-to-point</em>.</li>
        <li><strong>Mesh</strong> - topologia dostarcza wysoki stopień
          dostępności usług, ale wymaga aby system były ze sobą połączone
          na zasadzie każdy z każdym.</li>
      </ul>
      <p>
        Urządzenia końcowe takie jak komputery czy laptopy są podłączone
        do sieci lokalnych najczęsciej wykorzystujących topologię gwiazdy oraz
        topologię gwiazdy rozszerzonej (topologię hybrydową). Topologie tego
        typu są łatwe w
        instalacji oraz w rozwiązywaniu problemów, przy tym bardzo
        skalowalne. Na początkach instnienia sieci, były jeszcze dwie
        topologie: magistrali oraz pieścienia, ale nie odnalazływ sie one
        we współczesnych warunkach.
      </p>
      <p>
        W sieciach komputerówych komunikacja jednoczesna komunikacja z drugą
        stroną może odbywać się albo na zasadzie <strong>half-duplex</strong>,
        gdzie w jednym czasie może nadawać lub odbierać tylko jeden host. Tego
        typu komunikacja zachodzi np. w sieciach bezprzewodowych, albo 
        na zasadzie <strong>full-duplex</strong>, gdzie hosty mogą nadawać
        i odbierać informacje jednocześnie w tym samym czasie, tego typu
        transmisja zachodzi w sieciach Ethernet opartych na przełączniku.
      </p>
      <p>
        Jeśli działamy w trybie <em>half-duplex</em>-u, to musimy określić
        metodę dostępu do łącza. W technologiach Ethernet istnieją dwa
        algorytmy, które badają dostęp do łącza są nimi
        <strong>CSMA/CD</strong> wykorzystywany w starym Ethernecie opartym
        na topologi magistrali, gdzie komputery łączył jeden wspólny kabel.
        Kolejnym mechanizmem stosowanym w sieciach bezprzewodowych jest
        modyfikacja wyżej wymienionego <strong>CSMA/CA</strong>.
      </p>
      <p>
        Kiedy w starym algorytmie CSMA/CD, wykrywało się kolizje
        (moment, gdy dwie stacje nadają jednocześnie), to w przypadku sieci
        bezprzewodowych wprowadzono ich unikanie. Funkcja unikania kolizji,
        polega na tym, że jeśli stacja nadaje to nadaje jednocześnie informacje
        o tym ile czasu porzebuje na transmisje. Pozostałe hosty dostają te
        informacje i wstrzymują się z nadawaniem do upłynięcia zadeklarowanego
        czasu.
      </p>
      <h2 id="1.6.3.datalinkframe">1.6.3. Ramka łącza danych</h2>
      <p>
        Dane enkapsulowane przez warstwę łącza danych wraz z nagłówkiem oraz
        <em>stopką</em> tworzą <strong>ramkę</strong>. Ramka składa się
        z nagłówka, danych oraz <em>stopki</em>, w zależności od użytego
        protokołu tej warstwy pola nagłówka oraz zawartość <em>stopki</em>
        może się różnić, podobnie może być ilością danych kontrolnych.
        Pola przeciętnej ramki prezentują się następująco:
      </p>
      <ul>
        <li><strong>Początek oraz koniec ramki</strong> - pola kontrolne
          mające za zadanie wskazać początek oraz koniec ramki.</li>
        <li><strong>Adresacja</strong> - pola zawierające adres źródłowy i
          docelowy.</li>
        <li><strong>Typ</strong> - pole zawierające wskazanie protokołu
          warstwy wyższej.</li>
        <li><strong>Kontrola</strong> - pole zawierające informacje, służace
          mechanizmom kontroli przepływu ruchu.</li>
        <li><strong>Dane</strong> - pole zawierające ładunek, najcześciej
          PDU warstwy wyższej.</li>
        <li><strong>Detekcja błędów</strong> - pole wykorzystywane w detekcji
          błędów.</li>
      </ul>
      <p>
        W większość wyżej wymieniony pól znajduje się w nagłówku, ale
        detekcja błędów oraz koniec ramki znajdują się w <em>stopce</em>.
      </p>
      <p>
        Adresy warstwy drugiej, nazwywane również fizycznymi, znajdują się
        wewnątrz nagłówka ramki i są wykorzystywane tylko i wyłącznie do
        dostarczenia jej lokalnie (w obrębie sieci lokalnej). Jeśli wymagane
        jest przezkazanie ramki dalej do inne sieci, to te adresy muszą
        zostać zmienione.
      </p>
      <p>
        Topologie logiczne oraz fizyczne media często mają wpływ na wybór
        określonego protokołu warstwy wyższej. A jest z czego wybierać:
      </p>
      <ul>
        <li>Ethernet</li>
        <li>802.11 WLAN</li>
        <li>Point-to-point (PPP)</li>
        <li>High-Level Data Link Control (HDLC)</li>
        <li>Frame-Relay</li>
      </ul>
      <p>
        Każdy z tych protokołów posiada swoje mechnizmy kontroli dostepu
        do medium, dla określonych topologi logicznych.
      </p>
      <h3 id="ch6summary">Podsumowanie</h3>
      <p>
        W tym rozdziale poznaliśmy podstawowe zagadnienia związane z drugą
        warstwą - warstwą łącza danych. Ten rozdział również rozpoczyna jej
        bardziej szczegółowe omawianie oraz wstęp do technologi Ethernet i
        przełączników.
      </p>
      <h1 id="1.7.ethernetswitching">1.7. Przełączanie Ethernetu</h1>
      <p>
        W tym rozdziale zapoznamy się ze szczegółami technologii Ethernet,
        potrzebnymi do zrozumienia działania takiego urządzenia jak
        przełączniki. Poznamy również meteody przełączania jakie możemy
        spotkać w dostępnych na rynku przełącznikach.
      </p>
      <h2 id="1.7.1.ethernetframe">1.7.1. Ramka Ethernet</h2>
      <p>
        Ethernet operuje w warstwie fizycznej oraz łącza danych, opisują go
        dwa standardy IEEE 802.2 oraz 802.3.
      </p>
      <p>
        Standardy rodziny 802 wykorzystywane w sieciach LAN/MAN w tym i
        Ethernet wykorzystują dwie podwarstwy warstwy łącza danych.
        <strong>LLC</strong>, której zadaniem jest umieszczenie w ramce
        Ethernet informacji o wykorzystywanym protokole warstwy sieciowej dla
        tej ramki. Drugą podwarstwą jest <strong>MAC</strong> odpowiedzialna
        za enkapsulacje danych, kontrolę dostępu do łącza oraz adresacje w
        warstwie łącza danych.
      </p>
      <p>
        Podwarstwa MAC jest odpowiedzialna za enkapsulację danych oraz dostęp
        do łącza danych. Jesli chodzi o samą enkapsulację to podwarstwa MAC
        zajmuje się <strong>ramką Ethernet</strong> - jej wewnętrzną strukturą;
        <strong>adresacją Ethernetu</strong> - ramki muszą zawierać adresy MAC
        źródła oraz hosta docelowego, aby dostarczyć je z jedenj karty
        sieciowej do drugiej; <strong>detekcją błędów Ethernetu</strong>
        ramki zawierają w <em>stopce</em> pole FCS
        <em>Frame Check Sequence</em> wykorzystywane do detekcji błedów.
      </p>
      <p>
        W ramach kontroli dostępu do łącza Ethernet, podwarstwa MAC zawiera
        specyfikację dla różnych standardów komunikacyjnych Ethernetu przez
        różnego rodzaju łącza takie jakie okablowanie miedziane lub 
        światłowody. Stary Ethernet wykorzystywał topologę magistrali lub
        koncentrator, które są współdzielonym medium działającym w trybie
        <em>half-duplex</em>. Ethernet przez tego typu łącza wymagał
        mechanizmów badania dostępności łącza oraz detekcji błędów. Temu
        służył algorytm CSMA/CD (ang. <em>Carrier Sense Multiple
        Access/Colision Detection</em>). Obecnie Ethernet wykorzystuje
        przełączniki przez co komunikacja może odbywać się w trybie
        <em>full-duplex</em> i nie ma potrzebny stosowania mechanizmu CSMA/CD
        ponieważ ta magistrala przy starym Ethernecie jest teraz jednym
        kablem łączącym kartę sieciową z portem przełącznika.
      </p>
      <p>
        Jeśli chodzi o pola ramki Ethernet to najpierw warto sobie powiedzieć,
        że minimalną wielkością ramki mogą być 64B a maksymalną 1518B.
        Preambuła nie jest wliczana do ramki jeśli chodzi o jej wielkość.
        Wszelkie ramki mniejsze niż 64B są uważane za ramki uszkodzone i
        automatycznie odrzucane. Ramki przekraczające górną granice wielkości
        uważane są za ramki typu <em>jumbo</em>. Ramki przekraczające rozmiary
        lub mniejsze niż minimalny rozmiar, są zazwyczaj uznawane za rezulat
        kolizji lub niechciany sygnał. Przez odbiorców mogą być uznane za
        nieprawidłowe. Większe ramki są akceptowane do technologi FastEthernet
        w góre. 
      </p>
      <h3 id="1.7.1.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/7.1.6-lab---use-wireshark-to-examine-ethernet-frames_pl-PL.pdf">Używanie programu Wireshark do badania ramek Ethernet</a>
      </p>
      <h2 id="1.7.2.ethernetmacadress">1.7.2. Adres MAC Ethernetu</h2>
      <p>
        Adres MAC składa się z 48 bitów zapisanych za pomocą 12 cyfr systemu
        heksadecymalnego, 6 par po 2 cyfry. Dwie cyfry heksadecymalne to 1
        bajt. Poprzedzającje zera są również zapisywane, aby każda z grup
        miała te 8 bitów. Cyfry heksadecymalne mogą być czasem zapisywane 
        z przedrostkiem <strong>0x</strong> lub z przyrostkiem
        <strong>H/h</strong>. 
      </p>
      <p>
        Ethernet był projektowany z myślą o tym, że urządzenia sieciowe 
        są podłączone do współdzielonego medium (magistrali) i adresacja MAC
        pozwala na identyfikacje takiego hosta. Ze tego powodu wszyskie
        adresu MAC muszą być unikatowa w obrębie całej sieci. W tym celu
        każdy z dostawców sprzętu działającego w sieci Ethernet muszą
        zarejestować się w IEEE aby uzyskać 6 cyfrowy (heksadecymalnych) kod
        nazwany <strong>unikalnym indentyfikatorem organizacji</strong>
        (<strong>OUI</strong>). Każdy adres MAC składa się z kodu OUI
        przypisanego do producenta sprzętu oraz pozostałych 6 cyfr
        przypisanych przez producenta do konkretnej sztuki produktu.
      </p>
      <p>
        Przetwarzanie ramek ma swój początek już na komputerze źródłowym.
        Każda ramka zawiera adres źródłowy oraz adres docelowy. Kiedy
        karta sieciowa odbierze taką ramkę porówna jej adres docelowy MAC z
        z adresem swojej kartym, jeśli adres jest taki samy oznacza to, że
        ramka jest przeznaczona dla tego hosta. Ramka dekapsulowana i
        przekazana do warstw wyższych. Obecnie większość urządzeń wykorzystuje
        Ethernet, więc tego typu przetwarzanie danych jest podstawą
        wszlakiej komunikacji w sieci. Warto wspomnieć o tym, że karty sieciowe
        akceptują rownież ramki typu broadkast oraz multikast tych grup, do 
        których ten host należy.
      </p>
      <p>
        W Ethernecie różne adresy MAC są wykorzystywane do transmisji unikast,
        broadkast oraz multikast w warstwie drugiej. Adres MAC unikastowy
        jest wykorzystywany do transmisji między pojedynczymi hostami w sieci.
        Adresy MAC są powiązane z adresami warstwy sieciowej, są one uzyskiwane
        za pomocą protokołów ARP (dla IPv4) lub ND (IPv6). Przy tych wszystkich
        rodzajach adresów, a co za tym idzie rodzajach transmisji adresem
        źródłowym zawsze adres unikastowy.
      </p>
      <p>
        Ramkę ethernetową transmisji broadkast odbierze każdy host
        znajdujący się w tej samej sieci Ethernet LAN. Broadkastowy adres MAC
        składa się wyłącznie z samych cyfr <strong>F</strong>. Przez
        przełączniki jest on przekazywany na wszystkie porty poza tym z którego
        ta ramka została przysłana. Oczywiście transmisja broadkast w
        Ethernecie zawiera w sobie pakiet IP z tym samym rodzajem transmisji,
        oznacza to, że dane zawarte w tej transmisji zostaną przetworzone
        przez wszystkie host w tej sieci lokalnej (domenie rozgłoszeniowej),
        które ten pakiet otrzymają.
      </p>
      <p>
        Przypadek transmisji multikast w Ethernet jest trochę bardziej
        skomplikowany. Taką ramkę odbiorą hosty, które należą do tej samej
        grupy. Transmisja multikast w Ethernet jest powiązana z rodzajem tego
        typu transmisji w protokole IP, dla wersji 4 mamy adres (początek):
        <strong>01-00-5E</strong>, a dla wersji 6 <strong>33-33</strong>.
        Innym rodzajem multikastu w Ethernecie jest protokół STP, nie jest
        on protokołem warstwy 3, a drugiej i zawiera swój adres docelowy
        typu multikast. Transmisje multikast opuszczają przełącznik w ten sam
        sposób co transmisja broadkast, chyba że urządzenie skonfigurowano
        inaczej (mechanizm <em>multicast snooping</em>), transmisja ta nie
        jest przekazywana przez router, chyba że został poinstuowany aby
        trasować pakiety multikast. Ze względu na to, że adresy multikast
        reprezentują grupe hostów, mogą zostac użyte tylko i wyłącznie jako
        adres docelowy, adresem źródłowym musi być adres unikast. Tak jak
        w przypadku transmisji unikast oraz broadkast, transmisja multikast
        wymaga odpowiadających adresom Ethernet, adresów IP.
      </p>
      <h3 id="1.7.2.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/7.2.7-lab---view-network-device-mac-addresses_pl-PL.pdf">Odczytywanie adresów MAC urządzeń sieciowych</a>
      </p>
      <h2 id="1.7.3.macaddresstable">1.7.3. Tablica adresów MAC</h2>
      <p>
        Ethernetowy przełącznik warstwy drugiej dokonuje swoich decyzji o
        przełączaniu na podstawie adresu MAC, który jest zapisany w tablicy
        adresów MAC przełącznika, na podstawie informacji tam zapisanych
        przełącznik wie na jaki port należy przesłać dane, adresowane do
        komputera o takim adresie MAC. W momecie włączenia urządzenia jego
        tablica nie zawiera żadnych wpisów i musi się ich nauczyć. Tablica
        MAC często nazwyana jest CAM (ang. <em>content addressable memory
        table</em>).
      </p>
      <p>
        Nauka adresów MAC przez przełącznik, czy też uzupełnienie tablicy
        polega na badaniu każdej przychodzącej do urządzenia, ramki w celu
        uzyskania nowych informacji. Badany jest przede wszystkim adres
        źródłowy oraz port, na którym te dane dotarły do przełącznika, 
        następnie
        te informacje są konfrontowane z tabelą jeśli taki adres MAC pod takim
        portem nie występuje wówczas te dane są dopisywane lub poprawiane w
        zależności od tego czy w przeciągu czasu ważności wpisów w tablicy MAC
        ruch sieciowych przechodził przez ten port. W przeciwnym wypadku
        wpis jest odświerzany co powowduje, że jego czas jego ważności
        został zresetowany. W przypadku większości przełączników czas wazności
        wpisów w tablicy to 5 minut. W przypadku przepięcia hosta do innego
        portu, w tablicy we wpisie z adresem zostanie zamieniony port, pod
        którym ten MAC może występować.
      </p>
      <p>
        W przypadku przekazywania ramek, działa to w sposób analogiczny, tylko
        przełącznik zamiast zapisywać odczytuje informacje z tablicy MAC. Jeśli
        adres docelowy jest unikastowy, to jest on sprawdzany w tablicy, w celu
        ustalenia portu docelowego przełącznika dla docelowego hosta. Jeśli
        wpis zostanie odnaleziony, to ramka zostaje przezkazna na ten port.
        W przeciwnym wypadku zostanie on przekazany na wszystkie porty poza tym
        źródłowym (z którego trafił do przełącznika). Podobnie przełącznik
        zachowuje się w przypadku transmisji broadkast oraz multikast.
      </p>
      <h3 id="1.7.3.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/7.3.7-lab---view-the-switch-mac-address-table_pl-PL.pdf">Przeglądanie tablicy adresów MAC przełącznika</a>
      </p>
      <h2 id="1.7.4.switchspeedsandforwardingmethods">1.7.4. Przepustowość przełącznika oraz metody przekazywania.</h2>
      <p>
        Przełączniki używają jednej z poniższych metod przełączania danych
        danych między portami.
      </p>
      <ul>
        <li><strong>Przełączanie <em>store-and-forward</em></strong> - w tej
          metodzie przełącznik musi otrzymać całą ramkę, następnie oblicza
          jej CRC. Jeśli CRC jest prawidłowe, wówczas dochodzi do przełączania
          znanego z poprzednie podrozdziału.</li>
        <li><strong>Przełączanie <em>cut-through</em></strong> - tutaj
          przełącznik nie czeka całą ramkę, wystarczy mu odczytać adres
          docelowy, aby dokonać przełączenia.</li>
      </ul>
      <p>
        Zaletą metody <em>store-and-forward</em> jest możliwosc wykrycia błędów
        zanim ramką zostanie przekazana dalej. Jeśli błąd zostanie wykryty
        przełącznik odrzuci ramkę. Odrzucanie uszkodzonych ramek pozwala
        zredukować żużycie przepustowści na przesyłanie uszkodzonych ramek.
        Metoda <em>store-and-forward</em> jest również wymaga przez 
        metody priorytetyzacji ruchu takie jak QoS.
      </p>
      <p>
        Metoda przełączania <em>cut-through</em> przełącza dane zanim w całości
        dotrą do przełącznika, jego bufor jest na tyle duży, że może odczytać
        docelowy adres MAC i na podstawie tego dokonuja przełącznia. Ta
        metoda występuje w dwóch wariantach:
      </p> 
      <ul>
        <li><strong>Przełączanie <em>fast-forward</em></strong> - ta metoda
          przełączania oferuje najmniejsze opóźnienia. Jeśli zostaną
          przekazane uszkodzone ramki, to zostaną one odrzucone przez
          docelową kartę. Jest to domyślny wariant dla metody
          <em>cut-through</em>.</li>
        <li><strong>Przełączanie <em>fragment-free</em></strong> - jest
          kompromis między <em>cut-through</em> oraz <em>store-and-forward</em>.
          Przełacznik pobiera i sprawdza pierwsze 64 bajty ramki przed
          przełączeniem. W większości sieci błedy są do wykrycia już tych
          pierwszych 64 bajtach ramki, przez co przełącznik może mieć pewność,
          że te ramki są całe i można je przekazać dalej.</li>
      </ul>
      <p>
        Wspominając o sposobach przełączania, warto również omówić pamięć
        bufora w przełączniku. Bufor jest wykorzystywany gdy port docelowy
        może być zbyt zajęty, żeby przyjmować kolejne ramki, do dyspozycji mamy:
      </p>
      <ul>
        <li><strong>Pamięc portów</strong> - Ramki są przechowywane w kolejkach
          powiązanych z portami wejściowymi oraz wyjściowymi. Ramka jest
          przekazywana na port wyjściowy tylko wtedy gdy ramki przed nią
          zostały poprawnie przesłane. Mozliwe jest opóźnienie transmisji
          wszystkich ramek w pamięci przez pojedyńczą ramkę, ze względu na
          obciążenie portu docelowego. Opóźnienia występują nawet wtedy gdy
          inne ramki mogą zostać przesłane na otwarte porty docelowe.</li>
        <li><strong>Pamięć współdzielona</strong> - przechowuje wszystkie
          ramki we ogólnym buforze pamieci współdzielonym ze wszystkimi portami
          przełącznika, ilość pamięci potrzebna dla konkretnego portu jest
          przydzielana dynamicznie. Ramki w buforze dynamicznie powiązane z 
          portami docelowymi. Pakiet może nadejść z jednego portu i być
          przekazywany do innego to niezostanie on przeniesiony do innej
          kolejki.</li>
      </ul>
      <p>
        Buforowanie w pamięci współdzielonej pozwala na transmisję większych
        ramek z mniejszymi stratami. Jest ważne dla przełączania asymetrycznego,
        które pozwala na różne prędkości danych na różnych portach.
        Dzięki czemu większa przepustowość może zostać przypisana do
        niektórych portów, np. porty serwerów.
      </p>
      <p>
        Dwoma najbardziej podstawowymi ustawieniami przełącznika są
        przepustowość (przełączniki mogą działać w standardach wstecznych
        Eternetu) oraz <em>duplex</em> (możliwość nadawania i odbierania
        danych w tym samym momencie). Do dyspozycji mam
        <strong>full-duplex</strong> - oba urządzenia końcowe mogą nadwać
        i odbierać dane jednocześnie lub <strong>half-duplex</strong> - tylko
        jedna ze stron może nadawać w tym czasie.
      </p>
      <p>
        Prawdopodobnie nie będzie trzeba konfigurować tych ustawień. Tym
        zajmuje się mechnizm autonegocjacji, urządzenia miedzy sobą ustalają
        najlepsze ustawienia dla warunków fizycznych. Gigabitowy Ethernet
        do działania wymaga <em>full-duplex</em>-u.
      </p>
      <p>
        Nie pasujący <em>duplex</em> jest przyczną większości problemów z
        z wydajnościa w sieciach Ethernetowyc 10/100Mbps. Przyczyna tych
        problemów może być ustawienie portu przełącznika w <em>half-duplex</em>
        natomiast druga strona ma ustawiony <em>full-duplex</em>, dzieje się
        tak gdy połączenie między tymi stronami zostanie zresetowane a 
        autonegocjacja nie będzie wstanie ustalić takie samej konfiguracji
        dla obu stron lub gdy zmienimy konfigurację na jednym urządzeniu i
        zapomnimy to zrobić na drugim urządzeniu. Najlepszą praktyką to albo
        włączyć na obu autonegocjację, albo na obu wyłączyć. Można
        również ustawić na portach przełącznika na stałe <em>full-duplex</em>.
      </p>
      <p>
        Połaczenia między urządzeniami mogą wymagać różnego rodzaju połączeń.
        mowa tutaj o kablach prostych oraz o kablach skrosowanych. Zazwyczaj
        połączenia między routerami wymagają kabli skrosowanych jak połączenia
        bezpośrednie między dwiema stacjami. Obecnie mało kto pamiętam o tym
        ponieważ mamy do dyspozycji funkcję <strong>Auto-MDIX</strong>, która
        mimo połączenia urządzeń za pomocą prostych przewodów, dokona
        skrosowania już wewnatrz interfejsu. W sprzętach marki Cisco,
        a szczególnie w przełącznikach ta funkcja jest raczej włączona, ale
        to może być różnie (w zależności jak stare jest to urządzenie). Więc 
        warto
        zawsze używać wymaganych przewodów lub też możemy spróbować włączyć
        tę funkcję za pomocą polecenia: <code class="code-inline">mdix auto</code>
        w trybie konfiguracji interfejsu.
      </p>
      <h2 id="ch7summary">Podsumowanie</h2>
      <p>
        W tym rodziale przybliżliśmy sobie szczegóły technologii Ethernet,
        poznaliśmy adres MAC oraz tablice MAC przełączników. Dowiedzieliśmy
        też jakie są metody przełączania oraz podstawowe ustawienia
        przełącznika.
      </p>
      <h1 id="1.8.networklayer">1.8. Wartstwa sieciowa</h1>
      <p>
        Warstwa sieciowa dostarcza usługi pozwalające na wymianę danych między
        hostami. Podstawowym jej protokołem jest protokół IP zarówno w wersji
        4 jak i 6. Warstwa sieciowa odpowiada adresacje urządzeń końcowych,
        enkapsulację, routing oraz deenkapsulacje.
      </p>
      <h2 id="1.8.1.networklayecharacteristics">1.8.1. Charakterystyki warstwy sieciowej</h2>
      <p>
        Protokół IP enkapsuluje segmenty z wartstwy transportowej, nie ma 
        znaczenia czy użyjemy wersji 4 czy 6 protokołu IP, na ten segment
        nie będzie to miało wpływu. Pakiet IP będzie analizowany przez
        wszystkie urządzenia warstwy 3 (lub mogące w niej działać) na swojej
        drodze do punktu docelowego. Generalnie to adres protokołu IP nie
        powinny się zmienić na drodze między hostem źródłowym a hostem
        docelowym, wyjątkiem od tej reguły jest mechanizm NAT. Protokół IP
        opisywany jest jako bezpołączeniowy, niezależny od medium transmisyjnego
        oraz najlepszej możliwości.
      </p>
      <p>
        Protokół IP jest bezpołączeniowy. IP nie ustanawia żadnego połączenia
        ze stroną docelową przed wysłaniem pakietu, nie potrzeba żadnych
        informacji kontrolnych. Host docelowy otrzyma pakiet kiedy on nadejdzie,
        nie ma żadnych wcześniejsych powiadomień. Jeśli wymagane jest
        połączenie, wówczas jest to powierzane warstwie wyższej, warstwie
        transportowej, a konkretnie protokołowi TCP.
      </p>
      <p>
        Protokół IP jest uznawana za protokół najlepszej możliwości porzez
        zmniejszenie narzutu spowodowanego brakiem mechnizmów retransmisji,
        nie ma potwierdzeń o tym, że pakiet dotarł. IP nawet na nie,
        nie oczekuje. Protokół również nie ma informacji na temat czy
        host w ogóle funkcjonuje i otrzymuje wysłane do niego pakiety.
      </p>
      <p>
        Ze względu na to, że protokół IP jest protokołem najlepszej możliwości
        uznawany jest za nierzetelny. Jednak te funkcje nie sprawdzają się w
        każdym możliwym przypadku, dlatego też brak ich w protokole IP, który
        w obenych czasach musi obsłużyć 99% ruchu w sieci. Protokół IP jest
        protokołem niezależnym od medium transmisjynego oznacza to, że
        może on przesyłać dane przez dowolne połączenie między dwoma hostami.
        Przyczym wprowadza on pojęcie <strong>MTU</strong>
        (<em>Maximum Transmission Unit</em>). Ten protokół utrzymuje
        informacje o tym jakie MTU ma ustawić od warstwy łącza danych. Innym
        mechanizmem protokołu IP jest <strong>fragmentacja</strong>, pozwala
        ona dzielić pakiety na mniejsze części, na przykład gdy nasza 
        technologia WAN ma mniejsze MTU.
      </p>
      <h2 id="1.8.2.ipv4packet">1.8.2. Pakiet IPv4</h2>
      <p>
        Protokół IP wersji 4 jest podstawowym protokołe komunikacyjnym w
        warstwie sieciowej, a sam nagłówek jest dość istotny w całej
        transmisji. Zapewnia, że pakiet zostanie wysłany do właściwego
        odbiorcy, zawiera w swoich polach wiele informacji ważnych dla
        przetwarzania pakietów. Informacje z nagłówka wykorzystują wszystkie
        urządzenia mogące przetwarzać dane z warstwy sieciowej. W nagłówku IP
        mimo wszystko najważniejszą informacją są pola a zawierające adresy,
        dość ciekawy polem tutaj jest pole <em>Protocol</em>, gdyż może mieć
        więcej niż jedną funkcję. Poniżej znajduje się bardziej szczegółowy
        opis poszczególnych pól:
      </p>
      <ul>
        <li><strong>Wersja</strong> - 4-bitowe pole zawierające wersję IP w tym
          przypadku: <em>0100</em> = 4.</li>
        <li><strong>Zróżnicowane usługi</strong> - pole wykorzystywane przez
          QoS, może mieć rózne oznaczenie: DS, DiffServ lub IntServ czy ToS
          <em>Type of Service</em>.</li>
        <li><strong>Suma kontrolna nagłówka</strong> - pole wykorzystywane do
          detekcji uszkodzeń nagłówka.</li>
        <li><strong>Pole TTL</strong> - licznik skoków w warstwie 3. Kiedy
          zostanie wyzerowane router odrzuci pakiet.</li>
        <li><strong>Protokoł</strong> - wskazuje na protokół, którego dane
          są niesione w tym pakiecie, np.: ICMP, TCP czy UDP.</li>
        <li><strong>Adres źródłowy IPv4</strong> - adres IPv4 hosta wysłającego
          pakiet.</li>
        <li><strong>Adres źródłowy IPv6</strong> - adres IPv4 hosta docelowego.</li>
      </ul>
      <h2 id="1.8.3.ipv6packet">1.8.3. Pakiet IPv6</h2>
      <p>
        Protokół IPv4 posiada swoje ograniczenia. Pierwszym z nich jest
        wyczerpanie się adresów IP w swojejwersji, inna przeszkodą może być 
        brak
        bezpośrednich połaczeń, obecnie łączymy się z pośrednictwem adresów
        prywatnych oraz NAT-u, a użycie mechnizmu NAT powoduje potrzebę zmiany
        nagłówków, co może powodować opóźnienia oraz zwiększać złożoność sieci.
      </p>
      <p>
        Remedium na powyższe ograniczenia jest globalne wdrożenie IPv6.
        IPv6 zwiększa długość adresu z 32-bitów do 128 przez co ich ilość
        zwiększa o bardzo duża liczbę (340 x 10^36), gdzie adresów IPv4 mamy
        lekko powyżej 4 miliardy. Zmniejsza się również nagłówek pakietu,
        zostaje pozbawiony kilku pól. Ze względu na ilość operowalnych adresów
        nie ma potrzeby stosowania NAT-u. 
      </p>
      <p>
        Sam nagłówek IPv6 został uproszczony, ale nie zmniejszony. Nagłówek
        IPv6 ma długość 40B, wiele z pól zostało zostało usuniętych aby
        zwiększyć wydajność. Ponizej znajduje się opis poszczególnych pól
        nagłówka IPv6.
      </p>
      <ul>
        <li><strong>Wersja</strong> - wersja protokołu 4 bity dla IPv6 to:
          <em>0110</em>.</li>
        <li><strong>Klasa ruchu</strong> - pole dla QoS.</li>
        <li><strong>Etykieta przepływu</strong> - 20-bitowe pole informujące
          urządzenia, aby przetwarzały pakiety z tą samą wartością tego pola
          w ten sam sposób.</li>
        <li><strong>Długość ładunku</strong> - 16-bitowe pole określa długość
          danych niesionych przez ten pakiet.</li>
        <li><strong>Następny nagłówek</strong> - wskazuje na protokół
          warsty wyższej, której dane niesie.</li>
        <li><strong>Limit skoków</strong> - licznik skoków w warstwie sieciowej</li>
        <li><strong>Adres źródłowy IPv6</strong> - 128-bitowy adres źródłowy.</li>
        <li><strong>Adres docelowy IPv6</strong> - 128-bitowy adres docelowy.</li>
      </ul>
      <p>
        Dodatkowo pakiety IPv6 mogą zawierać rozszerzenie nagłówka, które może
        zawierać dodatkowe informacji warstwy sieciowej takie jak fragmentacja,
        informacje odnośnie bezpieczeństwa czy wsparcie dla mobilności. To
        rozszerzenie jest opcjonalne i umiesczone jest między danymi a
        nagłówkiem. W przeciwieństwie do IPv4 routery IPv6 nie fragmentują
        pakietów.
      </p>
      <h2 id="1.8.4.howhostsroutes">1.8.4. W jaki sposób host przesyła pakiety</h2>
      <p>
        Każdy host posiada w swojej konfiguracji TCP/IP tablicę routingu.
        Pakiety przez niego wygenerowane mogą być wysłane do siebie po przez
        adres pętli zwrotnej: <em>127.0.0.1</em> (IPv4), <em>::1</em> (IPv6);
        do hostów lokalnych znajdujących się w tej samej sieci czy też do
        hostów zdalnych znajdujących się poza naszą siecią lokalną.
      </p>
      <p>
        To host źródłowy decyduje o tym czy adres docelowy jest adresem
        lokalnym czy też pochodzącym z poza sieci. W zależności od wersji
        protokołu są dwie metody. Host konfrontuje swój adres oraz maskę
        obliczając adresy sieciowe (adres sieci i broadcast) z adresem
        docelowym w przypadku IP w wersji 4. W przypadku IP w wersji 6, host
        wykorzystuje adres sieci oraz prefix przedstawiony mu przez najbliższy
        router. Ruch lokalny opuszcza kartę sieciową hosta i jest przetwarzany
        przez urządzenia pośredenie, takie jak przełączniki. Jeśli ruch jest
        ewidentnie adresowany na zewnątrz, jest on kierowany do prosto do bramy
        oczywiści z pośrednictwem urządzeń po drodze do routera.
      </p>
      <p>
        Urządzenia warstwy 3, takie jak routery lub przełączniki L3 mogą być
        domyślną bramą dla hostów w sieci lokalnej. Cechami domyślnej bramy
        są na pewno: adres IP urządzenia/interfejsu musi znajdować się w tej
        samej sieci lokalnej, urządzenia tego typu przyjmują ruch z sieci
        lokalnej i kierują ją po za nią, mogą trasować ruch do innych sieci.
        Jeśli hosty w sieci nie posiadają skonfigurowanej bramy lub jej adres
        adres jest niepoprawny nie będą wstanie przesyłać danych poza sieć.
      </p>
      <p>
        Host adres bramy może mieć zapisany w swojej konfiguracji statycznie
        lub otrzymać go wraz z dzierżawą adres IP z serwera DHCP, w przypadku
        protokołu IPv6 adres bramy może zostać otrzymany z komunikatów
        <em>router advertisement</em> (RA) lub skonfigurowany ręcznie.
      </p>
      <p>
        Za pomocą poleceń <code class="code-inline">netstat -r</code> dla
        (systemy MS Windows) czy <code class="code-inline">ip route</code>
        (dystrybucje Linuksa). Możemy wyświetlić tablicę routingu zapisaną
        na systemie hosta.
      </p>
<pre class="code-inline">
󱩊 xf0r3m@laptop-026253a/ ~/󰯆 ip route
default via 192.168.8.1 dev enp0s31f6 proto dhcp src 192.168.8.133 metric 100 
192.168.8.0/24 dev enp0s31f6 proto kernel scope link src 192.168.8.133 metric 100 
</pre>
      <h2 id="1.8.5.introductiontorouting">1.8.5. Wprowadzenie do routingu</h2>
      <p>
        Załóż czysto hipotetycznie, że chcemy przesłać pakiet do sieci obok,
        co sie stanie? Taki pakiet jeśli osiągnie router, ponieważ nasz host
        wysłał tę ramkę do bramy domyślnej, to router sprawdzi adres docelowy
        i wzależności czy posiada trasę do tego hosta, to wyśle go na pierwszy
        router w tej trasie, lub jeśli sieć docelowa jest wpięta do tego samego
        routera zostanie przekazana na interfejs obsługjący tę sieć. Router
        dokonuje tych decyzji opierając się o zapisaną w swojej pamięci tablicę
        routingu.
      </p>
      <p>
        W routerach możemy spotkać trzy rodzaje tras w ich tablicach.
      </p>
      <ul>
        <li><strong>Podłączone bezpośrednio</strong>
          (ang. <em>Directly Connected</em>) - te trasy są dodwane domyślnie
          bazując na aktywnych interfejsach i powiązanych z nimi adresach.</li>
        <li><strong>Zdalne</strong> (ang. <em>Remote</em>) - trasy
          bez połączenia bezpośrednie (niepodłączone lokalnie), router nauczył
          się ich albo przy użyciu dynamicznych protokółów routingu lub
          zostały mu one zapisane ręcznie przez administratora
          (trasy statyczne)</li>
        <li><strong>Trasa domyślna</strong> - trasa wykorzystywana w momencie,
          gdy nie ma innej pasującej do adresu docelowego.</li>
      </ul>
      <p>
        Cechami tras statycznych są: potrzeba ręcznej konfiguracji, potrzeba
        ręcznego dostosowania do zmienającej się topologii sieci. Trasy
        statyczne mogą być dobrym wyborem dla małych sieci. Za pomocą tras
        statycznych mimo wykorzystywania protokołów dynamicznych ustala się
        bramy domyślne dla routerów.
      </p>
      <p>
        W przypadku routingu dynamicznego, routery same odnajdują sieci,
        aktualizują informacje, wybierają najlepsze ścieżki czy dostosowują się
        do topologii. Dynamiczny routing może być wykorzystywany do
        współdzielnia statycznej trasy bramy domyślnej.
      </p>
      <p>
        W systemach Cisco IOS, szczególnie na routerach możemy zobaczyć dość
        obszerną informacje podobną do tej przedstawionej na poniższym
        przykładzie. Nie będzie ona tak obszerna jak w tym przypadku. Nie
        mniej warto się jednak zapoznać z oznaczeniami poszczególnych tras.
      </p>
<pre class="code-block">
route-views&gt;show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area 
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2
       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2
       ia - IS-IS inter area, * - candidate default, U - per-user static route
       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP
       a - application route
       + - replicated route, % - next hop override, p - overrides from PfR

Gateway of last resort is 128.223.51.1 to network 0.0.0.0

S*    0.0.0.0/0 [1/0] via 128.223.51.1
      1.0.0.0/8 is variably subnetted, 3781 subnets, 17 masks
B        1.0.0.0/24 [20/0] via 12.0.1.63, 12:59:24
B        1.0.4.0/22 [20/0] via 114.31.199.16, 12:59:24
B        1.0.5.0/24 [20/0] via 114.31.199.16, 12:59:24
...
</pre>
      <p>
        Zatem:
      </p>
      <ul>
        <li><strong>L</strong> - podłączony bezpośrednio adres IP interfejsu.</li>
        <li><strong>C</strong> - sieć podłączona bezpośrednio.</li>
        <li><strong>S</strong> - trasa statyczna.</li>
        <li><strong>O</strong> - protokół OSFP.</li>
        <li><strong>D</strong> - protokół EIGRP.</li>
        <li><strong>R</strong> - protokół RIP.</li>
        <li><strong>B</strong> - protokół BGP.</li>
      </ul>
      <p>
        Chcąc przypasować te oznaczenia do wspomniany wcześniej rodzajów wpisów
        w tablicy routingu routera to:
      </p>
      <ul>
        <li>Podłączone bezpośrednio (ang. <em>Directly Connected</em>) -
          <strong>C</strong> i <strong>L</strong>.</li>
        <li>Trasy zdalne (ang. <em>Remote Routes</em>) - 
          <strong>O</strong>, <strong>D</strong>, <strong>R</strong>
          <strong>B</strong>.</li>
        <li>Trasy domyślne (ang. <em>Default routes</em>) - 
          <strong>S*</strong>.</li>
      </ul>
      <h2 id="ch8summary">Podsumowanie</h2>
      <p>
        Tym rozdziałem rozpoczeliśmy omawianie warstwy sieciowej.
        Poznaliśmy jej główny protokół jakim jest protokół IP oraz nagłówki
        pakietów zarówno dla wersji 4 jak i 6. Dowiedzieliśmy się jak
        działa trasowanie oraz jakie są jego rodzaje oraz charakterystyki
        metody statycznej oraz dynamicznej. 
      </p>
      <h1 id="1.9.adresresolution">1.9. Rozwiązywanie adresów</h1>
      <p>
        Chcąc wysłać jakieś informacje przez sieć, nasz komputer musi w jakiś
        sposób zaadresować jakoś te pakiety z danymi. Pierwszą warstwą jaka
        będzie wymgać adresu jest warstwa sieciowa, tam potrzeba adresu IP,
        który może zostać uzyskany za pomocą system DNS. Następna warstwą jak
        wymaga adresu jest wartstwa fizyczna/łącza danych oraz
        rozpowszechniony na większość sieci protokół Ethernet, który wymaga
        adresów MAC (adresów fizycznych), kiedy pakiet IP jest enkapsulowany
        w ramkę Ethernet  wymagana
        jest zamiana adresów IP na adresy MAC i temu służą dwa tematy tego
        rozdziału: <strong>ARP</strong> oraz
        <strong>IPv6 Neighbor Discovery</strong>.
      </p>
      <h3 id="1.9.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.1.3-packet-tracer---identify-mac-and-ip-addresses_pl-PL.pdf">Identyfikacja adresów MAC i IP - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.1.3-packet-tracer---identify-mac-and-ip-addresses_pl-PL.pka">Identyfikacja adresów MAC i IP - zadanie</a>
      </p>
      <h2 id="1.9.1.arp">1.9.1. Protokół ARP</h2>
      <p>
        Protokół ARP jest wykorzystywany do określenia adresu MAC dla adresów
        IP lokalnych urządzeń w sieci. Protokół ten ma dwie zasadnicze
        funkcje zmianę adresów IPv4 na adresy MAC oraz utrzymania mapowań
        adresów w tabeli.
      </p>
      <p>
        Kiedy host musi wysłać ramkę przeszukuje swoją tablicę ARP w
        poszukiwaniu pasującego adres MAC do docelowego adresu IPv4, jeśli
        host docelowy znajduej się w tej samej sieci. Jeśli znajduje się w
        innej wówczas host będzie szukać w tablicy ARP adresu bramy.
        Pasujący adres zostanie użyty jako adres docelowy w ramce Ethernet.
        Jeśli nie uda się odnaleźć adresu MAC, to wówczas host wyśle zapytanie
        ARP.
      </p>
      <p>
        Wpisy w tabeli ARP znajdują się tam tylko przez określony czas, po jego
        upłynięciu wpis zostaje wymazany. Ilość tego czasu zależy od systemu
        operacyjnego, mimo to administrator ma możliwość ręcznego usunięcia
        wpisu z tablicy ARP.
      </p>
      <p>
        Na urządzeniach z systemami IOS tablice ARP możemy sprawdzić za pomocą
        polecenia: <code class="code-inline">show ip arp</code>. Na natomiast
        w urządzeniach z system MS Windows tablice ARP możemy wyświetlić
        za pomocą polecenia <code class="code-inline">arp -a</code>.
      </p>
      <p>
        Pakiety ARP są przesyłane przez hosty nie mal przez wszystkie hosty w
        sieci, a wiele transmisji ARP na raz może powodować spadki wydajności
        całej sieci. Warto też wspomnieć, że odpowiedzi ARP mogą być fałszowane
        przez atakującego przeprowadzającego atak zatruwanie tablicy ARP,
        jednak przełączniki klasy Enterprise zawierają funkcję ochronne przed
        tego typu atakami.
      </p>
      <h3 id="1.9.1.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.2.9-packet-tracer---examine-the-arp-table_pl-PL.pdf">Badanie tablicy ARP - scenaiusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.2.9-packet-tracer---examine-the-arp-table_pl-PL.pka">Badanie tablicy ARP - zadanie</a>
      </p>
      <h2 id="1.9.2.ipv6neighbordiscovery">1.9.2. Protokół IPv6 Neighbor Discovery</h2>
      <p>
        Protokół IPv6 <em>Neighbor Discovery</em> dostarcza nam takich funkcji
        jak rozwiązywanie adresów, znajdowanie routerów oraz
        usługi przekierowań. Cały ten protokół jest częścią protokołu ICMPv6
        i wykorzystuje jego konkretne rodzaje komunikatów takie jak
        <em>Neighbor Solicitation</em> (NS) i <em>Neigbor Advertisement</em>
        (NA) wykorzystywane do wymiany informacji między urządzeniami, np.
        takich jak rozwiązywanie adresów. Innymi komunikatmi są
        <em>Router Solicitation</em> (RS) oraz <em>Router Advertisement</em>
        (RA) służące do wymiany informacji pomiędzy hosta a routerami te
        komunikaty biorą udział w zapytaniach o adres routera oraz o
        rozgłoszeniu informacji o istniejącym w sieci routerze. Pozostałymi
        komunikatami są informacje o przekierowaniach, są one używane przez
        routery do wyboru lepszego następnęgo skoku.
      </p>
      <p>
        Wykorzystujące IPv6 urządzenia wykorzystują komunikaty ND w celu
        uzyskania adresów MAC dla znanych adresów IPv6. W odpowiedzi uzyskują
        adres MAC żądanego urządzenia, przyczym odpowiedzi wysyłane są
        na specjalny adres Ethernetowy oraz adres multikastowy IPv6.
      </p>
      <h3 id="1.9.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.3.4-packet-tracer---ipv6-neighbor-discovery_pl-PL.pdf">Wykrywanie sąsiadów IPv6 - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.3.4-packet-tracer---ipv6-neighbor-discovery_pl-PL.pka">Wykrywanie sąsiadów IPv6 - zadanie</a>
      </p>
      <h2 id="ch9summary">Podsumowanie</h2>
      <p>
        W tym jakże krótkim rodziale poznaliśmy w jaki sposób rozwiązywane są
        adresy IPv4 jak i IPv6 na adresy warstwy niższej - adresy MAC.
      </p>
      <h1 id="1.10.basicrouterconfig">1.10. Podstawowa konfiguracja routera</h1>
      <p>
        Kontynuując poznawanie warstwy sieciowej pora poznać kilka poleceń, a
        ze względu, że to warstwa 3 czy to modelu OSI czy TCP/IP, to będzie to
        router - urządzenie, które w tej warswie poniękąd rezyduje.  
      </p>
      <h2 id="1.10.1.configinitroutersettings">1.10.1. Konfiguracja podstawowych ustawień routera</h2>
      <p>
        Prze rozpoczęciem właściwej konfiguracji interfejsów sieciowych czy
        routing warto pochylić się na takimi rzeczami jak określenie jego
        nazwy, wybór ewentualnej metody dostępu zdalnego do jego konsoli oraz
        zabepieczenie dostępu do niego hasłem. Zaczniemy od czynności, którą
        wykonuje się bardzo łatwo a może mieć dość duże znaczenie. Mianowicie 
        od konfiguracji, nazwy urządzenia.
      </p>
      <p>
        Do zmiany urządzenia służy polecenie <strong>hostname</strong>,
        polecenie to wydajemy w trybie globalnej konfiguracji:
      </p>
<pre class="code-block">
Router(config)#hostname R1
R1(config)#
</pre>
      <p>
        Następnym ważnym elementem jest zablokowanie możliwości przejścia w
        tryb uprzywilejowany przez osoby do tego nieupoważnione, dokonujemy
        tego za pomocą polecenia
        <code class="code-inline">enable secret <em>hasło</em></code>
        w trybie konfiguracji globalnej:
      </p>
<pre class="code-block">
R1(config)#enable secret 2up3r74jn3Has!0
R1(config)#
</pre>
      <p>
        Teraz zabezpieczymy dostęp do trybu EXEC użytkownika, dokonamy tego
        za pomocą kilku poleceń, na początku musimy przejść do konfiguracji
        połączenia konsolowego, dokonujemy tego w trybie konfigracji globalnej
        za pomocą poniższego polecenia:
        <code class="code-inline">line console 0</code>, następnie ustawiamy
        hasło dostępu za pomocą polecenia
        <code class="code-inline">password <em>hasło</em></code> oraz wymuszamy
        logowanie za pomocą polecenia
        <code class="code-inline">login</code>
      </p>
<pre class="code-block">
R1(config)#line console 0
R1(config-line)#password 1234User!
R1(config-line)#login
R1(config-line)#end
</pre>
      <p>
        Jeśli zabezpieczyliśmy konsole to warto zabezpieczyć, również dostęp
        zdalny (na tym etapie, zrobimy to w podstawowym stopniu, w rozdziale
        poświęconym bezpieczeństwu, zrobimy to tak jak należy). Konfigurację
        rozpoczynamy od przejścia w trybie konfiguracji globalnej do trybu
        konfiguracji konsoli wirtualnych, w tym poleceniu należy wskazać
        również ile jest możliwych jednoczesnych połączeń, do konfiguracji
        konsoli wirtualnych, przechodzimy za pomocą poniższego polecenia:
        <code class="code-inline">line vty 0 4</code>, następnie identycznie
        jak w przypadku połączenia konsolowego ustawiamy hasło:
        <code class="code-inline">password <em>hasło</em></code> oraz
        wymuszamy logowanie: <code class="code-inline">login</code>
        Dodatkowym polecenie jakie należy wydać jest wybranie protokołu
        zdalnego dostępu, do dyspozycji mamy <em>Telnet</em> oraz SSH. Wybór
        raczej jest prosty, a dokonujemy go za pomocą poniższego:
        <code class="code-inline">transport input ssh</code> 
      </p>
<pre class="code-block">
R1(config)#line vty 0 4
R1(config-line)#password 1234User!
R1(config-line)#login
R1(config-line)#transport input ssh
R1(config-line)#end
</pre>
      <p>
        Odnośnie tej ilość jednoczesnych połączeń to odpowiadają za to te
        cyfry w pierwszym wierszu przykładu, w tym przypadku pozwoliśmy na
        5 jednoczesnych połączeń.
      </p>
      <p>
        Wpisane przez nas hasła za pomocą polecenia
        <code class="code-inline">password</code>, są niestety przechowyane
        czystym tekstem, jeśli wyświetlimy sobie obecną konfigurację. Jednak
        za pomocą polecenia:
        <code class="code-inline">service password-encryption</code> wydanego
        w trybie konfiguracji globalnej możemy włączyć szyfrowanie haseł.
      </p>
<pre class="code-block">
R1(config)#service password-encryption 
R1(config)#
</pre>
      <p>
        Ostatnią czynnością, jaką należy wykonać na tym etapie jest
        ustawienie informacji, tzw. baneru informującego o głównie o tym
        nieautoryzowany dostęp jest zabroniony. Dokonać tego możemy za pomocą
        polecenia: <code class=="code-inline">banner motd</code> następnie
        umieszczając między krzyżykami (<strong>#</strong>) rzeczoną
        informacje. Polecenie to wydajemy w trybie konfiguracji globalnej.
      </p>
<pre class="code-block">
R1(config)#banner motd # Nieautoryzowany dostep jest zabroniony! #
R1(config)#
</pre>
      <p>
        Teraz przed logowaniem każdy zobaczy taki napis i to nieważne czy
        przez konsole czy SSH. Na chwile obecną konfiguracja naszego urządzenia
        znajduje się w pamięci RAM. A wiemy jako to jest z pamięcią RAM, tak
        więc aby zapisać nasza konfigurację do NVRAM-u. Musimy wydać poniższe
        polecenie:
        <code class="code-inline">copy running-config startup-config</code>
        w trybie uprzywilejowanym EXEC.
      </p>
<pre class="code-block">
R1(config)#end
R1#copy running-config startup-config 
Destination filename [startup-config]? 
Building configuration...
[OK]
R1#
</pre>
      <h3 id="1.10.1.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.1.4-packet-tracer---configure-initial-router-settings_pl-PL.pdf">Konfiguracja ustawień początkowych routera - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.1.4-packet-tracer---configure-initial-router-settings_pl-PL.pka">Konfiguracja ustawień początkowych routera - zadanie</a>
      </p>
      <h2 id="1.10.2.configif">1.10.2. Konfiguracja interfejsów i polecenia podgladu</h2> 
      <p>
        Mając zapisaną początkową konfigurację routera w pamięci NVRAM możemy
        przejść do konfiguracji interfejsów routera, na początku zanim jednak
        skonfigurujemy jakiś interfejs musimy dowiedzieć się jakie są dostępne
        na urządzeniu. Do tego może nam posłużyć polecenie:
        <code class="code-inline">show ip interface brief</code> w trybie
        uprzywilejowanym EXEC.
      </p>
<pre class="code-block">
R1#show ip interface brief
Interface              IP-Address      OK? Method Status                Protocol 
FastEthernet0/0        unassigned      YES unset  administratively down down 
FastEthernet0/1        unassigned      YES unset  administratively down down 
Vlan1                  unassigned      YES unset  administratively down down
R1#
</pre>
      <p>
        Przy okazji tego narzędzia warto wspomnieć dlaczego są dwie kolumny z
        napisem <code class="code-inline">administratively down</code> oraz
        <code class="code-inline">down</code>. Pierwsza kolumna
        <code class="code-inline">Status</code> mówi nam jaki jest status
        faktyczny interfejsu, jeśli wartość tego pola jest jak na przykładzie
        oznacza to interfejs jest wyłączony przez administatora. W przypadku
        kolumny <code class="code-inline">Protocol</code> oznacza, że protokół
        warstwy niższej nie odpowiada - po drugiej stronie nic nie ma.
      </p>
      <p>
        Więcej szczegółów na temat interfejsów możemy uzyskać za pomocą
        polecenia: 
        <code class="code-inline">show interfaces <em>interfejs</em></code>
      </p>
<pre class="code-block">
R1#show interfaces FastEthernet0/0
FastEthernet0/0 is administratively down, line protocol is down (disabled)
  Hardware is Lance, address is 0060.472c.e901 (bia 0060.472c.e901)
  MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Full-duplex, 100Mb/s, media type is RJ45
  ARP type: ARPA, ARP Timeout 04:00:00, 
  Last input 00:00:08, output 00:00:05, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/75/0 (size/max/drops); Total output drops: 0
  Queueing strategy: fifo
  Output queue :0/40 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     0 packets input, 0 bytes, 0 no buffer
     Received 0 broadcasts, 0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort
     0 input packets with dribble condition detected
     0 packets output, 0 bytes, 0 underruns
     0 output errors, 0 collisions, 1 interface resets
     0 babbles, 0 late collision, 0 deferred
     0 lost carrier, 0 no carrier
 --More-- 
</pre>
      <p>
        Warto pamiętać o tym poleceniu, powieważ zwraca kilka przydatnych
        statystyk. Po odświerzeniu informacji, jak wyświetlać informacje o
        interfejsach, możemy przejść do ich konfiguracji. Konfiguracja
        nie będzie szczególnie różnić się od konfiguracja wirtualnego
        interfejsu <em>Vlan1</em> znanego z konfiguracji przełącznika. Dodamy
        jedynie polecenie konfigurjące adres IPv6.
      </p>
      <p>
        A więc jeśli chcemy skonfigurować dajmy na to interfejs 
        <em>FastEthernet0/0</em>
        to w trybie konfiguracji globalnej wydajemy polecenie:
        <code class="code-inline">interface FastEthernet0/0</code>, wówczas
        nasz znak zachęty powinien pokazać nam, że zmieniliśmy tryb. Następnie
        należy dodać opis dlatego interfejsu, za pomocą polecenia:
        <code class="code-inline">desc</code>. Teraz możemy dodawać nasze
        adresy IP, kolejno dla IPv4 poleceniem:
        <code class="code-inline">ip addr <em>adres</em> <em>maska-dziesietnie</em></code>
        oraz dla IPv6 poleceniem:
        <code class="code-inline">ipv6 addr <em>adres</em>/<em>prefix</em></code>
        na koniec podnosimy (uruchamiamy) ten interfejs poleceniem:
        <code class="code-inline">no shutdown</code>.
      </p>
<pre class="code-block">
R1(config)#interface FastEthernet0/0
R1(config-if)#desc WAN
R1(config-if)#ip addr 209.165.200.225 255.255.255.252
R1(config-if)#ipv6 addr 2001:db8:acad:10::1/128
R1(config-if)#no shutdown

R1(config-if)#
%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up
</pre>
      <p>
        Po wydaniu polecenia <code class="code-inline">no shutdown</code>,
        otrzymaliśmy na konsoli informacje o tym, że interfejs się 
        uruchomił. Aby sprawdzić nasze ustawienia możemy wydać ponownie
        polecenia <code class="code-inline">show ip interface brief</code>,
        <code class="code-inline">show ip interface FastEthernet0/0</code> oraz
        dla IPv6
        <code class="code-inline">show ipv6 interface FastEthernet0/0</code>.
      </p>
<pre class="code-block">
R1(config-if)#end
R1#
R1#show ip interface brief
Interface              IP-Address      OK? Method Status                Protocol 
FastEthernet0/0        209.165.200.225 YES manual up                    down 
FastEthernet0/1        unassigned      YES unset  administratively down down 
Vlan1                  unassigned      YES unset  administratively down down
R1#
R1#show interfaces FastEthernet0/0
FastEthernet0/0 is up, line protocol is down (disabled)
  Hardware is Lance, address is 0060.472c.e901 (bia 0060.472c.e901)
  Description: WAN
  Internet address is 209.165.200.225/30
  MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Full-duplex, 100Mb/s, media type is RJ45
  ARP type: ARPA, ARP Timeout 04:00:00, 
  Last input 00:00:08, output 00:00:05, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/75/0 (size/max/drops); Total output drops: 0
  Queueing strategy: fifo
  Output queue :0/40 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     0 packets input, 0 bytes, 0 no buffer
     Received 0 broadcasts, 0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort
     0 input packets with dribble condition detected
     0 packets output, 0 bytes, 0 underruns
     0 output errors, 0 collisions, 1 interface resets
 --More--
R1#
R1#show ipv6 interface FastEthernet0/0
FastEthernet0/0 is up, line protocol is down
  IPv6 is tentative, link-local address is FE80::260:47FF:FE2C:E901 [TEN]
  No Virtual link-local address(es):
  Global unicast address(es):
    2001:DB8:ACAD:10::1, subnet is 2001:DB8:ACAD:10::1/128 [TEN]
  Joined group address(es):
    FF02::1
  MTU is 1500 bytes
  ICMP error messages limited to one every 100 milliseconds
  ICMP redirects are enabled
  ICMP unreachables are sent
  ND DAD is enabled, number of DAD attempts: 1
  ND reachable time is 30000 milliseconds
</pre>
      <p>
        Zanim przejdziemy dalej, warto omówić sobie oznaczenia interfejsów
        w nomenklaturze Cisco, oprócz natywnego protokołu używanego przez ten
        interfejs typu FastEthernet itd. mamy takie cyferki odzielone
        ukośnikami <code class="code-inline">FastEthernet0/0</code>. W
        urządzeniach Cisco można dodawać interfejsy na specjalnych kartach, te
        karty umieszcza się w <em>slotach</em> urządzenia i ten <em>slot</em>
        to może być jedna z cyfr. Następną cyfrą może być moduł, póki co do
        głowy przychodzą mi tylko wkładki SFP, gdzie może być więcej modułów
        w slocie, lub też moduł przełącznika może być podzielon na dwa
        podmoduły - kiedy druga wartość może by inna niż 0. Ostatnią cyfrą
        jest numer portu. Tak więc maksymalnie mogą być trzy cyfry w oznaczeniu
        interfejsu np. <em>GigabitEthernet0/1/0</em>.
      </p>
      <p>
        Innym przydatnym przydatnym poleceniem przy konfiguracji router może
        być wyświetlenie tablicy routingu za równo dla IPv4 jak IPv6.
      </p>
<pre class="code-block">
R1#show ip route
Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

     209.165.200.0/30 is subnetted, 1 subnets
C       209.165.200.224 is directly connected, FastEthernet0/0

R1#
R1#show ipv6 route
IPv6 Routing Table - 2 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
C   2001:DB8:ACAD:10::1/128 [0/0]
     via ::, FastEthernet0/0
L   FF00::/8 [0/0]
     via ::, Null0
R1#
</pre>
      <h2 id="1.10.3.routerdefaultgatewayconfig">1.10.3. Konfiguracja bramy domyślnej na routerze</h2>
      <p>
        Kiedy wysyłamy pakiet do sieci, której nasz router nie obsługuje
        wysyła on ten pakiet dalej do swojej bramy domyślnej. Identycznie
        robią nasze domowe routery. Bez adresu bramy domyślnej dostęp do
        Internetu byłby niemożliwy. Aby skonfigurować bramę na routerze Cisco
        w trybie konfiguracji globalnej wydajemy polecenie:
        <code class="code-inline">ip default-gateway <em>adres bramy</em></code> 
      </p>
<pre class="code-block">
R1(config)#ip default-gateway 209.165.200.254
R1(config)#
</pre>
      <h3 id="1.10.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/build-a-switch-and-router-network.pksz">Podłączanie routera do sieci LAN</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.3.5-packet-tracer---troubleshoot-default-gateway-issues_pl-PL.pdf">Rozwiązywanie problemów z bramą domyślną - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.3.5-packet-tracer---troubleshoot-default-gateway-issues_pl-PL.pka">Rozwiązywanie problemów z bramą domyślną - zadanie</a>
      </p>
      <h2 id="ch10summary">Podsumowanie</h2>
      <p>
        W tym rozdziale poznalismy podstawową konfigurację routera Cisco w tym:
        początkowe ustawienia, konfigurację interfejsów oraz wyświetlenie ich
        stanu ze szczegółami i konfigurację domyślnej bramy.
      </p>
      <h3 id="1.10.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.4.3-packet-tracer---basic-device-configuration_pl-PL.pdf">Podstawowa konfiguracja urządzenia - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.4.3-packet-tracer---basic-device-configuration_pl-PL.pka">Podstawowa konfiguracja urządzenia - zadanie</a>
      </p>
      <h3 id="1.10.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/10.4.4-lab---build-a-switch-and-router-network_pl-PL.pdf">Budowanie sieci w oparciu o przełącznik i router</a>
      </p>
      <h1 id="1.11.ipv4adressing">1.11. Adresacja IPv4</h1>
      <p>
        Protokół IPv4
        ten ma tyle lat, że chyba każdy powinien znać podstawy jego działania.
        Dla nas w tej wartstwie może i najważniejszą rzeczą jest adres IPv4
        potocznie nazywany poprostu adresem IP. Adres ten jest unikalny i
        jednoznacznie wskazuje na hosta w sieci. W tym rozdziale zapoznamy się
        tym adresem i dowiemy się jak liczy się takie adresy oraz dzieli ich
        pulę na podsieci.
      </p>
      <h2 id="1.11.1.ipv4structure">1.11.1. Struktura adresów IPv4</h2>
      <p>
        Adres IPv4 jest długości 32-bitów oraz ma hierarchiczną budowę, na
        którą składa się część sieciowa oraz część hostów. Przy określaniu
        tych części warto przyjrzeć się temu adresowi w postaci binarnej.
        Ważna również jest w tym przypadku <strong>maska podsieci</strong>.
      </p>
      <p>
        Chcąc poznać poszczególne części adresu IP należy skonfrontować jego
        zapis binarny z maską, wówczas występujące na masce 1, oznaczają
        część sieciową, a 0 oznaczają część hosta. Taki proces nazywa się
        <em>ANDing</em>-iem.
      </p>
      <p>
        Prefiksem możemy nazwać maskę zapisaną za pomoca liczby występującej
        na niej bitów o wartości 1. Taki prefiks zapisujemy za przy użyciu
        ukośnika (<strong>/</strong>, notacji ukośnika). 
      </p>
      <p>
        Adres sieci, czyli adres wskazujący na początek zakresu naszego
        adresów możemy uzyskać za pomocą przeprowadzenia logicznej operacji
        <strong>AND</strong> (mnożenia, mnożymy bity adresu IP hosta, przez
        bity maski.
      </p>
<pre class="code-block">
   192    .    168    .     10    .     10
1100 0000 | 1010 1000 | 0000 1010 | 0000 1010
   255    .    255    .    255    .     0
1111 1111 | 1111 1111 | 1111 1111 | 0000 0000
---------------------------------------------- AND
1100 0000 | 1010 1000 | 0000 1010 | 0000 0000
   192    .    168    .     10    .     0
</pre>
      <p>
        Na każdą sieci przypada przypadają adresy dwa adresy, których nie
        można użyć do adresowania hostów. Jeden z nich adres sieci poznalismy
        przed chwilą. Drugim jest adres <em>broadcast</em>, adres ten 
        reprezentuje wszystkie hosty w danej podsieci, wskazuje on także koniec
        puli adresowej. W zapisie binarnym wyróznia się on tym, że w części
        hostowej ma on same jedynki.
      </p>
      <h2 id="1.11.2.ipv4castsadresses">1.11.2. Adresy IPv4 Unicast, Broadcast oraz Multicast</h2>
      <p>
        Adresem unikastowym IPv4 możemy nazwać dowolny adres hosta w sieci IP,
        w przypadku adresów unikastowych transmisja odbywa się od jednego
        nadawcy do jednego odbiorcy. Przy czym transmisja Broadcast polega
        na przesłaniu wiadomości z jednego źródła do wszystkich hostów w sieci
        Adres broadcast dla IPv4 jest <em>255.255.255.255</em>. Transmisja
        może odbyć do wybranej grupy hostów, do tego służą adresy multikast,
        adresem, zarezerwowany do tworzenia grup multikastowych, jest zakres
        adresów od 224.0.0.0 do 239.255.255.255. Adresy te służą tylko temu
        celowi i nie powinny być wykorzystywane w innych celach.
      </p>
      <h2 id="1.11.3.typesofipv4addresses">1.11.3. Rodzaje adresów IPv4</h2>
      <p>
        Adresy IP można podzielić na publiczne, które mogą być trasowane
        pomiędzy różnymi sieciami łącząc je ze sobą. Są również adresy
        prywatne, które są wyłącznie do użytku wewnątrz sieci i nie są one
        routowalne. To za pomocą adresów prywatnych, adresujemy nasze hosty
        w sieci. Do dyspozycji mamy trzy klasy w zależności od wielkości
        naszej sieci.
      </p>
      <ul>
        <li><strong>10.0.0.0/8</strong> - 10.0.0.0 - 10.255.255.255</li>
        <li><strong>172.16.0.0/12</strong> - 172.16.0.0 - 172.31.255.255</li>
        <li><strong>192.168.0.0/16</strong> - 192.168.0.0 - 192.168.255.255</li>
      </ul>
      <p>
        Aby hosty zaadresowane adresami z klas prywatnych mogły uzyskać dostęp
        do internetu, potrzebna jest zamiana tych adresów na adresy publiczne.
        Za to odpowiada funkcja <strong>NAT</strong> - Network Address
        Translation. Ta funkcja najcześciej załączona jest na routerze
        brzegowym podłączonym do Internetu.
      </p>
      <p>
        Protokół IP w wersji 4 wyróżnia kilka zakresów adresów specjalnych
        jednym z nich są <strong>adresy pętli zwrotnej</strong> - pozwalają
        na komunikację ze samym sobą oraz sprawdzenie poprawności działania
        stosu TCP/IP. Zakres tych adresów to 127.0.0.0/8 
        (127.0.0.1 - 127.255.255.254), zazwyczaj będziemy spotykać tylko jeden
        adres tego typu - 127.0.0.1. Drugą grupą są adresy typu
        <strong>Link-local</strong>, 169.254.0.0/16
        (169.254.0.1 - 169.254.255.254), te adresy są wykorzystywane przez
        automatyczną adresację adresów IP prywatnych (tzw. APIPA),
        jest
        mechanizm pozwalający na adresowanie interfejsów sieciowych w przypadku
        gdy serwer DHCP jest niedostępny.
      </p>
      <p>
        Cała przestrzeń adresowa IP w wersji 4 jest podzielona na klasy, które
        zawierają poszczególne zakresy adresów, zatem mamy:
      </p>
      <ul>
        <li>Klasa A (0.0.0.0/8 - 126.0.0.0/8)</li>
        <li>Klasa B (128.0.0.0/16 - 191.255.0.0/16)</li>
        <li>Klasa C (192.0.0.0/24 - 223.255.255.0/24)</li>
        <li>Klasa D (224.0.0.0 - 239.0.0.0)</li>
        <li>Klasa E (240.0.0.0 - 255.0.0.0)</li>
      </ul>
      <p>
        Klasowy podział został zastąpiony poprzez adresowanie bezklasowe, przez
        co zakresy w klasach A, B i C mogą okazać się już nie aktualne.
      </p>
      <p>
        Podziałem adresów IP zajmuje się organizacja IANA, podzieliła ona bloki
        adresów na 5 oddziałów regionalnych. Te oddziały regionalne są
        odpowiedzialne przydzielanie adresów do ISP oraz do innych organizacji.
        Za Polskę oraz Europę odpowiada organizacja <strong>RIPE ncc</strong>.
      </p>
      <h2 id="1.11.4.networksegmentation">1.11.4. Segmentacja sieci</h2>
      <p>
        Wiele protokołów wykorzystuje transmisje broadkast oraz multikast.
        Przełączniki rozporowadzają transmisje broadkast na wszystkie swoje
        interfejsy po za tym, z którego ten ruch został otrzymany. Routery
        zatrzymuje te transmisje i nie propagują ich dalej. Routery dzielą
        sieci na domeny rozgłoszeniowe ograniczając wymienione wcześniej
        transmisje tylko do określonych domen.
      </p>
      <p>
        Duże domeny rozgłoszeniowe mogą być problematyczne ponieważ wiele
        hostów, może generować wiele transmisji broadkastowych, co
        wpływa negatywnie na sieć. Rozwiązaniem tego problemu może być
        podzielenie duzych sieci na mniejsze podsieci z wykorzystaniem
        routerów.
      </p>
      <p>
        Podział dużej sieci na mniejsze podsieci, obniża wielkość nadmiarowego
        ruchu i poprawia wydajnosć sieci. Pozwala na zastosowanie odbrębnych
        polityk bezpieczeństwa dla odrębnych podsieci. Podsieci zmniejszają
        liczbę urządzeń, które mogą generować dużo transmisji broadkast lub
        multikast.
      </p>
      <h2 id="1.11.5.ipv4subnets">1.11.5. Podsieci protokołu IPv4</h2>
      <p>
        Sieci IP jesteśmy w wstanie bez trudu podzielić na mniejsze podsieci
        wykorzystując do tego <strong>oktety</strong>. Adres IP ma długość
        32-bitów i jest podzielony na 4 oktety, których zakres
        jest od 0 do 255. W postaci binarnej te wartości można zapisać za
        pomocą 8 bitów. W zależności od tego jak dużej sieci potrzebujemy możem
        przesuwać tę granicę między częścią sieciowa a częścią hostową w
        lewo lub w prawo. Nieznając innych metod najprościej jest przesunąć
        tę granicę o całe 8-bitów. Przez co możemy podzielić taki zakres
        adresów IP: <em>172.16.0.0/16</em> na 256 podsieci po 254 hosty.
        Przesuwając maskę o 8 bitów w prawo. 
      </p>
<pre class="code-block">
172.16.0.0/16:
1. /24 172.16.0.0 - 172.16.0.255: 172.16.0.1 - 172.16.0.254
2. /24 172.16.1.0 - 172.16.1.255: 172.16.1.1 - 172.16.1.254
3. /24 172.16.2.0 - 172.16.2.255: 172.16.2.1 - 172.16.2.254
4. /24 172.16.3.0 - 172.16.3.255: 172.16.3.1 - 172.16.3.254
5. /24 172.16.4.0 - 172.16.4.255: 172.16.4.1 - 172.16.4.254
6. /24 172.16.5.0 - 172.16.5.255: 172.16.5.1 - 172.16.5.254
...
</pre>
      <p>
        Oczywiście sieć z maską 24-bitową, można dzielić dalej, aby jak
        najlepiej wykorzystać ilość przydzielonych nam adresów. Dzieląc tą
        podsieć na mniejsze fragmenty. Poniżej znajdują się table, które mogą
        pomóc nam podzielić czy to sieci 24-bitową czy 16.
      </p>
      <p>
        <img src="https://ftp.morketsmerke.org/img/tabela-s27.png" alt="tabela-s27" border="0">
      </p>
      <p>
        <img src="https://ftp.morketsmerke.org/img/tabela-s32.png" alt="tabela-s32" border="0">
      </p>
      <p>
        Przy podziale podsieci, niekoniecznie o całe 8 bitów, warto sobie wziąć
        pod uwagę zasadę, że ile bitów zabieramy (przekazujemy je na część
        sieciową) - X to mamy 2^X podsieci. Jeśli mamy ilość podsieci to należy
        podzielić ilość hostów z wyjściowej klasy przez ilość podsieci. Te
        rozważania mogą nam być potrzebne do rozważań na temat adresacji oraz
        w przypadku VLSM.
      </p>
      <h3 id="1.11.5.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.5.5-packet-tracer---subnet-an-ipv4-network_pl-PL.pdf">Podział sieci IPv4 na podsieci - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.5.5-packet-tracer---subnet-an-ipv4-network_pl-PL.pka">Podział sieci IPv4 na podsieci - zadanie</a>
      </p>
      <h2 id="1.11.6.subnetmeetrequirements">1.11.7. Podział na podsieci a wymagania</h2>
      <p>
        W przedsiębiorstwach możemy spotkać różne wymagania. Jednym z nich
        może być to że firma posiada dwie podsieci, jedna z nich jest siecią
        lokalną natomast druga to DMZ (wydzielona sieć dla serwerów, w tej
        sieci urządzenia mogą wykorzystywać adresy publiczne). To wówczas dla
        tej sieci lokalnej możemy wykorzystać pule adresów prywatnych a DMZ,
        niech korzysta z adresów publicznych.
      </p>
      <p>
        Sprawa zaczyna się komplikować, gdy dostajemy już jakieś wytyczne.
        Posiadamy klasę adresów <em>172.16.0.0/22</em>, co daje 1022 hosty.
        Firma posiada 5 lokalizacji, każda z nich ma mieć dostep do Internetu.
        Największa sieć w tych pięciu lokalizacji będzie miała nie więcej niż
        40 hostów. Potrzebne jest zatem 10 podsieci, o wielkości nie mniejszej
        niż 40 hostów, dla naszych potrzeb wystarczy maska o długości 26-bitów
        da to po 62 hosty na sieć, a na każdą z lokalizacji będziemy co
        najmniej dwie podsieci. Jedna podsieci będzie adresować hosty natomiast
        druga połaczenie do ISP. Mamy zatem
      </p>
<pre class="code-block">
Lokalizacja 1:
Do ISP: 172.16.0.0/26
LAN: 172.16.0.64/26

Lokalizacja 2:
Do ISP: 172.16.0.128/26
LAN: 172.16.0.192/26
#Tutaj wyczerpują się 254 hosty dla 172.16.0, dlatego trzeba przejść o jeden
#dalej na 172.16.1.

Lokalizacja 3:
Do ISP: 172.16.1.0/26
LAN: 172.16.1.64/26

Lokalizacja 4:
Do ISP: 172.16.1.128/26
LAN: 172.16.1.192/26

Lokalizacja 5:
Do ISP: 172.16.2.0/26
LAN: 172.16.2.64/26
</pre>
      <p>
        Wmiarę prosty sposób połączyliśmy te lokalizacje, tylko jest
        jednen mały szczegół. Trochę szkoda adresów na połączenie do ISP, 62
        adresy na połaczenie dwóch hostów.
      </p>
      <h3 id="1.11.6.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/11.6.6-lab---calculate-ipv4-subnets_pl-PL.pdf">Obliczanie podsieci IPv4</a>
      </p>
      <h2 id="1.11.7.vlsm">1.11.7. VLSM</h2>
      <p>
        W podanej topologii wymagane jest 7 podsieci (cztery LAN-y oraz 3 WAN-y),
        Największą siecią jest sieć w budynku D ma 28 hostów. Do tego celu
        wybieramy maskę /27, ona da 8 podsieci po 30 hostów IP. Jednak w
        ogólnym rozrachunku, zmarnujemy 84 adresy. Tak więc tradycjne podejście
        nie jest zbyt wydajne. Rozwiązaniem może być <strong>VLSM</strong>,
        który pozwoli nam na podział już podzielonej podsieci. Dzięki VLSM
        możemy dla tych trzech WAN-ów zastosować maskę /30, co da nam tylko
        dwa hosty w tej podsieci, reszta pozostanie do wykorzystania. Takie
        krótkie sieci warto wydzielać od końca, np. żeby adres broadcast całej
        puli był np. adresem broadcast tej podsieci i te mniejsze wydzielać,
        kolejno cofając się po puli.
      </p>
      <h2 id="1.11.8.structureddesign">1.11.8. Projekt strukturalny</h2>
      <p>
        Planowanie sieci IP jest istotnym elementem opracowywania skalowalnego
        rozwiązania dla sieci przedsiębiorstwa. W celu określenia schematu
        adresacji musimy zdobyć wiedzę na temat tego ile potrzebujemy
        podsieci oraz określenie ilości hostów w każdej z nich. Trzeba
        równiez przestudiować zapotrzebowanie na ruch sieciowych organizacji
        oraz określić w jaki sposób te podsieci będą mieć strukturę. Trzeba
        pod uwagę wziąć segmentaryzacje sieci oraz zapotrzebowanie na 
        adresy IP dla różnych urządzeń (jak np. serwery lub
        urządzenia sieciowe) oraz pule VLAN-ów.
      </p> 
      <h3 id="1.11.8.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.7.5-packet-tracer---subnetting-scenario_pl-PL.pdf">Praktyka projektowania i wdrażania VLSM - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.7.5-packet-tracer---subnetting-scenario_pl-PL.pka">Praktyka projektowania i wdrażania VLSM - zadanie</a>
      </p>
      <h2 id="ch11summary">Podsumowanie</h2>
      <p>
        W tym rozdziale poznaliśmy strukturę adresów IP, ich rodzaje oraz
        czym jest broadcast, unicast oraz multicast. Poznaliśmy zakresy
        adresów publicznych, prywatnych oraz tych specjalnych. Dowiedzieliśmy
        się jakie dzielić domeny rozgłoszeniowe oraz zakresy adresów IP na
        podsieci. Na koniec nauczyliśmy się jak korzystać VLSM, aby oszczędzać
        adresy podczas podziału.
      </p>
      <h3 id="1.11.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.9.3-packet-tracer---vlsm-design-and-implementation-practice_pl-PL.pdf">Projektowanie i stosowanie adresacji VLSM - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.9.3-packet-tracer---vlsm-design-and-implementation-practice_pl-PL.pka">Projektowanie i stosowanie adresacji VLSM - zadanie</a>
      </p>
      <h3 id="1.11.lab">Laboratorium</h3>
      <p>
        <a href=https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/11.10.2-lab---design-and-implement-a-vlsm-addressing-scheme_pl-PL.pdf"">Projektowanie i wdrażanie schematu adresacji VLSM</a>
      </p>
      <h1 id="1.12.ipv6adressing">1.12. Adresacja IPv6</h1>
      <p>
        Obecnie sieci komputerowe opierają się na podwójnym stosie. Nasze
        komputery są konfigurowane zarówno przy użyciu IPv4 oraz IPv6.
        IPv6 nie jest nowym wynalazkiem, ma już kilka lat. Jedną z przeszkód
        dlaczego używamy IPv4 zamiast IPv6 jest fakt, że protokół IP ma już
        coś około 40 lat. Pakiet mknąc przez przestrzeń może napotkać 
        naprawdę różny sprzęt i dostosowanie się usługodawców internetowych do
        IPv6 jest tak główną przeszkodą do odejścia od IPv4 i zmiany głównego
        protkołu internetowego. W tym rozdziale spróbujemy przybliżyć sobie
        jak wygląda adresacja IPv6. Odpowiemy również na pytanie czy ja muszę
        rzeczywiście pisać te wszystkie cyfry?
      </p>
      <h2 id="1.12.1.ipv4issues">1.12.1. Problemy IPv4</h2>
      <p>
        Adresy IPv4 są nawyczerpaniu. IPv6 jest następcą IPv4. IPv6 ma
        o wiele większą przestrzeń adresową niż IPv4. Implementacja IPv6
        posiada wiele ulepszeń i znosi wiele ograniczeń IPv4. Pula adresowa
        przeznaczona dla krajów europejskich wyczerpała się we wrześniu 2012
        roku. Wszystkie obecnie nowoprzydzielane pule są zaporzyczeniami z
        puli przeznaczonej dla kontynentu afrykańskiego.
      </p>
      <p>
        Organizacja IETF stworzyła wiele protokołów oraz narzędzi mających
        pomóc administratorom w migracji ich sieci na IPv6. Opracowane techniki
        migracji można opisać za pomocą trzech kategorii:
      </p>
      <ul>
        <li><strong>Podwójny stos</strong> - urządzenie używają obu stosów
          jednocześniej.</li>
        <li><strong>Tunelowanie</strong> - metoda przenoszenia pakietów IPv6
          przez sieć IPv4. Pakiet IPv6 jest enkasulowany w pakiecie IPv4.</li>
        <li><strong>Translacja</strong> - mechnizm NAT64 (taki NAT tylko dla
          IPv6) pozwala na komunikowanie się urządzeń używających IPv6 z
          urządzeniami korzystającymi z IPv4.</li>
      </ul>
      <p>
        Warto dodać, że tunelowanie powinno być wykorzystywane tylko tam gdzie
        jest to niezbędne. Naszym celem powinno być zapewnienie domyślnej
        komunikacji z pośrednictwem protokołu IPv6.
      </p>
      <h2 id="1.12.2.ipv6representation">1.12.2. Reprezentacja IPv6</h2>
      <p>
        Adres IPv6 mają długość 128-bitów, zapisywane są za pomocą liczb
        systemu heksadecymalnego (szesnastkowego). Zapis adresu nie jest
        wrażliwy na wielkość znaków, cyfry reprezentujące liczby od 10 (A) do 
        15 (F), można zapisać małymi lub wielkimi literami. Preferowanym
        formatem zapisu jest <code class="code-inline">x:x:x:x:x:x:x:x</code>,
        gdzie każdy <code class="code-inline">x</code> jest czterema cyframi
        heksadecymalnymi, jeden taki <em>x</em> jest również nazywany
        nieoficjalnie <em>hekstetem</em>. Poniżej znajdują się przykładowe
        adresu IPv6.
      </p>
<pre class="code-block">
2001:0db8:0000:1111:0000:0000:0000:0200
2001:0db8:0000:00a3:abcd:0000:0000:1234
</pre>
      <p>
        Powyższy zapis jest niewygodny, wymaga więcej czasu na jego zapisanie
        na stacji roboczej. Dlatego też wymyślono dwie zasady za pomocą,
        których możemy skracać zapis tego typu adresów. Zasady operają się
        na cyfrze 0. Pierwszą z nich jest <strong>ponięcie wiodącego zera</strong>
      </p>
      <p>
        Zatem jeśli mamy na początku hekstetu cyfrę 0, to możemy ją pominąć,
        a hosty same ją poźniej uzupełnią, tak aby każdy hekstet mam 4 znaki.
        Po zastosowaniu tej metody powyższe przykłady wygłądały by nastepująco.
      </p>
<pre class="code-block">
2001:db8:0:1111:0:0:0:200
2001:db8:0:a3:abcd:0:0:1234
</pre>
      <p>
        Zapis jest już krótszy i w pełni poprawny. Drugą zasadą jest
        wykorzystanie <strong>podwójnego dwukropka (::)</strong>. Ta zasada
        mówi, że możemy zastąpić następujące po sobie hekstety zer, podwójnym
        dwukropkiem. Ta zasada ma jednak ograniczenia, otóż może zostać w
        jednym adresie użyta tylko raz. Tak więc nasze adresy możemy zapisać
      </p>
<pre class="code-block">
2001:db8:0:1111::200
2001:db8:0:a3:abcd::1234
#lub jeśli zmodyfikujemy 4 hekstet z 00a3 na 0000, to wówczas taki adres
#możemy zapisać tak:
2001:db8:0:0:abcd::1234
#albo
2001:db8::abcd:0:0:1234
</pre>
      <h2 id="1.12.3.ipv6adresstypes">1.12.3 Typy adresów IPv6</h2>
      <p>
        Istnieją trzy kategorie adresów IPv6, są to m. in.:
      </p>
      <ul>
        <li><strong>Unicast</strong> - adres unikalny dla każdego hosta
          używającego IPv6.</li>
        <li><strong>Multicast</strong> - adres wykorzystywany do wysłania
          jednego pakietu IPv6 do wielu urządzeń.</li>
        <li><strong>Anycast</strong> - dowolny unikastowy adres IPv6, który
          może być przypisany do wielu urządzeń. Pakiet wysłany pakiet na ten
          adres zostanie przekierowany do urządzeń, które go posiadają.</li>
      </ul>
      <p>
        W przeciwieństwie do IPv4 w IPv6 nie ma czegoś takiego jak adres
        <em>broadcast</em>, jednak że istnie adres multikastowy kierowanych
        do wszystkich hostów, co w rezultacie daje takie same efekty.
      </p>
      <p>
        Prefiks oraz jego długość wykorzystywane są do wskazywania sieciowej
        części adresu IPv6. Przedstawiany jest jak maska IPv4 w notacji CIDR.
        Prefiks może mieć długośc od 0 do 128. Jednak rekomendowaną długością
        prefiksu dla sieci LAN oraz innych są 64-bity (/64). Jest to wręcz
        standard, ze względu na ty, że metoda SLAAC (będzie opisana poźniej),
        wykorzystuje pozostałe 64-bity na identyfikator interfejsu użytkownika.
        Użycie takie prefiksu, łatwia podział na podsieci oraz poźniejsze nimi
        zarządzanie.
      </p>
      <p>
        W przeciwieństwie do IPv4, urządzenia korzystające z IPv6 mają po dwa
        adresy przypisane do interfejsów. Pierwszym z nich jest
        <strong>Global Unicast Address (GUA)</strong> - adres ten jest podobny
        do publicznego adresu IPv4, jest unikalny w skali świata oraz
        osiągalny z Internetu. Drugim adresem jest
        <strong>Link-local Address (LLA)</strong> - jest on wymagany przez
        wszystkie urządzenia, które korzystają z IPv6 i sa wykorzystywane 
        do komunikacji tylko w sieci lokalnej przez co są nie routowalne.
      </p>
      <p>
        IPv6 posiada unikalne adresy lokalne (zakres od fc00::/7 do fdff::/7),
        (<em>Unique Local Adress</em>) 
        które posiadają pewne podobnieństwa do adresów prywatnych IPv4, ale
        również istnieje znaczące różnice. Tego rodzaju adresy sa używane do
        adresacji wewnątrz organizacji lub pomiędzy ograniczoną ich
        liczbą. Urządzenia wykorzystujące te adresy nigdy nie będą mieć
        dostępu do innych sieci za ich pośrednictwem. Unikalne adresy lokalne
        nie są ani routowalne, ani zamieniane na adresy globalne IPv6.
      </p>
      <p>
        Niektóre organizacje korzystały sieci prywatnych IPv4, aby ukryć swoje
        sieci przed zagrożeniami z Internetu, jednak to nigdy nie było 
        motywacją do stoswania adresów ULA w IPv6. 
      </p>
      <p>
        Adresami unikastowmi o zasiągu globalnym są tzw. adresy
        <em>Global Unicasts Address</em> - GUA. Tego typu adresy są swojego
        rodzaju adresy publiczne osiagne z Internetu. Obecnie przypisane
        są tylko adresy GUA rozpoczynające sie od 2000::/3, przydzielone
        (zarezerowane) zostały tylko 
        trzy bity. Przy tych trzech bitach można rozpisać tylko 2 cyfry
        2 oraz 3. Zatem obecny zakres GUA rozpoczyna się od 2000 a kończy 3fff.
      </p>
      <p>
        Adresy GUA posiadają określoną strukturę. Składa się on z globalnego
        prefiksu routing, który może być prefiksem, siecią lub pulą adresów.
        Ten prefiks routingu jest przydzielny organizcjom lub klientom przez
        ISP. Następną cześcią adresu jest identyfikator podsieci, znajduje się
        między globalnym prefiksem a identyfikatorem interfejsu. Identyfikator
        podsieci wykorzystywany identyfikacji podsieci wewnątrz organizacji.
        Ostatnią cześcią adresu jest identyfikator interfejsu, jest to część
        adresu odpowiedzialna za identyfikację hosta. Identyfikator hosta ma
        długość 64-bitów, dlatego też rekomendowane jest aby stosować
        64-bitowe prefiksy.
      </p>
      <p>
        IPv6 pozwala na przypisanie hostom adresów składajacych się z samych
        0 lub z samych 1, jednakże adres składajacy się z samych 0 jest
        zarezwowany jako adres <em>anycast</em> <em>Subnet-Router</em> i 
        powinnien być przypisany tylko do routera.
      </p>
      <p>
        Ostatnim typem adresu IPv6 jest <em>Link-local address</em> - LLA.
        Ten pozwala na komunikację wewnątrz tej samej podsieci. Pakiet
        zaadresowane przez LLA nie są routowalne. Każdy interfejs sieciowy
        działający przy użyciu IPv6 musi mieć skonfigurowane LLA, jesli nie
        jest przypisane, urządzenie przypisze je sobie samo, automatycznie.
        Prefiksem dla adresów LLA jest
        <code class="code-inline">fe80::/10</code>
      </p>
      <h2 id="1.12.4.guaandllastaticconfig">1.12.4. Statyczna konfiguracj GUA oraz LLa</h2>
      <p>
        Chcąc skonfigurować ręcznie adres IPv6 GUA, 
        w systemie IOS po przejściu do konfiguracji
        wybranego intefejsu wydajemy poniższe polecenie: 
      </p>
<pre class="code-block">
Router(config-if)# ipv6 address 2001:db8:acad:1::1/64
</pre>
      <p>
        Następnie podnośimy interfejs za pomocą polecnia
        <code class="code-inline">no shutdown</code>. Gotowe.
      </p>
      <p>
        W przypadku konfiguracji stacji roboczych, to konfiguracja wygląda
        podobnie do konfiguracji IPv4, tylko zamiast "Protokoł Internetowy
        w wersji 4" wybieramy "Protokoł Internetowy w wersji 6". Jeśli
        podajemy adres bramy, to najlepszą praktyką jest ustawienie adresu
        LLA routera.
      </p>
      <p>
        Konfigurując LLA na jednym z interfejsów w systemie IOS korzystamy
        z tego samego polecenia. Nie podajemy przy tego rodzaju adresie
        prefiksu. To specjalny adres, który go nie wymaga. Dodajemy również
        specjalne słowo kluczowe: <em>link-local</em>.
      </p>
<pre class="code-inline">
Router(config-if)# ipv6 address fe80::1:1 link-local
</pre>
      <p>
        Konfigurując LLA dla każdego z interfejsów routera warto pamiętać o tym
        aby były one unikalne (wymagane jest aby były unikalne w obrębie
        jednej podsieci).
      </p>
      <h2 id="1.12.5.dynamicaddressingforipv6gua">1.12.5. Dynamiczne adresowanie GUA w IPv6</h2>
      <p>
        Urządzenia mogą uzyskąć adres GUA dynamicznie wykorzystując do tego
        komunikaty ICMP w wersji 6. Host może wysłać zapytanie o router
        (komunikat RS <em>Router Solicitation</em>). W informacji zwrotnej w
        postaci (komunikatu RA <em>Router Advertisment</em>) od routera, host
        dowiaduje się w jaki sposób może uzyskać GUA oraz otrzymuje kilka
        dodatkowych informacji takich jak:
      </p>
      <ul>
        <li>Prefix sieci oraz jego długość.</li>
        <li>Adres domyślnej bramy.<li>
        <li>Adresy DNS oraz nazwę domenowa.</li>
      </ul>
      <p>
        Komunikat RA dostarcza trzy metody dla konfiguracji GUA:
      </p>
      <ul>
        <li>SLAAC</li>
        <li>SLAAC z bezstanowym serwerem DHCPv6</li>
        <li>Stanowy serwer DHCPv6 (bez SLAAC)</li> 
      </ul>
      <p>
        Metoda SLAAC pozwala na skonfigurowanie GUA bez usługi DHCPv6.
        Urządzenia uzyskują informacje do konfiguracji GUA z komunikatów RA
        protokołu ICMP. Prefix również znajdujący się w komunikatach RA
        jest również używany do generowania identyfikatora interfejsu czy to
        w przypadku metody EUI-64 lub metody losowej.
      </p>
      <p>
        W przypadku metody SLAAC i bezstanowego serwera DHCPv6, komunikat RA
        instruuje klientów aby wykorzystali mechnizm SLAAC to utworzenia
        GUA. LLA routera, które jest adresem źródłowym pakiety RA zostaje
        zapisany jako adres bramy. Używa się bezstanowego serwera DHCPv6 do
        uzyskania takich informacji jak adres DNS oraz nazwę domenową.
      </p>
      <p>
        Ostatnią metodą jest poinstruowanie przez pakiet RA do użycia
        stanowego serwera DHCPv6. Stanowe DHCPv6 jest podobne do DHCP dla
        IPv4. Urządzenie automatycznie otrzymuje GUA, długość prefiksu oraz
        adresy serwerów DNS z serwera DHCPv6. Komunikat RA sugeruje aby
        urządzenia użyły adresu źródłowego komunikatu RA, którym jest
        LLA jako adresu bramy oraz serwera DHCPv6 do uzyskania innych
        informacji
      </p>
      <p>
        Nie zależnie czy w RA będzie sugerowane SLAAC czy SLAAC z uzyciem
        bezstanowego DHCPv6, klient musi wygenerować identyfikator interfejsu.
        Taki identyfikator jest tworzony za pomocą metody EUI-64 lub za pomocą
        wygenerowanych losowo 64-bit liczb. 
      </p>
      <p>
        Instytucja IEEE określa EUI (<em>Extended Unique Identifier</em>) lub
        jego zmodyfikowaną wersję EUI-64, która polega na utworzeniu
        identyfikatora umieszczając 16-bitową wartość heksadecymalną <em>fffe</em>
        w środku adresu MAC interfejsu, korzystającego z tej metody, oraz
        odwróceniu w siódmego bitu adresu MAC z wartości binarnej 0 na 1.
      </p>
      <p>
        Alternatywną metodą jest wygenerowanie 64-bitów liczb heksadecymalnych
        zamiast generowania identyfikatora za pomocą metody EUI-64. Tak dzieje
        się w wszystkich współczesnych systemach MS Windows.
      </p>
      <p>
        Aby zapewnić unikalnosć adresów, hosty mogą użyć mechanizmu DAD
        (<em>Duplicate Address Detection</em>). Jest to podobne do protokołu
        ARP, żądanie o swój adres. Jeśli odpowiedź nie nadejdzie to oznacza,
        że adres jest unikatowy.
      </p>
      <h2 id="1.12.6.dynamicaddressingforipv6lla">1.12.6. Dynamiczna adresacja LLA w IPv6</h2>
      <p>
        Wszystkie interfejsy IPv6 muszą mieć przypisane LLA
        (<em>Link-local Address</em>). Podobnie do GUA, LLA może zostać
        przypisane dynamicznie. Jak pamiętamy LLA składa się z prefiksu
        <em>fe80::/10</em>, pozostałe bity są dopełniane zerami. Następnie
        występuje identyfikator interfejsu (zazwyczaj jest 64-bity liczb
        heksadecylmanych).
      </p>
      <p>
        Systemy operacyjne z rodziny Windows do konfiguracji IPv6 domyślnie
        wykorzysują utworzone przez SLAAC GUA oraz dynamicznie przydzielone
        LLA. W przypadku systemów IOS LLA jest generowane nawet wtedy gdy
        adres GUA nie jest skonfigurowany. Adres LLA w systemach firmy Cisco
        jest generowany przy użyciu EUI-64.
      </p>
      <h3 id="1.12.6.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.6.6-packet-tracer---configure-ipv6-addressing_pl-PL.pdf">Konfiguracja adresacji IPv6 - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.6.6-packet-tracer---configure-ipv6-addressing_pl-PL.pka">Konfiguracja adresacji IPv6 - zadanie</a>
      </p>
      <h2 id="1.12.7.multicasts">1.12.7. Adresy typu multicast IPv6</h2>
      <p>
        Multikastowe adresy IPv6 posiadają prefiks ff00::/8. Istnieją dwa
        rodzaje adresów multikastowych:
      </p>
      <ul>
        <li>adres multikastowy <em>Well-Known</em>,</li>
        <li>adres multikastowy <em>Solicited-node</em>.<li>
      </ul>
      <p>
        Warto zwrócić na to uwagę, że adresy multikastowe mogą być jedynie
        używane jako adresy docelowe, a nie źródłowe. 
      </p>
      <p>
        Adresy <em>Well-known</em> są adresami już przypisanymi i
        zarezerowanymi dla predefiniowanych grup urządzeń. Istnieje dwie
        powszechne grupy przypisanych adresów multikastowych:
      </p>
      <ul>
        <li><strong>ff02::1 grupa multikastowa <em>All-nodes</em></strong> - 
          Jest grupa, do której należą wszysktie hosty korzystające z IPv6.
          Pakiet wysłany do tej grupy zostanie odebrany i przetworzony przez
          wszystkie interfejsy w sieci</li>
        <li><strong>ff02::2 grupa multikastowa <em>All-routers</em></strong> -
          Grupa wszystkich routerów obsługujących routing unikastowy w dla IPv6
          (router, żeby mógł dołączyć do tej grupy musi być skonfigurowany
          poprze wydanie poniższego polecenia):
<pre class="code-block">
Router(config)# ipv6 unicast-routing
</pre>
         
        </li>
      </ul> 
      <p>
        Adres multikastowy dla <em>solicited-node</em> jest podobny do adresu
        <em>all-nodes</em>. Adres <em>solicited-node</em> jest mapowany do
        specjalnego adresu multikastowego <strong>Ethernet</strong>. Przez to
        karty sieci <em>Ethernet</em> są wstanie odfiltrować taki pakiet
        sprawdzając adres docelowy zanim trafi do przetwarzania przez IPv6
        w celu ustalenia czy host, do którego ten pakiet trafił jest hostem
        dla niego docelowym.
      </p>
      <h3 id="1.12.7.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/12.7.4-lab---identify-ipv6-addresses_pl-PL.pdf">Identyfikacja adresów IPv6</a>
      </p>
      <h2 id="1.12.8.subnetsofipv6">1.12.8. Podsieci protokołu IPv6</h2>
      <p>
        Protokół IPv6 posiada już zaprojektowaną możliwość podziału większych
        sieci na podsieci. Adres GUA posiada wydzielone pole na 
        <strong>identyfikator podsieci</strong> (<em>subnet ID</em>)
        wykorzystywane przy tworzeniu podsieci. Identyfikator podsieci znajduje
        się między globalnym prefiksem routingu, a identyfikatorem
        interfejsu.
      </p>
      <p>
        Załóżmy, że otrzymaliśmy globalny prefiks routingu o wartości:
        <code class="code-inline">2001:db8:acad::/48</code>, wraz 16-bitami
        identyfikatora podsieci to daje nam 65,535 podsieci. Globalny prefiks
        pozostaje dla wszystkich tych podsieci, inkrementacji natomiast będzie
        ulegać jedynie kolejny po nim hekstet.
      </p>
<pre class="code-block">
2001:db8:acad:0000::/64
2001:db8:acad:0001::/64
2001:db8:acad:0002::/64
2001:db8:acad:0003::/64
2001:db8:acad:0004::/64
2001:db8:acad:0005::/64
2001:db8:acad:0006::/64
2001:db8:acad:0007::/64
2001:db8:acad:0008::/64
2001:db8:acad:0009::/64
2001:db8:acad:000a::/64
2001:db8:acad:000b::/64
2001:db8:acad:000c::/64
...
2001:db8:acad:ffff::/64
</pre>
      <p>
        Posieciami IPv6 w praktyce operujemy tak samo jak w przypadku podsieci
        IPv4. Dla każde z nich potrzebujemy osobnego interfejsu na routerze.
      </p>
      <h3 id="1.12.8.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.9.1-packet-tracer---implement-a-subnetted-ipv6-addressing-scheme_pl-PL.pdf">Implementacja schematu adresowania podsieci IPv6 - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.9.1-packet-tracer---implement-a-subnetted-ipv6-addressing-scheme_pl-PL.pka">Implementacja schematu adresowania podsieci IPv6 - zadanie</a>
      </p>
      <h2 id="ch12summary">Posumowanie</h2>
      <p>
        W tym rodziale zostaliśmy zaznajomieni z protokołe IPv6 zobaczyliśmy
        jak wygląda taki adres IPv6 i w jaki sposób można go zapisać.
        Poznaliśmy rodzaje adresów tego protokołu oraz nauczyliśmy się
        konfigurować statyczne adresy GUA oraz LLA. Przedstawiono nam
        techiniki dynamicznego uzyskiwania adresu GUA oraz LLA. Na koniec
        dowiedziliśmy się jakie są adresy multikastowe dla IPv6 oraz
        zapoznaliśmy się z podziełem sieci IPv6 na podsieci.
      </p>
      <h2 id="1.12.lab">Laboratorium</h2>
      <p>
        <a href=https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/12.9.2-lab---configure-ipv6-addresses-on-network-devices_pl-PL.pdf"">Konfiguracja adresów IPv6 urządzeń sieciowych</a>
      </p>
      <h1 id="1.13.icmpprotocol">1.13. Protokół ICMP</h1>
      <p>
        Protokół ICMP jest protokołem diagnostyczno-kontrolnym, wspomagający
        protokoł IP. Przez użytkowników może zostać wykorzystany do sprawdzenia
        połączenia z siecią oraz weryfikacji trasy wysyłanych pakietów.
      </p>
      <h2 id="1.13.icmpmessages">1.13.1. Komunikaty protokołu ICMP</h2>
      <p>
        Protokoł ICMP dostarcza informacji o problemach związanych z
        przetwarzaniem pakietów IP w określonych warunkach.
      </p>
      <p>
        ICMP w wersji 4 posiada głównie funkcjonalność sygnalizacyjną na IPv4.
        Natomast w przypadku IPv6 funkcjonalność protokołu ICMPv6
        rozszerzono o dodatkowe role.
      </p>
      <p>
        Oczywiśćie ICMP dla IPv6 dalej pozostaje protokołem sygnalizacyjnym.
        Obie wersje protokółu wspierają podstawowe komunikaty takie
        jak:
      </p>
      <ul>
        <li>Osiągalność hosta</li>
        <li>Nieosiągalność celu lub usług</li>
        <li>Wyczerpanie czasu</li>
      </ul>
      <p>
        Warto zaznaczyć, że nie ze wszystkich sieci otrzymamy odpowiedź,
        ponieważ w wielu z nich protokół ICMP jest blokowany przy użyciu
        zapory, ze względów bezpieczeństwa.
      </p>
      <p>
        Do badania osiągalności hosta, można wykorzystać komunikat 
        ICMP <strong>Echo</strong>. Jeden z hostów wysyła do drugiego
        żądanie <em>Echo</em> (<em>request</em>), jeśli ten drugi host jest
        osiągalny to odpowie przy użyciu komunikatu odpowiedzi <em>Echo</em>
        (<em>reply</em>)
      </p>
      <p>
        W przypadku mierzenia osiagalności celów oraz usług sprawa trochę
        bardziej skomplikowana. Komunikat ICMP może zawierać specjalny
        kod, który wskaże nam dlaczego pakiety nie mogą dotrzeć.
      </p>
      <p>
        Dla IPv4 są to kolejno:
      </p>
      <ul>
        <li><strong>0</strong> - sieć jest nieosiągalna</li>
        <li><strong>1</strong> - host jest nieosiągalny</li>
        <li><strong>2</strong> - protokół jest nieosiągalny</li>
        <li><strong>3</strong> - port jest nieosiągalny</li>
      </ul>
      <p>
        Natomiast dla IPv6 są to kolejno:
      </p>
      <ul>
        <li><strong>0</strong> - brak trasy do celu</li>
        <li><strong>1</strong> - komunikacja z celem została zablokowana przez
          administratora (np. na komunikację nie pozwala firewall)</li>
        <li><strong>2</strong> - poza zakresem adresu źródłowego</li>
        <li><strong>3</strong> - adres nieosiągalny</li>
        <li><strong>4</strong> - port nieosiągalny</li>
      </ul>
      <p>
        Innym rodzajem komunikatu jest upłynięcie czasu. Jak możemy pamiętać
        z budowy nagłówka pakietu IPv4, to zawiera on pole TTL, każde
        przejście pakietu przez router obniża tą wartość o 1, aż do jej
        wyzerowania. W momecie wyzerowania pola TTL, dla np. naszego
        żądania <em>Echo</em>, możemy otrzymać komunikat o tym, że pole TTL
        zostało wyzerowane w trakcie przesyłu pakietu
      </p>
      <p>
        Protokół ICMP dla IPv6 został zaktualizowany, a jego funkcjonalność
        została rozszerzona na 4 nowe rodzaje komunikatów jako część
        protokołu <em>Neighbor Discover Protocol</em>.
      </p>
      <p>
        Nowe komunikaty dzielą się na wymieniane między hostem a routerem,
        to jest:
      </p>
      <ul>
        <li><strong>Zapytanie o router</strong> - <em>Router Solicitation</em>
          (RS)</li>
        <li><strong>Ogłaszanie się routera</strong> -
          <em>Router Advertisement</em> (RA)</li>
      </ul>
      <p>
        Jak i na te wymienie między hostami, to jest:
      </p>
      <ul>
        <li><strong>Zgłoszenie się hosta</strong> -
          <em>Neighbor Solicitation</em> (NS)</li>
        <li><strong>Ogłoszenie się hosta</strong> -
          <em>Neighbor Advertisement</em> (NA)</li>
      </ul>
      <p>
        ICMPv6 zawiera jeszcze inne komunikaty, ale są one np. podobne do 
        komunikatu przekierowania (<em>redirect</em>) wykorzystywanego IPv4.
      </p>
      <p>
        Komunikaty RA w IPv6 są wysyłane przez router co 200 sekund, aby
        dostarczyć informacje do wszystkich obsługujących IPv6 urządzeń.
        Poza adresami routera przekazywany jest prefix i jego długość, adresy
        DNS czy nazwa domenowa. Komunikaty RA są wykorzystywane do konfiguracji
        bramy domyślnej dla hostów, które są ustawione na samodzielną
        konfigurację.
      </p>
      <p>
        Routery odpowiedzą za pomocą komunikatu RA na otrzymany komunikat RS.
        Hosty wysyłają RS w celu określenia informacji na temat adresacji
        protokołu IPv6.
      </p>
      <p>
        Urządzenia, które mają skonfigurowane IPv6 pod GUA lub Local-Link,
        mogą używać mechanizmu <strong>DAD</strong>
        (<em>Duplicate Adress Detection</em>) w celu upewnienia się o
        unikalności adresu. W celu sprawdzenia unikalności swojego adresu
        host wysyła komunikat NS, ustawiając swój adres jako adres docelowy.
        Jeśli jeden z hostów będzie mieć taki adres, wówczas odpowie na tem
        pakiet komunikatem (NA).
      </p>
      <p>
        W przypadku IPv6 protokół ICMP w wersji 6, przejął rozwiązywanie
        adresów IP na adresy MAC. Host, który potrzebuje adresu MAC innego
        hosta wysła do niego komunikat NS. W odpowiedzi host odpowiada
        komunikatem NA zawierającym adres MAC stacji, która go wysłała.
      </p>
      <h2 id="1.13.2.pingandtraceroutetests">1.13.2. Testy ping oraz traceroute</h2>
      <p>
        Polecenie <strong>ping</strong> jest narzędziem testowym zarówno dla
        IPv4 i IPv6. Polega ono na wysłaniu kilku komunikatów 
        <em>echo requests</em> i oczekiwaniu na <em>echo reply</em>
        wyswietlając każdą odpowiedź. Na koniec zwracane jest podsumowanie
        zawierające m. in. uśredniony czas wszystkich odpowiedzi. Polecenia
        ping mogą wyglądać różnie w zależności od systemu.
      </p>
<pre class="code-block">
#MS Windows:
C:\Users\xf0r3m\Desktop&gt;ping 192.168.8.1

Pinging 192.168.8.1 with 32 bytes of data:
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64

Ping statistics for 192.168.8.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

#Dystrybucja Linuksa - immudex:
󱩊 xf0r3m@laptop-45f33b2/ ~/󰯆 ping 192.168.8.1
PING 192.168.8.1 (192.168.8.1) 56(84) bytes of data.
64 bytes from 192.168.8.1: icmp_seq=1 ttl=64 time=0.591 ms
64 bytes from 192.168.8.1: icmp_seq=2 ttl=64 time=0.643 ms
64 bytes from 192.168.8.1: icmp_seq=3 ttl=64 time=0.524 ms
64 bytes from 192.168.8.1: icmp_seq=4 ttl=64 time=0.793 ms
^C
--- 192.168.8.1 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3078ms
rtt min/avg/max/mdev = 0.524/0.637/0.793/0.099 ms

#Cisco IOS - przełącznik (ver. 15.2):
Switch#ping 192.168.8.1

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.8.1, timeout is 2 seconds:
.!!!!
Success rate is 80 percent (4/5), round-trip min/avg/max = 0/0/0 ms
</pre>
      <p>
        Polecenie ping możemy zastosować kilku scenariuszach aby uzyskać kilka
        odpowiedzi. Jeśli chcemy sprawdzić czy nasz stos sieciowy działa
        poprawnie możemy zpingować swój adres pętli zwrotnej:
        <code class="code-inline">ping 127.0.0.1</code>. Pozytywna odpowiedź
        oznacza, że nasz host może funkcjonować we wszystkich współczesnych
        sieciach. Drugim testem jaki możemy wykonać jest ping na adres bramy
        domyślnej, pozwoli nam to ustalić czy nasz konfiguracja IP jest
        prawidłowa. Szczególnie przydatne, gdy konfigurowaliśmy nasz interfejs
        ręcznie
        bez użycia serwera DHCP. Jeśli odpowiedź na ten test będzie pozytywna
        to oznacza, to że nasz host ma możliwość komunikacji w sieci, do
        której jest podpięty. Ostatnim trzecim testem jest sprawdzenie
        dostępności jakiegoś hosta w Internecie lub w drugiej sieci. Takie
        działania może mieć na celu upewnienie się, że mamy dostęp Internetu
        oraz, że nasz router jest skonfigurowany jeśli obsługuje on więcej niż
        dwie sieci.
      </p>
      <p>
        Innym z narzędzi pozwalających nam testować możliwości połączenia. Jest
        <strong>traceroute</strong> w systematch takich jak Windows może
        nosić nazwę <em>tracert</em>. Nie koniecznie może być przedatne
        zwykłym użytkownikom, ale jeśli administrator ma kilka routerów, to
        za pomocą tego narzędzia sprawdzić możliwości komunikacji miedzy
        odległymi sieciami. Działa ono w oparciu o komunikat 
        <em>Time exceeded</em> manipulując wartością TTL. Na początku nadawca
        wysyła pakiet IP z zawartością ICMP do docelowego hosta
        ustawia TTL na jeden i przesyła do bramy. Brama zmniejsza TTL i
        odsyła do klienta komunikata <em>time exceeded</em>, nam na ekranie
        pojawia się pierwszy skok. Następnie nadawca zwiększa TTL o 1 i
        wysyła ponownie i tak dalej, aż osiągnie cel podany podczas wydawania
        polecenia lub liczba skoków osiągnie 30. Zamiast nazw hostów (routerów)
        lub ich adresów IP zobaczymy gwiazdki (<strong>*</strong>), wówczas
        oznaczna to, że wysłany pakiet został utracony lub host nie jest
        w stanie (np. ze względów bezpieczeństwa) opowiedzieć za pomoca
        komunikatu <em>time exceeded</em>.
      </p>
      <p>
        W przypadku nagłówków pakietów IPv6 nie mamy doczynienia z polem TTL, a
        z polem <em>Hop Limit</em>.
      </p>
      <h3 id="1.13.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.6-packet-tracer---verify-ipv4-and-ipv6-addressing_pl-PL.pdf">Weryfikacja adresacji IPv4 i IPv6 - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.6-packet-tracer---verify-ipv4-and-ipv6-addressing_pl-PL.pka">Weryfikacja adresacji IPv4 i IPv6 - zadanie</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.7-packet-tracer---use-ping-and-traceroute-to-test-network-connectivity_pl-PL.pdf">Stosowanie komendy ping oraz traceroute do testowania połączeń w sieci - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.7-packet-tracer---use-ping-and-traceroute-to-test-network-connectivity_pl-PL.pka">Stosowanie komendy ping oraz traceroute do testowania połączeń w sieci - zadanie</a>
      </p>
      <h2 id="ch13summary">Podsumowanie</h2>
      <p>
        Ten rozdział zamyka warstwę trzecią. Poznaliśmy w nim protokoł ICMP, 
        podstawowe komunikaty oraz ich rodzaje. Dowiedzieliśmy się jaką ważną
        rolę będzie pełnić ten protokół w sieciach opartych na IPv6. 
        Na koniec omówiliśmy sobie sposób działania narzędzi takich jak 
        <em>ping</em>
        czy <em>traceroute</em> oraz w jaki sposób wykorzystują do swojego
        działania komunikaty protokołu ICMP.
      </p>
      <h3 id="1.13.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
         <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.3.1-packet-tracer---use-icmp-to-test-and-correct-network-connectivity_pl-PL.pdf">Używanie ICMP do testowania i korygowania łączności - scenariusz</a>
         <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.3.1-packet-tracer---use-icmp-to-test-and-correct-network-connectivity_pl-PL.pka">Używanie ICMP do testowania i korygowania łączności - zadanie</a>
      </p>
      <h3 id="1.13.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/13.3.2-lab---use-ping-and-traceroute-to-test-network-connectivity_pl-PL.pdf">Stosowanie komendy ping oraz traceroute do testowania połączeń w sieci</a>
      </p>
      <h1 id="1.14.transportlayer">1.14. Warstwa transportowa</h1>
      <p>
        Warstwa transportowa jest odpowiedzialna za komunikację pomiędzy
        aplikacjami uruchomionymi na różnych komputerach. Wraz z niższymi 
        warstwami odpowiedzialna jest za komunikację sieciową.
      </p>
      <h2 id="1.14.1.transportationofdata">1.14.1. Dostarczanie danych</h2>
      <p>
        Warstwa transportowa jest odpowiedzialna za takie czynności jak: 
      </p>
      <ul>
        <li>Śledzenie indywidualnych połączeń</li>
        <li>Segmentacje danych i ich ponowne złożenie</li>
        <li>Dodanie nagłówka informacji do danych, tworząc segment</li>
        <li>Identyfikacje, separację oraz zarządzanie wieloma połączeniami</li>
        <li>Wykorzystanie segmentacji oraz multipleksacji do umożliwienia
          prowadzenia wielu połączeń w tej samej sieci.</li>
      </ul>
      <p>
        Warstwa IP nie ma możliwość bezpośredniego dostarczenia danych w
        docelowe miejsce. Określają to protokoły warstwy transportowej są one
        odpowiedzialne za sposób wymiany danych między hostami oraz
        za spełnienie wymagań wykorzystywanych połączeń. Protokołami warstwy
        transportowej są <strong>TCP</strong> oraz <strong>UDP</strong>.
      </p>
      <p>
        Protokoł TCP wybierany jest przez aplikacje wymagające niezawodnego
        połączenia. Funkcjonalnością warstwy transportowej, za które odpowiada
        protokół TCP to:
      </p>
      <ul>
        <li>Numerowanie oraz śledzenie segmentów danych dostarczanych do
          określonych hostów oraz określonych aplikacji</li>
        <li>Potwierdzenie otrzymania danych</li>
        <li>Retransmisję każego niepotwierdzonego fragmentu danych, po
          określonyn czasie.</li>
        <li>Skwencjonowane dane mogą być dostarczane w dowolnej kolejności</li>
        <li>Dostosowanie wysyłania danych do możliwości odbiorcy.</li>
      </ul>
      <p>
        Protokoł UDP dostacza bardzo podstawowywch funkcji dostarczania danych
        między określonymi aplikacjiami, przy minimalnym obciążeniu oraz
        weryfikacji poprawności przesyłanych danych. Cechami, które wyróżniają
        ten protokoł jest:
      </p>
      <ul>
        <li>Protokoł UDP jest bezpołączeniowy.</li>
        <li>Protokół UDP uznawany jest protokoł <em>best-effort</em>, ponieważ
          nie stosuje on potwierdzeń po otrzymaniu danych.</li>
      </ul>
      <p>
        Protokół UDP jest również wykorzystywany dla aplikacji działajacej na
        zasadzie żądanie-odpowiedź, gdzie ilość danych jest niewielka, nie
        ma tam również retransmisji, przez co taka wymiana informacji może
        zostać bardzo szybko zrealizowana. Przykład: transmisja głosu (VoIP),
        komunikacja z DNS. Wymagane cechy:
      </p>
      <ul>
        <li>Szybki</li>
        <li>Minimalne obciążenie</li>
        <li>Nie wymaga potwierdzeń</li>
        <li>Nie wysyła retransmisji</li>
        <li>Dostarcza dane w kolejności w jakiej dotrą do hosta docelowego</li>
      </ul>
      <p>
        Inne aplikacje, którym bardziej zależy na jakość przesyłanych danych
        wybiorą transmisję opartą na protokole TCP. Przykład: Poczta
        elektroniczna (protokoły IMAP/SMTP) czy przeglądanie sieci WWW (HTTP).
        Wymagane cechy:
      </p>
      <ul>
        <li>Rzetelny</li>
        <li>Wysyła potwierdzenia otrzymania danych</li>
        <li>Dokonuje retransmisji zagubionych danych</li>
        <li>Dostarcza dane w kolejności ich wysłania przez hosta źródłowego.</li> 
      </ul>
      <h2 id="1.14.2.tcpheader">1.14.2. Nagłówek TCP</h2>
      <p>
        Podczas ekapsulacji dane z warstwy aplikacji trafiają do wartstwy
        transportowej. Tutaj surowe dane z aplikacji są zamieniane w segmenty
        po dodaniu nagłówka wykorzystywane do transmisji protokołu warstwy
        transportowej. Poniżej znajduje się obraz przedstawiający nagłówek
        TCP.
      </p>
      <p>
        <img src="https://ftp.morketsmerke.org/img/tcp-header.png" alt="tcp-header" border="0">
      </p>
      <ul>
        <li><strong>Port źródłowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji źródłowej.</li>
        <li><strong>Port docelowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji docelowej.</li>
        <li><strong>Numer sekwencji</strong> - 32-bitowe pole przechowywujące
          numer porządkowy dla celu ponownego złożenia informacji w kolejności
          w jakiej została wysłana.</li>
        <li><strong>Numer potwierdzenia</strong> - 32-bitowe pole wykorzysywane
          do wskazania danych, które zostały otrzymane oraz następny bajt
          oczekiwany od źródła.</li>
        <li><strong>Długość nagłówka</strong> - 4-bitowe pole bardziej znane
          jako offset danych, wskazuje długość nagłówka segmentu TCP.</li>
        <li><strong>Zarezerowane</strong> - 6-bitowe pole pozostawione do
          poźniejszego wykorzystania.</li>
        <li><strong>Bity kontrolne</strong> - 6-bitowe pole zawierające flagi
          oraz kody bitowe, wskazując cel oraz funkcję tego segmentu TCP.</li>
        <li><strong>Rozmiar okna</strong> - 16-bitowe pole wskazujące liczbę
          bajtów, która może być potwierdzona za jednym razem.</li>
        <li><strong>Suma kontrolna</strong> - 16-bitowe pole używane to
          do ustalenia poprawności segmentu.</li>
        <li><strong>Ważność</strong> - 16-bitowe pole wykorzystywane do
          wskazania ważności (istotności) przesyłanych danych.</li>
      </ul>
      <h2 id="1.14.3.udpheader">1.14.3. Nagłowek UDP</h2>
      <p>
        Segmenty UDP rownież posiadają nagłówki, jednak nie tak rozbudowne
        jak w przypadku TCP. Dla porównania nagłówek UDP zawiera tylko 4 pola.
      </p>
      <p>
        <img src="https://ftp.morketsmerke.org/img/udp-header.png" alt="udp-header" border="0">
      </p>
      <ul>
        <li><strong>Port źródłowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji źródłowej.</li>
        <li><strong>Port docelowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji docelowej.</li>
        <li><strong>Długość nagłówka</strong> - 4-bitowe pole bardziej znane
          jako offset danych, wskazuje długość nagłówka datagramu UDP.</li>
        <li><strong>Suma kontrolna</strong> - 16-bitowe pole używane to
          do ustalenia poprawności datagramu.</li>
      </ul>
      <h2 id="1.14.4.portnumbers">1.14.4. Numery portów</h2>
      <p>
        Protokoły TCP oraz UDP wykorzystują numery portów do zarządzania
        działająch w tym samym czasie połączeń. Port źródłowy wskazuje
        aplikację źródłową na lokalnym hoście natomast port docelowy
        aplikację docelową na hoście zdalnym.
      </p>
      <p>
        Porty znajdują się wewnątrz segmentów warstwy transportowej, Segmenty
        natomiast są enkapsulowane w pakiety IP. Kombinacja adresu IP oraz 
        numeru portu nie ważne, z której strony w transmisji nazwany jest
        <strong>gniazdem</strong>. Gniazda umożliwiają klientom wielkrotne
        połączenia z tym samym serwerem, czy tą samą usługą.
      </p>
      <p>
        Portów ze względu na rozmiar pola portu docelowego i źródłego ma
        długość 16-bitów, to bez modyfikacji nagłówków porty mają zakres
        od <strong>0</strong> do <strong>65535</strong>. Większość portów jest
        już przydzielona i mozna je podzielić na trzy mniejsze zakresy,
      </p>
      <ul>
        <li><strong>Dobrze znane porty</strong> - zakres:
          <strong>0 - 1023</strong> - większość znanych nam usług sieciowych,
          HTTP, FTP czy poczta.</li>
        <li><strong>Porty zarejestrowane</strong> - zakres:
          <strong>1023 - 49151</strong> - Porty przydzielone przez IANA dla
          aplikacji i procesów, znane porty z tego zakresu np.: 2049/TCP NFS
          czy 3306/TCP serwer baz danych MySQL.</li>
        <li><strong>Porty prywatne/dynamiczne</strong> - zakres:
          <strong>49152 - 65535</strong> - Porty do wykorzystywane przez
          klienta jako port źródłowy.</li>
      </ul>
      <p>
        Nie będę wypisywał tutaj jakiś list. Wszystko jest dostępne w
        Internecie lub w dystrybucjach Linuksa w pliku <em>/etc/services</em>.
      </p>
      <p>
        Warto odczasu do czasu zwrócić uwagę na to jakie połaczenia są
        realizowane w naszym systemie w zależności od systemu możemy
        wykorzystać do tego albo polecenie <strong>netstat</strong> dla
        MS Windows lub <strong>ss</strong> dla dystrybucji Linuksa.
      </p>
      <h2 id="1.14.5.tcpcommunicationproces">1.14.5. Procesy komunikacji TCP</h2>
      <p>
        Każdy proces aplikacji serwera jest skonfigurowany w taki sposób, aby
        korzystać z portów. Dwie aplikacje na tym samym serwerze nie mogą mieć
        przypisanych tych samych portów. Aktywna aplikacja z przypisanym
        portem uznaje się za <strong>otwarą</strong>, oznacza to mniej więcej
        tyle, że jej proces przyjmie dane przekazane do tego portu. Oznacza to
        również, że każde żądanie od klientów jest akceptowane i dane
        przekazywane są do procesu aplikacji.
      </p>
      <p>
        Klient nawiązuje połączenie w tzw. schemacie
        <em>Three-Way-Handshake</em>. W wygląda to mniej więcej w taki sposób
      </p>
      <ol>
        <li>Klient incjalizuje połaczenie w modelu klient-serwer z serwerem
          wysyłając do niego segment z ustawioną flagą SYN.</li>
        <li>Serwer odpowiada na próbę inicjalizacji połączenia odsyłając
          do klienta segment z ustawionymi flagami SYN, ACK.</li> 
        <li>Klient przesyła odpowiedź do serwera z ustawiona flagą ACK i w ten
          połączenie zostaje nawiązane.</li>
      </ol>
      <p>
        Zamykanie połączeń odbywa się podobny sposób. Jeśli nie ma więcej
        danych do przesłania, klient wysyła segment z ustawioną flaga FIN.
        Następnie serwer wysyła dwa segementy jeden z odpowiedzią na wysłaną
        flage FIN oraz drugi segment z ustawioną flagą FIN wysłaną do klienta.
        Kiedy klient odbierze taki segment, potwierdza za pomocą flagi ACK,
        jego odebranie i połącznie zostaje zakończone.
      </p>
      <p>
        Flagi kontrone wykorzystywane do zarządzania połączeniami TCP:
      </p>
      <ul>
        <li><strong>URG</strong> - Wskaźnik ważności pola <em>Urgent</em>.</li>
        <li><strong>ACK</strong> - Flaga potwierdzająca wykorzystywana
          normalnej komunikacji, ale również w przy nawiązywaniu i kończeniu
          połączeń.</li>
        <li><strong>PSH</strong> - funkcja push</li>
        <li><strong>RST</strong> - restartuje połączenie kiedy napotkano błąd
          lub minął czas oczekiwania.</li>
        <li><strong>SYN</strong> - Synchonizacja numerów sekwencyjnych,
          flaga wykorzystywana podczas nawiązywania połączenia.</li>
        <li><strong>FIN</strong> - Wysyłający nie ma więcej danych, używane
          do zamykania połączeń</li>
      </ul>
      <h2 id="1.14.6.tcpreliabilityandfc">1.14.6. Niezawodność i kontrola przepływu transmisji TCP</h2>
      <p>
        W przypadku transmisji sieciowej może dojść do zgubienia części danych
        (pakietu) z róznych przyczny, rownie istotna może być ścieżka jaką
        poruszają się pakiety do miejsca docelowego, pakiety z tego samego
        źródła wysłane inną ścieżką mogą dotrzeć do celu poźniej niż inne.
        Wówczas warstwa transportowa otrzymała dane nie pokolei. Podobnie jest
        w przypadku utracenia danych, ponieważ muszą one zostać
        retransmitowane. Jednak zawarty w nagłówkach numer sekwencji pozwoli
        mechnizmom zawartym w protokole TCP złożyć widomość, tak aby nie
        różniła się niczym od tej wysłanej przez nadawcę.
      </p>
      <p>
        Ciekawym mechnizmem może być <strong>SACK</strong>. Załóżmy taki
        przypadek, że mamy ustawione okno na odpowiedź po 10 segemencie, ale
        protokoł TCP uznał, że 3 i 4 segment są uszkodzone i wymagana jest ich
        retransmisja. To w normalnym przypadku nadawca dowiedział by się o tym
        fakcie dopiero po przesłaniu 10 segmentu. No dobrze troche by to
        opóźniło transmisje, ale mamy już nasz 3 i 4 segment, a to nie koniec
        ponieważ okno ustawione na 10 segment, to otrzymamy także segmenty od
        5 do 10. To jeśli uda się ustalić w SACK czyli
        <strong>odpowiedź selektywna</strong>. W momecie gdy nadawca dowiaduje,
        że potrzebna jest retransmisja w dodatkowym polu w segemencie
        potwierdzenia zwracany jest numer sekwencyjny segmentu, który wymaga
        retransmisji ale w dodatkowym polu SACK znajdują się te numery
        sekwencyjne, które odbiorca już ma i uznał je za poprawne.
      </p>
      <p>
        Kontrola przepływu polega na dostosowaniu ilości wysyłanych danych do
        możliwości odbiorcy. W przypadku protokołu TCP, kontrola przepływu
        pomoga utrzymać stabliność i niezawodność tego protokołu. W jedym z
        takich parametrów jest <strong>MSS</strong>, który określa wielkość
        danych niesionych w pakietach. Standardowo dla Etherenetu jest 1460B.
        Maksymalne MTU dla Ethernetu to 1500B, od tego musimy odjąć 20B dla 
        nagłówka IP oraz 20B dla nagłówka TCP. Wiec pozostaje 1460B na dane z
        warstwy aplikacji.
      </p>
      <p>
        Protokół TCP ma również dodatkowe mechanizmy dzięki, którym mocno
        obciażona stacja robocza, nie zostanie zalana segmentami w momencie
        kiedy nie jest wstanie odpowiedzieć, tym mechnizmem zarządza nadawca i
        nazywają sie <em>Congestion Avoidance</em> - unikanie zatorów.
      </p>
      <h2 id="1.14.7.udpcommunication">1.14.7. Komunikacja z wykorzystaniem protokołu UDP</h2> 
      <p>
        Protokół UDP nie zestawia połączenia. Ma on również mały narzut,
        ponieważ jego nagłówek jest mniejszy i nie zarządza on ruchem.
      </p>
      <p>
        UDP nie korzysta z numerów sekwencji tak jak robi to TCP, przez co nie
        możliwości uprządkowania pakietów w takiej samej kolejności w jakiej 
        zostały wysłane.
      </p>
      <p>
        Serwery korzystające z transmisji UDP wykorzystują dobrze znane lub
        zarejestrowane porty. Kiedy datagram UDP dotrze do komputera
        docelowego jest on przekazywany do aplikacji na podstawie przypisanego
        jej numery portu.
      </p>
      <p>
        Klienci transmisji UDP przypisują sobie porty dynamicznie, przeważnie
        z tej ostatniej grupy. Następnie ten port oraz port docelowy są
        używane w nagłówkach datagramów.
      </p>
      <h3 id="1.17.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/14.8.1-packet-tracer---tcp-and-udp-communications_pl-PL.pdf">Komunikacja z użyciem protokołów TCP i UDP - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/14.8.1-packet-tracer---tcp-and-udp-communications_pl-PL.pka">Komunikacja z użyciem protokołów TCP i UDP - zadanie</a>
      </p>
      <h2 id="ch15summary">Podsumowanie</h2>
      <p>
        W tym rodziale dowiedzieliśmy za co jest odpowiedzialna warstwa
        transportowa oraz jakie są jej funkcje. Poznaliśmy dwa protokoły
        tej warstwy - TCP oraz UDP, scharakteryzowaliśmy ich nagłówki.
        Następnie skupiliśmy się na opisaniu funkcjonalności protokołu TCP, na
        koniec krótko został przedstawiony protokół UDP.
      </p> 
      <h1 id="1.15.applicationlayer">1.15. Warstwa aplikacji</h1>
      <p>
        W warstwie aplikacji znajdują się elementy komunikacji sieciowej,
        z którymi użytkownik ma styczność podczas korzystania z zasobów
        Internetu. Na warstwę aplikacji składają się nie tylko aplikacje jakby
        sama nazwa miała wskazywać, ale także stojące za nimi protokoły, czy
        też metody prezentacji treści audio czy wideo, ale także utrzymanie
        połączenia między aplikacjami. W materiałach Cisco jak pamiętamy 
        posługujemy się siedmiowarstowym modelem ISO/OSI, tak więc tutaj
        warstwa aplikacji, jaką możemy znać z modelu TCP/IP jest przedstawiona
        w postaci trzech mniejszych warstw.
      </p>
      <h2 id="1.15.1.aplicationpresentationsession">1.15.1. Warstwy aplikacji, prezentacji i sesji</h2>
      <p>
        Warstwa aplikacji dostarcza interfejsu wykorzystywanego przez aplikacje
        do komunikacji oraz umożliwia korzystanie z sieci do przesyłania
        wiadomości między nimi.
      </p>
      <p>
        W tej warstwie rezydują znane wszystkim protokoły takie jak HTTP, DNS,
        FTP, IMAP, SMTP, ale także taki protokoł jak DHCP.
      </p>
      <p>
        Niższa wartswa prezentacji odpowiedzialna jest za formatowanie i
        prezentacje pozwalając dostosować dane źródłowe do postaci
        kompatybilnej z urządzeniem końcowym. Metody kompresji pozwalające
        na przyspieszenie ładowania zasosbu oraz ewentualną oszczędność miejsca
        jeśli taki zasób miał by zostać przechowany na naszych urządzeniach
        również rezydują w tej warstwie. Ostatnią cechą warstwy prezentacji
        jest zabzpieczenie transmisji przy użyciu metod szyfrowania, takich jak
        dobrze nam znany <strong>TLS</strong>.
      </p>
      <p>
        Warstwa sesji jest natomiast odpowiedzialna za utrzymaniem wirtualnego
        dialogu pomiędzy aplikacjiami, tzw. <strong>sesji</strong>. Warstwa ta
        zajmuje się umożliwieniem jej inicjalizacji celem wymiany informacji
        pomiędzy aplikacjami, jej utrzymaniem oraz ewentualnym restartem jeśl
        będą ku temu przesłanki.
      </p>
      <p>
        W warstwie aplikacji znajdują się protokoły określające standardy
        w wiekszości komunikacji sieciowej. Te protokoły muszą być stosowane
        przez obie strony i ich implementacje powinny być ze sobą kompatybilne,
        aby komunikacja mogła dość do skutku.
      </p>
      <h2 id="1.15.2.p2p">1.15.2. Komunikacja peer-to-peer</h2>
      <p>
        Obecny model komunikacji w Internecie opiera się o model
        <strong>klient-serwer</strong>, jego działanie opiera się na żądaniu
        przez klienta zasobów, które udostępnia serwer. Procesy zarówno
        klienta jak i serwera znajdują się w warstwie klienta. Format żądań
        i odpowiedzi klienta i serwera jest określany przez protokoły warstwy
        aplikacji.
      </p>
      <p>
        W modelu P2P dwoje lub więcej komputerów może współdzielić zasoby takie
        jak pliki czy drukarki bez dedykowanego serwera. W tym modelu każdy
        jest serwerem oraz klientem, dla jednego połączenia dany host może być
        serwerem a w miedzy czasie przy użyciu innego połączenia pobierać plik
        z innego hosta. Popularnymi programami działającymi w trybie 
        <em>peer-to-peer</em> jest klienci sieci BitTorrent, czy usługa Freenet.
      </p>
      <h2 id="1.15.3.webandemail">1.15.3. Protokół HTTP oraz protokoły pocztowe.</h2>
      <p>
        Wpisująć w pasek adresu przeglądarki adres URL żądanej strony,
        przeglądarka nawiąże połączenie z serwerem WWW stojącym za żądaną
        stroną i pobierze ją. Połączenia między przeglądarką a serwerem strony
        zostaną zrealizowane za pomocą protokołu HTTP lub jego szyfrowanej
        wersji jaką jest HTTPS. Jak pamiętamy protokoły określają sposób
        komunikacji. W przypadku protokołu HTTP, jest on dosyć prosty więc
        warto sobie go opisać. 
      </p>
      <ol>
        <li>Po wpisaniu adresu do przeglądarki np. 
          <em>https://www.cisco.com/index.html</em> zostanie on zinterpretowany
          i podzielony na konkretne sekcje określające: protokoł
          (<em>https</em>), nazwę hosta, który udostępnia tą witrynę
          (<em>www.cisco.com</em>) oraz żądany pliki (<em>index.html</em>).
        </li>
        <li>Na drugim etapie przeglądarka wysła do hosta żądanie wskazanego w 
          adresie pliku.  Wcześniej określając adres IP poprzez wykorzystanie
          protokołu DNS.
          Tego typu żądanie określa się mianem żądania <strong>GET</strong>. 
          W ten sposób sesja protokołu HTTP zostaje rozpoczęta.
        </li>
        <li>W odpowiedzi serwer wysła żądaną stronę. W tym momencie możemy
          uznać sesję HTTP uznać za zakończoną.</li>
        <li>Przeglądarką interpretuje otrzymaną stronę i wyświetla wynik
          użytkownikowi.</li>
      </ol>
      <p>
        W drugim kroku wspomniano, że żądanie strony można określić jako
        <em>GET</em>, <em>GET</em> jest jednym z faktycznych komunikatów
        protokołu HTTP. Jest on używany w momencie gdy klient chce pobrać zasób
        z serwera, wówczas taki zasób jest mu udostępniany po przez wysłanie
        go do klienta. Po za klasycznym <em>GET</em>-em mamy do dyspozycji
        komunikat typu <strong>POST</strong>, jego zadaniem jest wysłanie
        osobnych danych na serwer lub do aplikacji, na przykład za pomocą
        formularza na stronie. Innym rodzajem komuniktów jest 
        <strong>PUT</strong>, które zadaniem jest przysłanie plików na serwer
        WWW.
      </p>
      <p>
        Obecnie poza sieciami lokalnymi, nie spotkamy transmisji z użyciem
        protokołu HTTP, ale przy użyciu protkołu HTTPS - bezpieczniejszej
        wersji. Oczywiście mogą zdarzyć się wyjątki, gdzie takie strony jak
        np. ta, kompletnie nie potrzebują HTTPS
      </p>
      <p>
        Nieco innym rodzajem transmisji jest korzystanie z poczty
        elektronicznej. W dużym skrócie, przy poczcie elektronicznej
        wykorzystywane są trzy protokoły, jeden dla wysyłania oraz dwa do
        odbierania poczty. Obecnie nikt nie korzysta z gołych protokółów,
        choć w przypadku poczty jest jak najbardziej możliwe, to na co dzień
        wykorzystuje się programy pocztowe, będące klientami a ich zadaniem
        jest ułatwienie użytkownikowi korzystanie z poczty elektronicznej.
        Uruchamiając taki program, to jeśli posiadamy konfigurację konta
        pocztowego, to z serwera zostanie pobrana poczta ponieważ program
        połączy się albo z <strong>IMAP</strong>-em po porcie TCP/993
        dla transmisji szyfrowanej lub po porcie TCP/143 dla transmisji
        nieszyfrowanej lub też z protokołem <strong>POP3</strong> po porcie
        TCP/995 dla transmisji szyfrowanej oraz TCP/110 dla transmisji
        nieszyfrowanej. Rożnica w tych protokołach polega na tym, że
        protokół POP3 pobiera zawartość naszej skrzynki na serwerze, bez
        pozostawienia jej kopii na nim (chociaż w ustawieniach mozna wymuść,
        aby kopia pozostała na serwerze), z kolei działanie protokołu IMAP
        opiera się na synchronizacji, do klienta trafia ją szczątkowe
        informacje o poczcie na serwerze, w momencie gdy użytkownik kliknie w
        wiadomość zostanie ona pobrana z serwera i wyświetlona.
      </p>
      <p>
        Inaczej jest w przypadku gdy chcemy wysłać wiadomość. W momencie gdy 
        użytkownik
        zdecyduje się na kliknięcie przycisku wyśli zostanie on połączony z
        z serwerem <strong>SMTP</strong> TCP/465 dla transmisji szyfrowanej
        oraz TCP/25 dla transmisji nieszyfrowanej, wskazanym w konfiguracji
        konta. Wiadomość zostanie przekazana do serwera wraz ze wszystkimi
        danymi takimi jak odbiorca czy temat. Na podstawie odbiorcy nasz
        serwer SMTP prześle wiadomość do <strong>odpowiedniego dla odbiorcy
        serwera SMTP</strong>, z tam tąd odbiorca pobierze ją za pomocą jednego
        z wyżej opisanych protokołów.
      </p>
      <h2 id="1.15.4.ipaddressingservices">1.15.4. Usługi adresacji IP</h2>
      <p>
        W obecnych czasach ciężko było by się poruszać po Internecie, przy
        użyciu adresów IP. Dlatego też wynaleziono specjalny rodzaj usługi,
        jaką jest <strong>DNS</strong>. Zadaniem tego protokołu jest
        rozwiązywanie nazw domenowych na adresy IP, DNS wykorzystuje tutaj
        transmisję UDP po porcie 53. Serwery DNS przechowują dane w postaci
        rekordów, rekordy te mają określony typ. Tak więc, rekordy typu:
      </p>
      <ul>
        <li><strong>A</strong> - adres IPv4</li>
        <li><strong>NS</strong> - adres IP serwera autorytatywnego
          (serwera obsługjącego tą domenę) dla domeny</li>
        <li><strong>AAAA</strong> - adres IPv6</li>
        <li><strong>MX</strong> - rekord wskazujący na serwer pocztowy.</li>
      </ul>
      <p>
        System DNS używa tych samych formatów wiadomości między serwerami
        (uwaga, serwery DNS wymieniają informacje wykorzystując transmisję TCP
        na porcie 53, a UDP jak w przypadku wymiany informacji z klientami).
        Ten format zawiera takie informacje jak kolejno:
      </p>
      <ol>
        <li><strong>Zapytanie</strong> - zapytanie do serwera DNS</li>
        <li><strong>Odpowiedź</strong> - opowiedź od serwera DNS</li>
        <li><strong>Autorytatywność</strong> - wskazanie serwera 
          autorytatywnego dla zapytania.</li>
        <li><strong>Dodatkowe</strong> - przechowuje dodatkowe informacje</li>
      </ol>
      <p>
        Klient szukając adresu IP dla nazwy domenowej hosta na początku odpyta
        serwer DNS, który ma ustawiony w swoim systemie. Jeśli nie będzie on
        posiadać odpowiedzi, to wówczas rozpocznie się odpytywanie
        hierarchiczne.
      </p>
      <p>
        Otóż system DNS ma budowę hierarchiczną i cała hierarchia jest zapisana
        w adresie URL strony. Za przykład weźmy naszą wcześniejszą witrynę jaką
        jest <em>www.cisco.com</em>. Jeśli odczytamy ją od prawej do lewej,
        wówczas będziemy mieć rozeznanie w hierarchi DNS. W tym przypadku
        najważniejszą domeną jest <em>.com</em> i serwer tej domeny zawiera
        adres serwera DNS dla subdomeny <em>cisco</em>, a ten z kolei zawiera
        adres hosta <em>www</em>. Tak własnie wygląda rozwiązywanie nazw, gdy
        nasz najbliżej położony DNS, nie posiada odpowiedzi na zadane mu
        pytanie. Warto dodać, że serwery trzymają taką odpowiedź
        (nieautorytatywną, hosta z innej domeny) w pamięci podręcznej, wrazie
        gdyby inny z hostów w sieci pytał o tego hosta.
      </p>
      <p>
        Pomocnym narzędziem, które pozwoli nam odpytać system DNS jest
        polecenie <strong>nslookup</strong>. Polecenie to pozwala na
        <strong>odpytanie serwera DNS z pominięciem pamięci podręcznej
        urządzenia</strong>. Dostępne jest ono w każdym system operacyjnym.
      </p>
      <p>
        Kolejnym przykładem protokołu, który pracuje wraz z adresacją IP jest
        <strong>DHCP</strong>. Jego zadaniem jest automatyczna konfiguracja
        interfejsów sieciowych hostów. Przypisanie im adresów IP oraz
        pozostałych parametrów pozwalających na komunikację w sieci.
        Konfiguracja hosta wykonana przez serwer DHCP uznawana jest za
        dynamiczną z racji tego, że może się zmienić, po określonym czasie.
        W sieci z włączonym DHCP uzyskamy
        <strong>dzierżawę</strong> (adresy IP z serwera DHCP uzyskuje się na
        konkretny, zapisany w konfiguracji serwera czas) adres IP z
        <strong>puli</strong>
        (zakresu adresów, przydzielonych do tego zadania). W wielu sieciach
        stosuje się mieszane podejście do konfiguracji adresów IP, niektóre
        urządzenia takie jak serwery czy urządzenia pośredniczące w
        komunikacji sieciowej, np. przełączniki posiadają statycznie (ręcznie)
        skonfigurowane adresy IP. Można równiez statycznie skonfigurować adresy
        urządzeń wykorzystując DHCP (rezerwacje adresów).
      </p>
      <p>
        W przypadku adresów IPv6, również może działać serwer DHCP. Z tą
        różnicą, że nie konfiguruje on adresu bramy domyślnej, ten parametr
        jest pobierany z komunikatów <em>Router Advertisement</em>
        rozgłaszanych przez router.
      </p>
      <p>
        Wymiana komunikatów między nowymi hostami w sieci serwerem DHCP wygląda
        następująco: 
      </p>
      <ul>
        <li>Kiedy host z ustawioną automatyczną konfiguracją chce skonfigurować
          swój interfejs wysyła pakiet <em>broadcast</em> na port 67 
          zawierający komunikat <em>DHCPDISCOVER</em></li>
        <li>Serwer DHCP odpowiada na oferując dzierżawę klientowi, komunikat
          <em>DHCPOFFER</em>.</li>
        <li>Klient akceptuje ofertę serwera wysyłając do serwera żądanie
          <em>DHCPREQUEST</em></li>
        <li>Jeśli oferta serwera jest jeszcze aktualna serwer odsyła
          <em>DHCPACK</em>, wówczas cały proces można uznać za zakończony.</li>
        <li>Jeśli natomiast oferta dzierżawy nie jest juz aktualna serwer
          wysyła do klienta komunikat <em>DHCPNACK</em>, w tym przypadku
          cała procedurę należy powtórzy i ponownie rozpocząć od poszukiwania
          serwera DHCP.</li>
      </ul>
      <p>
        Dla IPv6 proces wygląd podobnie, różnicą są nazwy komunikatów. W DHCPv6
        mamy <em>SOLICIT</em>, <em>ADVERTISE</em>, <em>INFORMATION REQUEST</em>
        oraz <em>REPLY</em>.
      </p>
      <h3 id=="1.15.4.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/15.4.8-lab---observe-dns-resolution_pl-PL.pdf">Obserwacja procesu odwzorowania nazw DNS</a>
      </p>
      <h2 id="1.15.5.filesharing">1.15.5. Usługi współdzielenia plików</h2>
      <p>
        Jednym z protokołów, które możemy wykorzystać do współdzielenia plików
        jest protokół FTP. FTP jako jedna z nielicznych usług posiada dwa
        porty TCP/21 oraz TCP/20. Pierwszy z nich służy do nawiązania
        nawiązania połączenia z serwerem i przesyłania do niego poleceń
        protokoł FTP. Jeśli zdecydujemy się na wysłanie lub pobranie danych z
        serwera, wówczas pomiędzy naszymi komputerami zostanie otwarte nowe
        połączenie na portcie TCP/20. Warto pamiętać o tym, że w przypadku
        protokołu FTP możliwe jest przesyłanie danych w obu kierunkach. Klient
        może pobierać dane lub ładowanie je na serwer.
      </p>
      <p>
        Innym protokołem jaki możemy wykorzystać udostępniania plików jest
        protokół SMB (<em>Server Message Block</em>), działanie tego protokołu
        opiera się na żądaniach i odpowiedziach. Trzema głównymi funkcjami
        komunikatów SMB jest:
      </p>
      <ul>
        <li>Rozpoczenie oraz zerwanie sesji i autentykacja</li>
        <li>Kontrola plików i drukarek</li>
        <li>Pozwolenie na wysyłanie komunikatów do innych urządzeń (sic)</li>
      </ul>
      <p>
        W przeciwieństwie do protokołu FTP połączenie SMB jest długoterminowe,
        a użytkownicy mogą korzystać z zasobów udostępnianych przez SMB, jakby
        były ich lokalnymi zasobami.
      </p>
      <h2 id="ch15summary">Podsumowanie</h2>
      <p>
        Ten rozdział związany był z warstwą aplikacji. Poznaliśmy definicje
        oraz funkcje warstw prezentacji oraz sesji modelu OSI. Dowiedzieliśmy
        się w jaki sposób funkcjonują najważniejsze protokoły wykorzystywane
        zarówno w sieciach lokalnych jak i w internecie.
      </p>
      <h1 id="1.16.networksecurityfundamentals">1.16. Wprowadzenie do bezpieczeństwa sięci</h1>
      <p>
        Jak możemy sobie zdawać sprawę lub też nie zadaniem sieci w ujęciu
        teleinformatycznym jest umożliwienie komunikacji między jednym a drugim
        węzłem tej sieci. A jak wszystko na świecie, każdy kij ma dwa końce,
        przez co posiadanie możliwości komunikacji, może mieć negatyny wpływ
        na nasze urządzenia, poufne dane a co za tym idzie na nas samych.
        Oczywiście możemy kontragrumentować tę tezę przedstawiając przypadek
        połączeń między zaufanymi węzłami, jednak i one mogą w wyniku
        zaniedbań, ludzkiej omylności lub też celowego działania mogą zostać
        wykorzystane przeciwko nam, nasze zaufanie tylko ułatwi to zadanie.
        W tym rozdziale spróbujemy zapoznać się z rodzajami zagrożeń z jakimi
        możemy się spotkać.
      </p>
      <h2 id="1.16.1.threatsandvulns">1.16.1. Zagrożenia i podatności.</h2>
      <p>
        Zagrozenia mogą wynikać z wielu aspektów. Atakujący mogą wykorzystywać
        podatności w oprogramowaniu czy sprzęcie, jednak nie
        wszystkie ich działania są tak wyrafinowane. Często udaję się odgadnąć
        czyjeś dane logwania. Osoby wykorzystujące luki w oprogramowaniu lub
        w jaki kolwiek sposób będące w stanie zmodyfikować oprogramowanie aby
        uzyskać dostęp do systemu są nazwywane w nomenklaturze Cisco 
        <strong>podmiotem zagrożenia</strong>.
      </p>
      <p>
        Można natomiast określić cztery rodzaje zagrożeń na jakie mogą być
        narażeni użytkownicy sieci w momencie, gdy podmiot zagrożenia uzyska
        do niej dostęp:
      </p>
      <ul>
        <li>Kradzież informacji</li>
        <li>Utrada danych, bądź ich zmiana</li>
        <li>Kradzież tożsamości</li>
        <li>Przerwanie dostępu do usług</li>
      </ul>
      <p>
        <strong>Podatnością</strong> możemy nazwać słaby punkt czy to w
        urządzeniu czy też w oprogramowaniu. Podaności na uzyskanie
        nieautoryzowanego dostępu może posiadać każde urządzeń, które
        podłączamy do sieci. Podaności można uprządkować bazując na genezie jej
        powstania (pominiemy podatności związane, z błędami lub 
        niedociągnięciami programistycznymi, chociaż pierwsze dwa rodzaje w
        niższych wartstwach też je obejmują):
      </p>
      <ul>
        <li><strong>podatność technologiczna</strong> - wynika ze słabości
          samych protokół sieciowych, systemów operacyjnych czy oprogramowania
          (firmware-u) urządzeń sieciowych.</li>
        <li><strong>podatność konfiguracyjna</strong> - wynika z zaniedbań
          podczas wdrażania urządzeń sieciowych lub usług. Opiera się na
          przykład na domyślnych konfiguracjach, nie zmienionych domyślnych
          hasłach dostępu (w przypadku urządzeń sieciowych), ale także na złym
          zarządaniu użytkownikami.</li>
        <li><strong>podaności polityki bezpieczeństwa</strong> - wynikające
          z braku lub niejednoznacności zasad bezpieczeństwa przyjętych 
          w organizacji. Mogą również wynikać z lokalnego prawa, czy też braku
          jasno określonych działań podczas awarii.<li>
      </ul>
      <p>
        Inna bardzo często pomijaną kwestią związaną z bezpieczeństwem sieci,
        jest <strong>bezpieczeństwo fizyczne</strong> zarówno serwerownii 
        jak i pomieszczeń
        biurowych, w których może być przeprowadzany krytyczny dla organizacji
        proces technologiczny lub przetważane są istotne dane. Nie mniej
        jednak tutaj raczej skupimy się na tzw. czynnikach środowiskowych
      </p>
      <p>
        Możemy określić cztery klasy zagrożeń fizycznych, które np. mogą
        prowadzić do zagrożenia przerwania dostępności usług.
      </p>
      <ul>
        <li><strong>zagrożenia sprzętowe</strong> - uszkodzenia serwerów i
          sprzętu sieciowego.</li>
        <li><strong>zagrożenia środowiskowe</strong> - praca urządzeń poza
          zakresem ich temperatur oraz w pomieszczeniach o niewłaściwej
          wilgotności powietrza.</li>
        <li><strong>zagrożenia elektryczne</strong> - zniki zasilania lub
          niewłaściwe parametry fizczne energii elektrycznej, którą są zasilane
          urządzenia.</li>
        <li><strong>zagrożenia konserwacyjne</strong> - brak cześci zamiennych,
          nieumiejętnie przezprowadzone prace serwisowe, złej jakości
          okablowanie oraz niejednoznacze opisy w szafach krosowniczych oraz
          w punktach dystrybucyjnych.</li>
      </ul>
      <h2 id="1.16.2.networkattacks">1.16.2. Ataki sieciowe</h2>
      <p>
        Najczęściej zadaniem <strong>ataku sieciowego</strong> jest uzyskanie
        nieautoryzowanego dostepu do określonego i chronionego zasobu. Można
        wróżnić kilka podstawowych rodzajów ataków sieciowych, które mogą
        wpasowywać się w zagrożenia opisane na początku tego rozdziału.
      </p>
      <ul>
        <li><strong>złośliwe oprogramowanie</strong> - oprogramowanie lub
          fragment kodu, którego celem jest wykonanie dowolnej niepożądanej
          przez nas czynności na komputerze. Wśród nich możemy wyróżnić:
          <ul>
            <li><strong>wirusy</strong> - złośliwy samodzielny program lub
              fragment innego programu. Na skutek nie uwagi użytkownika może
              infekować wiele komputerów, do infekcji wirusem potrzebne jest
              działanie użytkownika, np. uruchomienie zainfekowanego programu.
            </li>
            <li><strong>robaki</strong> - rodzaj wirusa, który nie wymaga
              działania użytkownika do infekcji. Robaki często wykorzystują
              znane podatności w systemach operacyjnych, usługach lub innych
              programach i replikują się na skompromitowanych hostach.</li>
            <li><strong>konie trojańskie</strong> - złośliwe oprogramowanie
              podszywające się pod przydatne programy.</li>
          </ul>
        </li>
        <li><strong>rozpoznanie</strong> - samo w sobie rozpoznanie nie jest
          atakiem, a jego fazą przygotowawczą, chociaż i w tej fazie można
          użyć narzędzi, który przy wysokim poziomie bezpieczeństwa w
          organizacji mogą wywołąć alarm. Do rozpoznania można również
          wykorzystać dane publicznie dostępne w Internecie. Takie jak np.
          adresację IP sieci publicznej wykorzystywanej w organizacji.</li>
        <li><strong>ataki dostępowe</strong> - ataki dostępowe polegają już
          głównie na eksploatacji podatności, ale jak również takie czynności
          jak odgadywanie czy łamanie haseł oraz próba przechwycenia danych
          logowania. Możemy wyróżnić cztery typy takich ataków:
          <ul>
            <li><strong>ataki na hasła</strong> - mogą obejmować odgadywanie,
              łamanie ale jak i również przechwytywanie ciągów znaków w jakich
              zaszyfrowane są hasła (tzw. hash hasła), które poźniej mogą
              zostać złamane.</li>
            <li><strong>Wykorzystanie zaufania</strong> - podmiot zagrożenia
              może wykorzystywać nieautoryzowane uprawnienia w celu zwiększenia
              dostępu do systemu, możliwe przejmując kontrolę nad celem.(sic)
            </li>
            <li><strong>Przekierowanie portów</strong> - podmiot zagrożenia
              wykorzystuje przejęty host A, łącząc się z nim przez SSH
              (port TCP/22), następnie ze względu na to, że host a jest
              uprawniony do połączenia z hostem B przez Telnet (port TCP/23)
              napastnik to wykorzystuje (sic).</li>
            <li><strong>atak Man-in-the-middle</strong> - napastnik znajduje
              gdzieś miedzy na drodze między jednym wezłem a drugim. Zbiera on
              dane wymieniane między tymi hostami, może również je zmieniać
              lub wpływać na ruch między nimi.</li>
          </ul>
        </li>
        <li><strong>ataki odmowy usługi</strong> - atak ten polega nawiązaniu
          tak dużej ilości połączeń z daną aplikacją na serwerze, że ten nie
          będzie w stanie obsłużyć kolejnych, przez co usługa staje się
          niedostępna dla innych osób. Ataki DoS są wyjątkowo łatwe w
          implementacji więc mogą być stosowane przez mniej doświadczone
          osoby. Odmianą ataków odmowy usługi (DoS) są <strong>ataki DDoS</strong>,
          które różnią się rozproszeniem podmiotu zagrożenia na wiele hostów.
          Do ataków DDoS wykorzystuję się sieci przyjętych lub zainfekowanych
          złośliwym oprogramowaniem hostów tzw. <strong>botnet</strong>. Do
          kontroli takiej sieci wykorzystuje się inne przejęte hosty
          tzw. <strong>Command&Control</strong> przez co napastnik może
          pozostać nieuchwytny.</li>
      </ul>
      <h3 id="1.16.2.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/16.2.6-lab---research-network-security-threats_pl-PL.pdf">Badanie zagrożeń bezpieczeństwa sieci</a>
      </p> 
      <h2 id="1.16.3.networksecuring">1.16.3. Zabezpieczanie sieci</h2>
      <p>
        Aby zabezpieczyć się przez opisanymi w tym rozdziale atakami należy
        wdrożyć odpowiednie rozwiązania. Przed zakupem nie wiadomo jak
        drogiego komercyjnego systemu warto na początku zadbać o
        zabezpieczenie takich urządzeń jak serwery, routery, switche oraz
        urządzenia użytkowników końcowych. Po zabezpieczeniu tych urządzeń
        można wówczas pomyśleć o wdrożeniu systemów IPS/IDS,
        systemów AAA (sic) czy filtrów treści. Warto dodać, aby przy wyborze
        rozwiązań jednym z kluczowych składników było to aby jedne rozwiązania
        mogły współpracować z pozostałymi elementami systemu bezpieczeństwa,
        ale
        także rozwiązanimi już obecnie działającymi w naszej sieci.
      </p>
      <p>
        Jedną z tych podstawowych czynności, jakie możemy podjąć czyniąc naszą
        infrastrukturę teleinformatyczną bardziej bezpieczną jest zapewnienie
        kopii zapasowej istotnych dla organizacji danych. Podczas rozważań
        na temat kopii zapasowej należy wziąć pod uwagę cztery poniższe
        zagadnienia: 
      </p>
      <ul>
        <li><strong>Częstotliwość</strong> - Kopie zapasowe należy wykonywać w
              regularnych odstępach czasu
              najlepiej codziennie. Częstotliwość kopii zapasowych powinna być
              ujęta w polityce bezpieczeństwa.
              Wykonywanie pełnych kopii może być czasochonne więc warto
              wydzielić czas (powiedzmy raz w tygodniu) na wykonanie takiej
              kopii, w pozostałe dni można robić kopie tylko tych plików,
              które były ostatnio modyfikowane.</li>
        <li><strong>Przechowywanie kopii</strong> - jeśli organizacja obejmuje
          kilka budynków to warto trzymać te kopie poza budynkiem, w którym
          te dane są przetwarzane. Możemy tutaj posłużyć się zasadą 3-2-1 - 
          minimum 3 kopie, w 2 różnych miejscach, a 1 poza główną siedzibą.
          Jeśli organizacja jest na tyle duża, to może wynająć przestrzeń
          dyskową w lokalnym centrum danych.</li>
        <li><strong>Bezpieczeństwo kopii</strong> - Każda kopia powinna być
          chroniona hasłem. Tak samo jak procedura jej przywrócenia.</li>
        <li><strong>Integralność kopii</strong> - Należy dbać o poprawność
          i integralność kopii zapasowej. Raz na jakiś czas należy jedną
          losową kopię przywrócić w środowisku testowym.</li>
      </ul>
      <p>
        Jedną z najprostszych rzeczy jakie możemy wykonać na urządzeniach
        użytkowników jest sprawdzenie poprawności konfiguracji automatycznych
        aktulizacji. I jeśli brakuje poprawek w systemach to należy je
        niezwłocznie zainstalować. To samo tyczy się programów antywirusowych,
        program ten może aktualizować swoje bazy kilka razy w ciągu dnia.
        Dystrybucje Linuksa posiadają takie rozwiązania jak
        <em>unattended-upgrades</em>, które instalują automatycznie pakiety
        z takich gałezi repozytoriów jak <em>security</em>.
      </p>
      <p>
        Istotne podczas zabepieczenia sieci jest również kontrola użytkownika
        który ma z niej korzystać i nie musi się to tyczyć wyłącznie komputerów
        ale jeśli jest taka możliwość to i urządzeń sieciowych i taką usługą
        może być <strong>serwer AAA</strong>. Najprostszą a zarazem jedną z 
        lepszych jest
        protokół LDAP, zarówno jak i w wolnej implementacji Samba AD czy
        własnościowej MS Windows Active Directory. 
      </p>
      <p>
        Urządzenie, które powinno znaleźć się w każdej sieci to 
        <strong>zapora</strong>. Jej zadaniem jest monitorowanie i zarządzanie
        ruchem na podstawie zdefiniowanych przez administratora reguł. Zapory
        mogą tworzyć specjalny rodzaj sieci tzw. 
        <strong>strefę zdemilitaryzowaną - DMZ</strong>. W tej sieci
        umiesczane są serwery usług, które mają być osiągalne z poziomu sieci
        Internet. DMZ-ty najczęsciej konfigurowane są w taki sposób, że
        użytkownicy sieci lokalnych w organizacji mogą się łączyć bezproblemu
        z tymi serwerami, jednak te same serwery nie są w stanie inicjować
        połączeń z hostami w sieciach lokalnych. Kiedy jeden z tych serwerów
        zostanie przejęty przez napastnika, zostanie on ograniczony tylko do
        DMZ (oczywiście, nie należy takiego włamania lekceważyć) i nie będzie
        w stanie narobić wiecej szkód w innych sieciach. Same zapory
        najczęsciej są skonfigurowane tak aby blokować cały ruch pochodzący
        z Internetu, chyba, że przekierowano porty. Wówczas ruch na tych
        wybranych portach jest możliwy. Dostępnych jest kilka różnych metod
        filtrowania ruchu przez zapory o to cztery z nich
      </p>
      <ul>
        <li><strong>Filtrowanie pakietów</strong> - filtowanie pakietów na
          podstawie adresów IP czy adresów MAC.</li>
        <li><strong>Filtrowanie aplikacji</strong> - filtrowanie pakietów na
          podstawie numerów protów.</li>
        <li><strong>Filtrowanie treści</strong> - filtrowanie całych domen oraz
          pojedynczych stron na podstawie ogólnodostępnych list w internetcie.
        </li>
        <li><strong>Inspekcja stanów pakietów (SPI)</strong> - metoda
          filtrowania pakietów, która pozwala odfiltrować pakiety TCP z
          ustawionymi odpowiednimi flagami, przez co możliwa jest tylko
          przepuszczenie odpowiedzi z Internetu na połączenia, których źródłem
          są hosty wewnętrzne. SPI ma możliwość wykrywania i blokowania
          róznych ataków w tym ataków DoS.</li>
      </ul> 
      <h2 id="1.16.4.devicescurity">1.16.4. Bezpieczeństwo urządzeń</h2>
      <p>
        Poza serwera i urządzeniam użytkowników końcowych, do zabezpieczenia
        pozostały nam jeszcze urządzenia sieciowe takie jak routery czy
        switche. 
      </p>
      <p>
        W przypadku routerów Cisco mamy dyspozycji narzędzie
        <em>Cisco AutoSecure</em>, które pomoże nam przeprowadzić proces
        zabezpieczania urządzenia. Mimo to czynności podejmowane w celu
        zabezpieczenia urządzenia sieciowego nie za bardzo różnią się od
        procesu zabepieczania np. serwera, zaraz po zainstalowaniu na nim
        systemu operacyjnego.
      </p>
      <p>
        Oczywiście na tym poziomie do uzyskania dostępu do urządzenia
        sieciowego będziemy wykorzystywać hasła. Warto zatem mieć na uwadzę
        kilka reguł dotyczących tworzenia bezpiecznych haseł:
      </p>
      <ul>
        <li>Dobre hasło powinno mieć co najmniej 8 znaków, ale lepsze hasła
            zawierają 10 i więcej.</li>
        <li>Hasło powinno być dość złożone, tzn. składać losowych małych,
            wielkich liter, cyfr, znaków specjalnych a jeszcze lepiej jakby
            zawierało spację.</li>
        <li>Najlepiej jakby hasło nie zawiera żadnych informacji, które można
            znaleźć na nasz temat np. daty urodzenia czy imienia naszego
            zwierzaka. Najlepiej omijać także powtórzenia lub często
            stosowane słowa.</li>
        <li>Jeśli korzystamy z całych słów, to warto je urozmaicić wprowadzając
            błędy, podobnie brzmiące litery lub zamias konkretnych liter
            przypominające je cyfry.</li>
        <li>Hasła należy zmieniać co jakiś czas, np. co 6 miesięcy.</li>
        <li>Nie należy nigdzie zapisywać haseł.</li>
      </ul>
      <p>
        Jeśli chcemy stosować spację na urządzenia Cisco, to musimy podać ją
        jako drugi lub kolejny znak. IOS ignoruje początkowe spacje.
      </p>
      <p>
        Teraz znając zasady dotyczące haseł możemy wygenerować hasła i
        następnie ustawić je na naszych urządzeniach do dając przy tym kilka
        dodatkowych ustawień zapisanych poniżej (pierwsze trzy opcje,
        ustawiamy w trybie konfiguracji globalnej):
      </p>
      <ul>
        <li>Szyfrowanie haseł:
          <code class="code-inline">service password-encryption</code>
        </li>
        <li>Minimalna długość hasła:
          <code class="code-inline">security passwords min-length 10</code>
        </li>
        <li>Blokada na N sekund po X prób logowania w ciągu Y sekund:
          <code class="code-inline">login block-for N attempts X within Y</code>
        </li>
        <li>Automatyczne wyjście z trybu privileged EXEC po określonym czasie:
          (uwaga, tę opcję zmieniamy w konfiguracji linii)
          <code class="code-inline">exec-timeout min. sek.</code>
        </li>
      </ul>
      <p>
        Teraz wiedząc jak bezpiczenie ustawić dostęp oparty o hasło do
        urządzeń sieciowych Cisco. Możemy uruchomić bezpiecznych dostęp
        przez SSH. Poniżej polecenie, które trzeba wykonać
        (cztery pierwsze opcje są wykonywane w trybie konfiguracji globalnej):
      </p>
      <ul>
        <li>Ustawienie unikalnej nazwy hosta:
          <code class="code-inline">hostname r1</code>
        </li>
        <li>Ustawienie nazwy domenowej:
          <code class="code-inline">ip domain name example.com</code>
        </li>
        <li>Wygenerowanie kluczy RSA dla SSH o długości X bitów:
          <code class="code-inline">crypto key generate rsa general-keys modulus X</code>
        </li>
        <li>Utworzenie użytkownika w lokalnej bazie użytkowników urządzenia:
          <code class="code-inline">username xf0r3m secret 5up3r74jn3Has|_0</code>
        </li>
        <li>Włączenie uwierzytelniania przy użyciu lokalnej bazy:
          (uwaga, tę opcję wprowadzamy w trybie konfiguracji linii vty)
          <code class="code-inline">login local</code>
        </li>
        <li>Włączenie SSH dla zdalnych połączeń:
          (uwaga, tę opcję wprowadzamy w trybie konfiguracji linii vty)
          <code class="code-inline">transport input ssh</code>
        </li>
      </ul>
      <p>
        Po zapewnieniu prawidłowego dostępu zdalnego możemy wykonać ostatnią
        czynność jaką jest wyłączenie zbędnych usług. Tutaj istotna może być
        wersja IOS, jaką posiadamy na swoich urządzeniach. W starszych
        urządzeniach (z przed IOS-XE) możemy podejrzeć listę otwartych portów
        za pomocą polecenia:<br />
        <code class="code-inline">show control-plane host open-ports</code>.
        Natomiast w nowszych wersjach (od IOS-XE) używa się nieco krótszego
        polecenia:<br />
        <code class="code-inline">show ip ports all</code>
        Te polecenia wydajemy w trybie uprzywilejowanym EXEC bez konfiguracji.
        Chcąc wyłączyć usługę powiedzmy http, musimy przejść do trybu
        konfiguracji globalnej i następnie wydać polecenie:<br />
        <code class="code-inline">no ip http server</code>
      </p>
      <h3 id="1.16.4.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.4.6-packet-tracer---configure-secure-passwords-and-ssh_pl-PL.pdf">Konfiguracja bezpiecznych haseł i SSH - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.4.6-packet-tracer---configure-secure-passwords-and-ssh_pl-PL.pka">Konfiguracja bezpiecznych haseł i SSH - zadanie</a>
      </p>
      <h3 id="1.16.4.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/16.4.7-lab---configure-network-devices-with-ssh_pl-PL.pdf">Konfiguracja urządzeń sieciowych za pomocą SSH</a>
      </p>
      <h2 id="ch16summary">Podsumowanie</h2>
      <p>
        W tym module zapoznaliśmy się z podstawami sieci. Poznaliśmy zagrożenia
        oraz genezę wielu podatności. Dowiedzieliśmy się jakie są podstawowe
        ataki oraz jak niewiele potrzeba, aby utrudnić atakującym dostęp do
        naszych urządzeń. Na koniec podnieślismy poziom bezpieczeństwa haseł
        na naszych urządzeniach Cisco oraz w bezpieczny sposób uruchomiliśmy
        usługę SSH. Poniżej znajdują się ćwiczenia praktyczne do wykonania w
        programie Cisco Packet Tracer oraz bardziej zaawansowane zadanie w
        postaci laboratorium. 
      </p>
      <h3 id="1.16.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.5.1-packet-tracer---secure-network-devices_pl-PL.pdf">Zabezpieczanie urządzeń sieciowych - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.5.1-packet-tracer---secure-network-devices_pl-PL.pka">Zabezpieczanie urządzeń sieciowych - zadanie</a>
      </p>
      <h3 id="1.16.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/16.5.2-lab---secure-network-devices_pl-PL.pdf">Zabezpieczenie urządzeń sieciowych</a>
      </p>
      <h1 id="1.17.buildingasmallnetwork">1.17. Budowanie małej sieci</h1>
      <p>
        Ostatni rozdział pierwszego modułu kursu, ma skłonić nas do refleksji
        na temat: Co gdyby trzeba było zbudować taką małą sieć? Oczywiście
        pierwsze pytanie jak się nasuwa: <em>co to znaczy mała?</em> czasmi
        może okazać się, że do budowy takiej sieci wystarczy router klasy SOHO
        i dostęp do ISP. A czasami do małej sieci może zaliczać się nawet
        kilka segmentów. 
      </p>
      <h2 id="1.17.1.desingasmallnetwork">1.17.1. Projektowanie małej sieci</h2>
      <p>
        W tym podrozdziale zastanowimy się nad kilkoma aspektami, które trzeba
        rozważyć podczas projektowania małej sieci.
      </p>
      <p>
        Pierwszym z nich jest <strong>topologia</strong>. Małe sieci są
        zazwyczaj proste, zasięgiem obejmują jeden poziom lub jeden nieduży
        budynek. Takie sieci posiadają zazwyczaj jedno połączenie do ISP,
        mogą posiadać łącze zapasowe w postaci połączenia np. z siecią
        komórkową, jednak przełączanie między tymi sieciami może odbywać się
        w sposób ręczny. Takie sieci są zarządzane zazwyczaj przez osoby
        z zewnątrz, lub co może być rzadkością posiadają oni własnego
        administratora IT. 
      </p>
      <p>
        Jeśli już decydujemy się, że będziemy budować sieć komputerową to
        należy zastanowić się nad doborem urządzeń. Istnieją cztery
        postawowe czynnki, które należy wziąć pod uwagę podczas wybierania
        urządzeń dla naszej sieci:
      </p>
      <ul>
        <li>Koszt urządzenia</li>
        <li>Wydajność oraz typ portów/interfejsów</li>
        <li>Możliwości rozbudowy</li>
        <li>Funkcje i usługi oferowane przez firmware</li>
      </ul>
      <p>
        Tworząc projekt sieci, nie można zapomnieć o adresacji IP i jej
        ewentualnym podziale. Jeśli już będziemy dzielić adresy klasy
        prywatnej na mniejsze podsieci, to warto oprzeć się na klasach
        urządzeń i ich połączeniach. Dla przykładu powinniśmy wydzielić
        osobną klasę dla serwerów i urządzeń sieciowych, ale tutaj ciekawą 
        opcją
        mogą być komputery użytkowników, często są to laptopy, którą mogą mieć 
        więcej niż jedno połączenie. Warto mieć to
        na uwadze zastanawiając się nad podziałem adresów IP.
      </p>
      <p>
        Jeśli opieramy swoją sieć o połączenia kablowe, raczej będzie to kabel
        UTP, ponieważ jest prostszy w obsłudze, to warto pomyśleć o 
        nadmiarowości połaczeń, na przykład na jednego użytkownika przypadały
        dwa gniazda sieciowe. Warto również mieć w zanadrzu zapasowy 
        przełącznik oraz router.
      </p>
      <p>
        Ostatnim zagadnieniem jest zarządzanie ruchem, w przypadku małej sieci
        nie jest to może priorytetowy temat do czasu, aż ktoś nie zacznie nam
        wysycać łącza np. pobierając duży plik z Internetu. Wówczas najlepszym
        sposobem jest inwestycja w przełączniki, którymi możemy zarządzać, tam
        jest możliwość nie tyle wdrożenia QoS oczywiście jest to możliwe co
        przypisania konkretnej przepustowości dla danego hosta w obu kierunkach.
      </p>
      <p>
        Nie mniej jednak przełączniki i routery powinny być skonfigurowane w
        taki sposób aby priorytetyzować ruch zgodnie z zapotrzebowaniem 
        wykorzystywanych w tej sieci protokół, tak więc dobrze skonfigurowane
        sieci posiadają wdrożony QoS (<em>Quality of Service</em> -
        priorytetyzację ruchu) (sic).
      </p>
      <h2 id="1.17.2.smallnetworkprotocols">1.17.2. Protokoły wykorzystywane w małych sieciach</h2>
      <p>
        Najczęsciej wykorzystywanymi protokołami w małej sieci będzie na pewno
        protokoł HTTP lub HTTPS w bezpieczniejszej wersji. Protokoły pocztowe
        również mogą mieć miejsce, jak i protokoły SMB w celu wymiany plików
        z innymi współużytkownikami sieci. Do administracji mogą być
        wykorzystywane protokoły HTTPS jak i SSH. Protokoły takie DHCP oraz
        DNS muszą działać inaczej sieć może być trudna w użytkowaniu.
        Najczęściej są one zapewniane przez takie urządzenia jak routery,
        przynajmniej te klasy SOHO. Warto wspomnieć, że wiele usług może
        wykorzystywać jeden ten sam serwer fizyczny.
      </p>
      <p>
        Inna kwestią jest wdrożenie w sieci usług głosowych oraz video czatu.
        Tutaj musimy się zastanowić czy nasza infrastruktura jest w obsłużyć
        tego typu ruch oraz musimy wybrać jedną z trzech technologii:
      </p>
      <ul>
        <li><strong>VoIP</strong> - tańszy odpowiednik dla telefonów IP, 
          oczywiście kosztem jakoś jak i funkcjonalności.</li>
        <li><strong>Telefony IP</strong> - wymagają serwerów do sygnalizacji
          oraz utrzymywania połączeń.</li>
        <li><strong>Aplikacje czasu rzeczywistego</strong> - wszelkie aplikacje
          dla videoczatów oraz komunikatory głosowe. Wymagają one małych
          opóźnień w sieci oraz wdrożenia mechanizmów QoS. Niektóre z nich
          mogą być oparte o protokoły <em>Real-Time Transport Protocol</em>
          (RTP) oraz <em>Real-Time Transport Control Protocol</em> (RTCP).</li> 
      </ul>
      <h2 id="1.17.3.smallnetworkexpanding">1.17.3. Rozbudowa małej sieci</h2>
      <p>
        Może zajść taka potrzeba, że małą sieć będzie trzeba rozbudować i
        warto mieć to na uwadze już podczas projektowania małej sieci. Po co?
        Aby wyrobić w na przykład nawyk prowadzenia
        <strong>dokumentacji sieci</strong> zarówno topologii logicznej, jak
        i fizycznej, w której można znaleźć opisy połączeń oraz lokalizacje
        gdzie można znaleźć router i przełączniki. Jak i prowadzenie 
        <strong>spisu posiadanych urządzeń</strong>, które działają w sieci.
      </p>
      <p>
        Dośc istotnym czynnikiem związanym z rozbudową sieci jest to jakim
        <strong>budżetem</strong> dysponujemy, być może będziemy musieli z
        czegoś zrezygnować lub wręcz przeciwnie będzimy mogli wdrożyć więcej
        przydatnych innowacji. Ważnym czynnikiem determinującym rozbudowę
        może być <strong>analiza ruchu</strong> przy użyciu ogólnodostępnych
        narzędzi takicj jak np. <em>Wireshark</em>. 
      </p>
      <p>
        Aby analiza ruchu była miarodajna musi zostać przeprowadzona w
        odpowiedni sposób. Poniżej znajduje się kilka reguł w jaki sposób
        zbierać pakiety, tak aby dały jak najlepszy obraz tego co się dzieje
        w sieci podczas normalnego dnia pracy, kiedy użytkownicy korzystają 
        z jej zasobów:
      </p>
      <ul>
        <li>Zbieranie pakietów powinno odbywać podczas najwiekszego piku z
          użycia jej zasobów. Powiedzmy gdzieś godzinę od rozpoczęcia pracy
          w dniu kiedy większość pracowników jest obecna w siedzibie firmy.
        </li>
        <li>Przeprowadzenie zbierania pakietów powinno odbyć się w różnych
          segmentach sieci, tak aby móc uchwycić ruch specyficzny dla tego
          segmentu.</li>
        <li>Analiza ruchu powinna być oceniana na podstawie ruchu wychodzącego,
          przychodzącego oraz rodzaju przesyłanego ruchu (np. wykorzystywanych
          protokołów).</li>
      </ul>
      <p>
        Analiza dokonana przy zastosowaniu powyższych metod może dać nam dobrą
        wskazówkę w jaki sposób tym ruchem możemy zarządzać.
      </p>
      <h2 id="1.17.4.verifyconectivity">1.17.4. Weryfikacja łączności</h2>
      <p>
        Weryfikację łączności możemy stosować w momencie budowania sieci, kiedy
        jesteśmy pewni, że wszelakie okablowanie jest podłączone. Weryfikacja
        łączności na wczesnym etapie budowy sieci, może przyspieszyć
        uruchomienie jej w całości.
      </p>
      <p>
        Najprostszym narzędziem jest polecenie <strong>ping</strong>, opiera
        się ono protokół ICMP i jest dostępne w wiekszości systemów
        operacyjnych podłączonych do sieci. W przypadku systemów Cisco IOS,
        również jest ono dostępne ma ono nieco inną formę odpowiedzi niż
        standardowe narzędzia znane z dystrybucji Linuksa czy systemów MS
        Windows. Wysyłane jest komuników i na każde z nich możemy otrzymać
        albo kropkę (<strong>.</strong>) w przypadku braku odpowiedzi lub
        też wykrzyknik (<strong>!</strong>) jeśli taka odpowiedź zostanie
        otrzymana. Możemy rownież uzyskać dużą literę <strong>U</strong>,
        która oznacza, że sieć hosta, do którego wysłaliśmy to zapytanie jest
        nie osiągalna (równoznaczne z <em>destination unreachable</em>).
        Polecenie <em>ping</em> jest uruchamiane z adresem docelowego hosta
        jako pierwszym argumentem. W przypadku IOS jest tak samo, ale jeśli
        uruchomimy to polecenie bez argumentu, to wówczas przejdzie ono
        do trybu rozszerzenego, w którym to będziemy mogli skonfigurować
        więcej parameterów poza samym podaniem adresu docelowego, np. źródłowy
        interfejs.
      </p>
      <p>
        Innym poleceniem które może być przydatne podczas weryfikacji
        łączności w IOS jest <strong>traceroute</strong>, nazwa ta obowiązuje
        również w Uniksach, w przypadku systemu MS Windows jest 
        <em>tracert</em>. Zadaniem tego polecenia jest przeanalizowanie trasy
        do hosta docelowego. Narzędzia te mogą posłużyć do analizy czy wina
        w braku łączności z Internetem leży po stronie naszej konfiguracji czy
        naszego usługodawcy.
      </p>
      <p>
        Jeśli korzystamy z powyższych poleceń na zwykłym PC-cie, to warto
        pamiętać, że te polecenia posiadają komunikaty pomocy nie zależnie
        od systemu. W Uniksach dodatkowo istnieje nieco bardziej obszerny plik
        pomocy tzw. <em>strona podręcznika</em>.
      </p>
      <h2 id="1.17.5.displaynetconfigcommands">1.17.5. Polecenia wyświetlania konfiguracji sieciowej</h2>
      <p>
        Podczas budowania małej sieci, gdziej pod koniec prac nad nią przyjdzie
        nam zacząć podłączać do niej hosty, wówczas możemy potrzebować sposóbów
        na sprawdzenie ich konfiguracji sieciowej.
      </p>
      <p>
        Najczęsciej podłączanym przez nas hostem będzie MS Windows 10 i w
        ustawieniach karty sieciowej w aplecie "Centrum udostępniania i sieci"
        możemy sprawdzić parametry konfiguracji sieciowej takie jak adres IP,
        maska, adres bramy czy adresy serwerów DNS. Możemy również wyświetlić
        te informacje w wierszu polecenia, za pomoca polecenia
        <strong>ipconfig</strong>. Polecenie posiada kilka przydatnych
        opcji takich jak:
      </p>
      <ul>
        <li><strong>/all</strong> - wyświetla bardziej szczegółowe informacje</li>
        <li><strong>/release</strong>,<strong>/renew</strong> - zwolnienie
          używanego adresu IP oraz ponowna prośba o przydzielenie adresu IP.</li>
        <li><strong>/displaydns</strong> - wyświetlenie wpisów w pamięci
          podręcznej systemowego DNS.</li>
      </ul>
      <p>
        Może tak się zdarzyć, że chcąc wdrożyć pewne usługi w sieci organizacji
        będziemy mieć stycznosć z dystrybucjami Linuksa. Tutaj do wyświetlenia
        adresu IP używa się polecenia <strong>ip a</strong> do wyświetlania
        bramy wykorzystujemy polecenie <strong>ip route</strong> adres bramy
        będzie wówczas widnieć we wpisie dla sieci (pierwsza kolumna)
        <em>0.0.0.0</em>. Natomiast adresy serwerów DNS możemy zobaczyć,
        poprzez wyświetlenie zawartości pliku <em>/etc/resolv.conf</em>.
      </p>
      <p>
        W systemach MacOS na komputerach firmy Apple, listę dostępnych
        interfejsów możemy wyświetlić w terminalu za pomocą polecenia
        <strong>networksetup -listallnetworkservices</strong>. Po ustaleniu
        interfejsu wydajemy polecenie
        <strong>networksetup -getinfo <em>nazwa interfejsu</em></strong>.
      </p>
      <p>
        Innym przydatnym narzędziem może być sprawdzenie 
        <strong>tablicy ARP</strong>. Tablica
        ARP ma to do siebie, że komputer w sieci nie odpowiada na <em>ping</em>,
        ponieważ może być tak skonfigurowany za pomocą pakietu programu
        antywirusowego, aby nie odpowiadał na te żądania. To jeśli adres IP
        hosta ma dowiązany MAC w naszej tablicy ARP, to znaczy, że jest on
        poprawnie skonfigurowany tylko nie odpowiada na <em>ping</em>. Tablicę
        ARP możemy wyświetlić za pomoca polecenia <strong>arp -a</strong> w
        przypadku systemów MS Windows, w przypadku dystrybucji Linuksa
        jest <strong>ip neighbor</strong>. Tablice ARP możemy wyczyścić
        w systemach MS Windows za pomocą polecenia
        <strong>netsh interface ip delete arpcache</strong>. To polecenie
        może wymagać uprawnień administratora.
      </p>
      <p>
        W systemie Cisco IOS ze względu, że są to urządzenia sieciowe, mamy
        do dyspozycji kilka różnych poleceń poniżej (są one dostępne w
        trybie uprzywilejowanym EXEC):
      </p>
      <ul>
        <li><strong>show running-config</strong> - wyświetla obecnie używaną
          konfigurację oraz ustawienia.</li>
        <li><strong>show interface</strong> - wyświetla status interfejsów
          oraz ewentualne komunikaty o błędach.</li>
        <li><strong>show ip interface</strong> - wyświetla informacje dla
          z warstwy 3 dla interfejsu.</li>
        <li><strong>show arp</strong> - wyświetla tablice arp urządzenia.</li>
        <li><strong>show ip route</strong> - wyświetla tablice routing
          urządzenia.</li>
        <li><strong>show protocols</strong> - wyświetla listę dostępnych
          protokołów warstwy 3.</li>
        <li><strong>show version</strong> - zwraca informacje o pamięci
          urządzenia, dostępnych interfejsach oraz licencji.</li>
      </ul>
      <p>
        Innym wartym uwagi narzędziem jest protokół Cisco <strong>CDP</strong>,
        z jego pomocą możemy z identyfikować inne urządzenia Cisco podłączone
        do tego, na którym wydajemy polecenia tego protokołu. Ten protokół jest
        nieroutowalny, tak więc zobaczymy urządzenia zajdujące się w tej samej
        domenie rozgłoszeniowej. Aby sprawdzić z jakie są inne urządzenia
        Cisco w naszej sieci należy wydać polecnie:
        <code class="code-inline">show cdp neighbors</code> lub
        <code class="code-inline">show cdp neighbors detail</code>.
      </p>
      <p>
        W przypadku polecenia
        <code class="code-inline">show ip interface</code> możemy dodać na
        końcu jeszcze słowo kluczowe <strong>brief</strong> aby uzyskać więcej
        informacji.
      </p>
      <h3 id="1.17.5.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.5.9-packet-tracer---interpret-show-command-output_pl-PL.pdf">Interpretacja wyjścia polecenia show - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.5.9-packet-tracer---interpret-show-command-output_pl-PL.pka">Interpretacja wyjścia polecenia show - zadanie</a>
      </p>
      <h2 id="1.17.6.troubleshootingmethodologies">1.17.6. Metodologia rozwiązywania problemów</h2>
      <p>
        Czasami może tak się zdarzyć, że coś nie będzie działać lub coś
        przestanie działać. Naszym zadaniem jest znalezienie usterki oraz
        jej usunięcie. Czasami nie jest takie proste jakby się mogło wydawać,
        i niektóre problemy mogą być bardziej lub mniej złożone, wiadome jest,
        że ile jest usterek to tyle samo może być sposób na ich usunięcie.
        Poniżej jednak znajduje się lista kroków, które wprowadzają nieco
        organizacji w metodologię rozwiązywania problemów i to nie tylko
        sieciowych.
      </p>
      <ol>
        <li><strong>Zidentyfikuj problem</strong> - Tutaj możemy użyć wszelkich
          możliwych środków, które mogą przybliżyć nas do natury problemu.
          Istotna może być rozmowa z innymi użytkownikami.</li>
        <li><strong>Określenie możliwych przyczyn problemu</strong> - po
          zidentyfikowaniu problemu, powinniśmy ustalić możliwe przyczyny jego
          powstania, co mogło i kiedy się stać, że ten problem wystąpił.</li>
        <li><strong>Spróbuj potwierdzić swoje ustalenia</strong> - tutaj musimy
          ustalić, które z naszych przypuszeń powstania problemów, jest tą
          prawdziwą genezą usterki.</li>
        <li><strong>Określ plan rozwiązania problemu oraz ustal właściwe
          rozwiązanie</strong> - skoro wiemy co spowodowało usterkę, to należy
          opracować rozwiązanie problemu oraz sposób w jaki to zrobimy, aby
          jeszcze nie pogorszyć sytuacji.</li>
        <li><strong>Zweryfikuj poprawność wprowadzonych rozwiązań, wdróż
          rozwiązania zardcze</strong> - Po hipotetycznym pozbyciu się
          problemu musimy ustalić, czy naszy rozwiązanie działa i czy
          przypadkiem nie ma wpływu na inne rozwiązania. Warto również
          skonfrontować się z przyczyną problemu i wdrożyć odpowiednie środki
          zaracze, aby problem się nie powtarzał.</li>
        <li><strong>Udokumentuj to</strong> - warto prowadzić bazę wiedzy lub
          chociaż notatki, wrazi gdyby podobny problem wystąpił gdzieś
          indziej.</li>
      </ol>
      <p>
        Oczywiście zdaję sobie sprawę z tego, że nie zawsze uda się trzymać
        tego planu. Warto jednak moim zdaniem wziąć sobie do serca ostatnią
        zasadę. Właśnie dzięki niej ta strona w ogole powstała i dlatego też
        dalej ją prowadzę.
      </p>
      <p>
        Drugą sprawą jest fakt, że pewnych problemów nie uda nam się rozwiązać,
        z różnych przyczyn. Warto mieć to na uwadze i poinformować o tym
        przełożonych oraz innych pracowników. Oszczędzimy sobie setek pytań 
        o...
      </p>
      <p>
        Cisco IOS posiada narzędzie, które może pomóc nam znaleźć problem lub
        jego przyczynę, jednak należy traktować go jako ostatateczność. Do
        dyspozycji mamy polecenie <strong>debug</strong>. Wprowadza ono
        urządzenie w stan debugowania, przez co każdy pakiet jest analizowany,
        a rozszerzeone komunikaty diagnostyczne o przychodzących pakietach jakie
        zostały
        przetworzone przez te urządzenie mogą pojawiać się na konsoli. Jednak
        warto mieć to na uwadzę, że uruchomienie tego trybu spowoduje znaczne
        spowolnienie transmisji przez nie, ponieważ przez większość czasu
        będzie ono zajęte analizowaniem pakietów. Tryb debugowania włączamy
        polecenie <code class="code-inline">debug</code> w trybie
        uprzywilejowanym EXEC, a wyłączamy za pomocą polecenia
        <code class="code-inline">no debug</code>.
      </p>
      <h2 id="1.17.7.troubleshootingscenarios">1.17.7. Rozwiązania typowych problemów</h2>
      <p>
        Poniżej znalazły się rozwiązania typowych problemów jakie możemy
        napotkać nie tylko konfigurując małą sieć. Takie problemy mogą się
        pojawić zawsze gdy konfigurujemy czy urządzenie końcowe czy też
        urządzenie pośredniczące w komunikacji sieciowej.
      </p>
      <p>
        Pierwszym z nich mogą być problemy z autonegocjacją interfejsów
        sieciowych oraz błedne przyjęte uzgodnie odnośnie kierunku transmisji
        (<em>duplex</em>). Tutaj najczęściej przyczną może być fatalnej jakość
        medium transmisjne, np. kabel UTP, źle zarobione końcówki RJ-45 lub
        uszkodzone urządzenie, które chcemy podłączyć. Urządzenia Cisco mogą
        wyłączać również porty, jeśli dochodzi na do błędów.
      </p>
      <p>
        Następnym przypadkiem jest przypadek błędnej adresacji interfejsów.
        Do rozwiązania tego problemu możemy wykorzystać poznane wcześniej
        polecenia jak <code class="code-inline">show ip interface brief</code>.
      </p>
      <p>
        Problem z brakiem łączności z internetem można powiązać z brakiem
        lub błędnym przypisaniem adresu bramy do hosta. Za pomocą poleceń
        <code class="code-inline">ipconfig</code> lub
        <code class="code-inline">show ip route</code> w przypadku urządzeń
        sieciowych. Warto również sprawdzić czy serwer DHCP dobrze ustawia
        ten parametr.
      <p>
      <p>
        Problemy z rozwiązywaniem nazw również mogą powodować błędnę adresy
        w konfiguracji hostów. Tak jak we wcześniejszym przypadku serwer DHCP
        może przydzielć adres serwera DNS, który już nie istnieje. W przypadku
        systemów MS Windows, aby sprawdzić adres serwera DNS należy wydać
        polecenie <code class="code-inline">ipconfig /all</code> do dyspozycji
        mamy również takie narzędzie jak
        <code class="code-inline">nslookup</code>
      </p>
      <h3 id="1.17.7.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/17.7.6-lab---troubleshoot-connectivity-issues_pl-PL.pdf">Rozwiązywanie problemów z łącznością</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/laby/17.8.1-lab---design-and-build-a-small-network_pl-PL.pdf">Projektowanie i budowanie sieci małej firmy</a>
      </p>
      <h3 id="1.17.7.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.7.7-packet-tracer---troubleshoot-connectivity-issues_pl-PL.pdf">Rozwiązywanie problemów z łącznością - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.7.7-packet-tracer---troubleshoot-connectivity-issues_pl-PL.pka">Rozwiązywanie problemów z łącznością_- zadanie</a>
        
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.3-packet-tracer---troubleshooting-challenge_pl-PL.pdf">Wyzwanie dotyczące rozwiązywania problemów - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.3-packet-tracer---troubleshooting-challenge_pl-PL.pka">Wyzwanie dotyczące rozwiązywania problemów - zadanie</a>
      </p>
      <h2 id="ch17summary">Podsumowanie</h2>
      <p>
        W tym rodziale dowiedzieliśmy się w jaki sposób projektować małe sieci
        czy weryfikować konfigurację sieciową hostów znajdujących się nie
        tylko w małych sieciach, ale podłączonych do sieci ogólnie. Poznalismy
        również zasady jakim należy kierować się podczas chęci rozbudowy
        takiej małej sieci. Na koniec usystematyzowaliśmy swoją wiedze na
        temat metodologi rozwiązywania problemów oraz poznaliśmy scenariusze
        typowych błędów jakie możemy napotkać. Ten rozdział zamyka pierwszy
        moduł kursu Cisco CCNA. <!--Poniżej znajduje się 50 pytań teoretycznych,
        których można spodziewać się na egzaminie z pierwszego modułu.-->
      </p>
      <h3 id="1.17.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.2-packet-tracer---skills-integration-challenge_pl-PL.pdf">Zadanie podsumowujące umiejętności - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.2-packet-tracer---skills-integration-challenge_pl-PL.pka">Zadanie podsumowujące umiejętności - zadanie</a>
      </p>
      <!--<h1 id="1.examplepartialexam">Przykładowy egzamin cząstkowy - Tematy: 16-17</h1>
      <p>
        <a href="Cisco_-_CCNA_-_ITN_-_przykladowy_egzamin_czastkowy.html">Cisco - CCNA - ITN - przykładowy egzamin_czastkowy.html</a>
      </p>-->
      <h1 id="1.mockexam">1. Egzamin próbny - ITN</h1>
      <p>
        Przed przystąpieniem do egzaminu finałowego, będziemy mogli a wręcz
        musieli podejść do egzaminu próbnego. Egzamin próbny jest bardzo
        podobny do egzaminy finalnego, gdyż jego zakres obejmuje całość
        przerobionego na kursie materiału. Wynikiem tego egzaminu jest wartość
        procentowa poprawnych odpowiedzi ze wszystkich 55 pytań, poniżej
        rozpisane zostały również wartości procentowe ze wszystkich działów,
        dzięki temu kursant wie co musi sobie powtórzyć przed przystąpieniem
        do <em>finala</em>. Egzamin ten niepodlega ocenie, to znaczy że nie
        dostaniemy informacji zwrotnej, z pokazanymi odpowiedziami, na które
        odpowiedziliśmy źle z zaznaczonymi odpowiedziami oraz jego wyniki nie
        jest brany do kryterium ukończenia modułu.
      </p>
      <!--<p>
        <a href="Cisco_-_CCNA_-_ITN_-_przykladowy_egzamin_probny.html">Cisco - CCNA - ITN - przykładowy egzamin próbny</a>
      </p>-->
      <h1 id="1.finalexam">1. Egzamin finałowy - ITN</h1>
      <p>
        Egzamin finałowy może składać z testu, w którym do wyboru możemy
        mieć pytania jednokrotnego lub wielokrotnego wyboru wymagające 2 lub 3
        odpowiedzi. Mogą również zdarzyć się zadania polegające na
        przyporządkowaniu słów kluczowych, terminów, a nawet adresów do
        poszczególnych pól, jakimś opisem. W przypadku adresów możemy mieć
        rownież polecenie, gdzie będzie trzeba przyporządkować do adresów
        opis w stylu adres <em>broadcast</em> podsieci 1. Mając podane adres
        np. hostów oraz maskę w notacji CIDR.
      </p>
      <p>
        W pytanich wielkrotnego wyboru, istnieje pewnego rodzaju haczyk. Czy
        też zmuszenie zdającego do posiadania podstaw do zazanaczenia takich
        odpowiedzi (w postaci wiedzy), że jeśli zaznaczym jedną dobrą
        odpowiedź i jedną złą, to wówczas za całe to zadanie mamy 0 punktów.
        Dlatego też, jeśli niemamy pewności do pozostałych, a jednej jesteśmy
        pewnii to lepiej zaznaczyć tę jedną i iść dalej. Taki mechanizm, żeby
        nie zgadywać.
      </p>
      <p>
        Ilość pytań na egzaminie wacha się między 50, a 60 pytaniami, na
        zdanie których mamy 2 i pół godziny. W tym egzaminie nie uświadczymy
        zadań praktycznych wykonywanych w Packet Tracerze, tak jak to miało
        miejsce w egzaminach cząstkowych.
      </p>
      <p>
        Czy są szanse na zdanie egzaminu, bazując tylko na tym materiale?
        Jeśli czytelnik, nie posiada żadnej wiedzy na temat sieci to raczej
        w to wątpie. Materiał ten ma za zadanie jedynie odświeżenie wiedzy
        zdobytej podczas kursu. Coś na zasadzie intensywnego powtórzenia.
        Problemy również mogą mieć osoby posiadające już jakąś wiedzę oraz
        doświadczenie w praktycznej konfiguracji sieci. Wymaga się od
        zdającego, zmiany sposobu myślenia na rozumienia pewnych pojęć tak
        jak sobie życzy tego Cisco. Z jednej strony przygotowuje nas to pracy
        z konkretną technologią, jednak nie od dziś wiadomo, że raczej z
        jedną nie będziemy zawsze i wszędzie pracować. Dlatego też zapoznanie
        się z materiałamia dostępnymi na kursie może być wymagane.
      </p>
      <h1 id="1.ptsa">1. Finałowy egzamin praktyczny - Packet Tracer - ITN</h1>
      <p>
        Egzamin praktyczy jest podobny do ćwiczeń, które wykonywaliśmy 
        w trakcie tego kursu. W przypadku tegorocznego zdania możemy dostać
        podłączoną już sieć która wymaga konfiguracji. Ale zanim do niej
        przejdziemy dostajemy na początku zadanie z określeniem odpowiedniej
        adresacji. Na przykład 192.168.1.0/24 i wytyczne mówią, aby podzielić
        tę pulę na podsieci o X ilości hostów przy jak najmniejszym zmarnowaniu
        adresów. Np. 30 hostów w sieci i dla sieci powiedzmy <em>administracji</em>
        mamy wykorzystać 4-tą podsieć z tego podziału. Następnie od 5-tej
        podsieci, podzielić pule na jescze mniejsze zawierające 12 czy 14
        hostów i dla sieci <em>działu IT</em> wykorzystać podsieć 7 czy 8.
        Z tych podsieci mogą być również wytyczne, aby wykorzystać ostatni
        adres dla interfejsu routera, następny, przedostatni dla przełącznika
        i na koniec dowolne, inne dla hostów w tej sieci. Tak wygląda
        adresacja IPv4 w przypadku IPv6, adresy są już przypisane w tabeli.
        Tabele należy uzupełnić, aby nie pogubić się podczas konfiguracji
        urządzeń. Nie uzupełniamy jej w zadaniu. Nie ma takiej możliwości.
        Tak się kończy krok pierwszy.
      </p>
      <p>
        Krok drugi polega na skonfigurowaniu interfejsów hostów w sieciach.
        Dla IPv4 oraz IPv6. Nie jest on zbyt wymagających.
      </p>
      <p>
        Krok trzeci polega na konfiguracji routera. Do konfiguracji możemy
        mieć:
      </p>
      <ul>
        <li>Nazwę urządzenia.</li>
        <li>Zabezpieczenie dostępu do urządzenia. Tj. zabezpieczenie połączeń
          konsolowych, zabezpieczenie trybu uprzywilejowanyego EXEC za
          pomocą szyfrowanego hasła. Hasła musimy wymyśleć sami. Tutaj należy
          pamiętać o banerze. Warto zabepieczyć je jak najbardziej się da,
          najwyżej, niektóre z poleceń nie zostaną ocenione.</li>
        <li>Zaszyfowanie haseł.</li>
        <li>Ustawienie min. 10 znaków dla nowych haseł.</li>
        <li>Konfigurację dostępu przez SSH, przy czym może być informacja
          sugerująca utworzenie klucza RSA, ale nie będzie informacji na
          temat domeny. Bez tej informacji klucz nie zostanie utworzym. W tym
          celu musimy wykonać wszystkie kroki, aby to polecenie wykonało się
          poprawnie.</li>
        <li>Utworzyć użytkownika w lokalnej bazie na podstawie informacji
          podanych w zadaniu oraz użycie lokalnej bazy uwierzytelniania
          użytkowników łączycych się po SSH.</li>
        <li>Na koniec należy skonfigurować interfejsy w raz z ich podniesiem
          oraz z opisem <em>description</em>. Tutaj ważne może być włącznie
          routingu dla IPv6.</li>
      </ul>
      <p>
        Krok czwarty (prawdopodobnie ostatni) polega na konfiguracji
        przełącznika i przy czym ta konfiguracja jest banalna. Musimy
        skonfigurować go do dostępu za pomocą protokołu Telnet z możliwością
        połączenia się z nim z innej sieci (tej drugiej) niż lokalna.
      </p>
      <p>
        Ostatnią rzeczą jaką należy wykonać przed złożeniem zadania, jest
        sprawdzenia łączności oraz czy faktycznie mamy możliwość połączenia
        się z przełącznikiem po przez Telnet z sieci zdalnej.
      </p>
      <p>
        W trakcie egzaminy praktycznego mamy zablokowane zakładki CLI lub
        w ogóle dostęp do urządzeń z poziomu osobnego okna Packet Tracera.
        Z urządzeniami należy łączyć się poprzez dowolnego hosta korzystając
        z połaczenia szeregowego oraz terminala. Egzamin ten oraz jego
        scenariusz jest tylko i wyłącznie w języku angielskim.
      </p>
      <h1>Koniec modułu pierwszego</h1>
      <h2>Słowem wstępu</h2>
      <p>
        Po zdaniu egzaminu, kontunuacja w takiej jak dotychczas formie kursu
        Cisco CCNA, zawisła na włosku. No i z niego spadła. Z grupy wypisały 3
        osoby, a rektor wydziału nie pozwolił wykładowcy na kontynuację kursu.
        Zostalismy bowiem z jednym modułem...
      </p>
      <p>
        Nie mniej jednak dwa dni poźniej jeden z kolegów z kursu, znalazł kurs
        CISCO CCNA w innym mieście. Taniej, ale jednak trzeba dojechać.
        Pomijając inne aspekty. Kurs będzie kontynuowany, w innym miejscu i ja
        już wiem, że trochę z innym podejściem. Co na minus, ale tutaj liczy
        się dostęp do materiałów oraz możliwość zaliczenia kolejnych semestrów
        (modułów).
      </p>
      <h1 id="2.module2">2. Moduł 2: Podstawy przełaczania, routingu oraz sieci bezprzewodowych - SRWE</h1>
      <p>
        Moduł drugi czyli podstawy przełączania, routingu oraz sieci
        bezprzewodowych. Na tym etapie zapozanymy się z takimi technikami
        sieciowymi jak VLAN-y, agregacja łącza, podstawy łączności
        bezprzewodowej oraz statyczny routing. Tematy te już są bardziej
        zaawansowane niż to co mogliśmy spotkać w poprzednim module. Pierwsze
        dwa tematy będą przypomnieniem sobie kilku zagadnień z poprzedniego
        modułu.
      </p>
      <h1 id="2.1.basicdeviceconfiguration">2.1. Podstawowa konfiguracją urządzenia</h1>
      <p>
        Każde dostaczone urządzenie zawiera już jakąś konfigurację. Bez tego
        nie mogło by działać. Oczywiście ta konfiguracja ma z zadanie
        przygotować urządzenie do pracy i umożliwić dostosowanie go do obecnych
        potrzeb. Przy okazji przypominy sobie część poleceń
        jakie do tej pory poznaliśmy. Rozszerzymy wiedzę zawartą w podstawowej
        konfigurację przełącznika oraz routera o kilka nowych informacji.
      </p> 
      <p>
        Wiekszość urządzeń techniki komputerowej, niezależnie od tego jak
        prymitywne one nie są i jakie realizują zadania, oparto o schemat
        działania ówczesnych komputerów. Podobnie w przypadku przełączników
        firmy Cisco, są one prymitywnymi komputerami zawierającymy duże ilości
        kart sieciowych (mniej więcej).
      </p>
      <p>
        Przełączniki nie posiadają nawet włącznika. Startuje zaraz podaniu
        zasilania. Zamysł takiego projektu przełącznika opiera się na tym, że
        ten sprzęt powinien zostać zasilony i działać do momentu swoje żywota.
      </p>
      <ol>
        <li>Po podłączeniu zasialania przełącznik przeprowadza procedurę
          POST, w której oprócz podstawowych komponentów takich jak CPU czy RAM
          sprawdzany jest także stan systemu plików, w który zawiera system
          operacyjny przełącznika.</li>
        <li>Przełącznik ładuje z pamięci ROM program ładujący 
          (<em>bootloader</em>),
          uruchamiany jest on w momencie pozytywnego przejścia procedury
          POST.</li>
        <li>Program ładujący przy urzyciu procesora przygotowuje pamięc.</li>
        <li><em>Bootloader</em> montuje system plików znajdujący się dysku
          flash w przełączniku.</li>
        <li>Na końcu <em>bootloader</em>, odszukuje na powyższej pamięci obraz
          IOS i
          uruchamamia go i przekazuje mu kontrolę nad urządzeniem.</li>
      </ol>
      <p>
        Jak w przypadku większości komputerów, czy to mniej lub bardziej
        prymitywnych możemy kontrolować ich rozruch, jednym ze sposobów zmiany
        sekewncji startowej urządzenia jest uzycie odpowiednich poleceń
        systemu IOS.
        Polecenie <code class="code-inline">boot system</code> służy do
        ustawienia zmiennej środowiskowej BOOT. Przechowuje ona bowiem ścieżkę
        wskazującą na plik z system operacyjnym w tym wypadku z IOS. Jeśli
        takiej zmiennej będzie brakować w systemie, wówczas program ładujący
        uruchomi pierwszy napotkany plik wykonywalny. Dostęp do zmiennej BOOT
        możemy uzyskać po przez polecenie 
        <code class="code-inline">show boot</code>. Poniżej przykład.
      </p>
<pre class="code-block">
Switch#sh boot
BOOT path-list      : 
Config file         : flash:/config.text
Private Config file : flash:/private-config.text
Enable Break        : no
Manual Boot         : no
HELPER path-list    : 
Auto upgrade        : yes
NVRAM/Config file
      buffer size:   65536
</pre>
      <p>
        Jak wydzimy na powyższym przykładzie, przełączniki domyślnie nie mają
        ustawionego, żadnego pliku z systemem operacyjnym. Korzystają z
        możliwości przeszukiwania pamięci <em>flash</em> i użycia pierwszego
        napotkanego
        pliku wykonywalnego. W celach przezentacji wykorzystałem emulowany
        przełącznik z programu PacketTracer, w przypadku urządzeń fizycznych,
        możemy mieć zdefiniowaną domyślną ścieżkę do pliku z systemem,
        ponieważ na przestrzeni lat działania, w pamięci <em>flash</em> może
        znajdować się kilka, takich plików. Spróbujmy teraz ustawić opisywany
        tutaj parameter i ponownie wyświelimy informację o rozruchu.
      </p>
<pre class="code-block">
Switch#dir flash: 
Directory of flash:/

    1  -rw-     4670455          &lt;no date&gt;  2960-lanbasek9-mz.150-2.SE4.bin
Switch(config)#boot system flash:/2960-lanbasek9-mz.150-2.SE4.bin
Switch#sh boot
BOOT path-list      : flash:/2960-lanbasek9-mz.150-2.SE4.bin
Config file         : flash:/config.text
Private Config file : flash:/private-config.text
Enable Break        : no
Manual Boot         : no
HELPER path-list    : 
Auto upgrade        : yes
NVRAM/Config file
      buffer size:   65536
</pre>
      <p>
        Na początku wyświetliłem zawartość pamięci <em>flash</em>, aby sprawdzić
        dokładną nazwę pliku z obrazem systemu, następnie użyłem polecenia
        <code class="code-inline">boot system</code> jak parametr polecenia
        podałem scieżkę z lokalizacją pliku z system operacyjnym. Na koniec
        ponownie wyświetliłem informacje rozruchowe i w pierwszym wierszu
        widzimy naszą wskazaną ścieżkę.
      </p>
      <p>
        Przełączniki serii <em>Catalist</em> (powszechnie używane modele) firmy
        Cisco, nie posiadają wyświetlaczy, a jedynie zestaw diód nad portami
        oraz diody z lewej strony urządzenia na odrębnym panelu. Na tym panelu
        również znajduje się jedyny przycisk tego urządzenia. Przełącznik tak
        jak już może wspomniałem albo nie, nie posiadają wyłącznika. Cisco
        zakłada, że raz podłączony przełącznik ma działać do momentu, aż się
        nie uszkodzi. Ten nie pozorny zestaw diód, może nam zdradzić
        znacznie więcej informacji, niż inne przełączniki, innych firm również
        wyposażone w diody prezentujące stan oraz aktywność poszczególnych
        portów.
      </p>
      <p>
        Diody w urządzeniach Cisco, mają 5 stanów: wyłączony - dioda się nie
        swieci, zielony stały - dioda swieci się na kolor zielony,
        pomarańczowy stały - dioda swieci się na kolor pomarańczowy, zielony
        migający - dioda miga kolorem zielonymm, pomarańczowy migający - 
        dioda miga kolorem pomarańczowym.
      </p>
      <p>
        Za pomocą przycisku <em>MODE</em>, wybieramy jeden z trybów
        informacyjnych, przezentowany za pomocą diód LED nad portami, sam
        wybrany tryb również jest sygnalizowany za pomocą diód nad przyciskiem
        po lewej stronie urządzenia. Omówimy sobie te diody po kolei:
      </p>
      <ul>
        <li><strong>SYST</strong> - dioda wskazuje na stan zasilania. Jeśli
          dioda jest wyłączona, oznacza to, że urządzenie najzwyczajniej w
          świecie niedziała i nie dochodzi do niego zasilanie. W przypadku
          normalnej pracy dioda świeci na zielono, natomiast jeśli
          przełącznik będzie mieć awarię, wówczas będzie to sygnalizować ta
          dioda w kolorze pomarańczowym.</li>
        <li><strong>RPS</strong> - dioda nadmiarowego zasilania
          (ang. <em>Redundant Power Supply</em>). Dioda wskazuje stan zasilania
          RPS, jeśli jest ona: wyłączona - oznacza to, że RPS jest wyłączony
          lub nie jest podłączony prawidłowo; zielona stała - RPS jest
          podłączony i gotowy do zapewnienia zasilania awaryjnego; zielona miga
           - RPS jest podłączony, ale jest niedostępny, ponieważ zasila
          inne urządzenie; pomarańczowa stała - RPS jest w trybie gotowości lub
          w stanie błędu; pomarańczowa miga - wewnętrzne źródło zasilania 
          uległo awarii, a RPS dostarcza energię.</li>
        <li><strong>STAT</strong> - dioda statusu portu. Ta dioda na panelu,
          zawsze ma kolor zielony stały. Natomiast wybranie tego trybu powoduje
          modyfikację informacji zwracanych przez diody nad portami. Po
          wybraniu tego trybu, diody nad portami będą: wyłączone - port nie ma
          fizycznego połączenia lub został wyłączony przez administratora; 
          zielone stałe - jest połączenie fizyczne (ten stan jest przejściowy
          występuje przez kilka, kilkanaście sekund); zielone migające - 
          połączenie tego portu jest aktywne, wysyła i odbiera dane; migać
          naprzemiennie zielony, pomarańczowy - oznacza to błąd połączenia;
          pomarańczowe stałe - porty zablokowane (ten stan występuje prawie
          zawsze podczas uruchamiania urządzenia przez ok. 30 sek.);
          pomarańczowe migające - porty są zablokowane, aby zapobiec
          możliwej pętli. Tryb ten, często jest domyślny trybem urządzenia.</li>
        <li><strong>DUPLX</strong> - dioda dupleksu portu, gdy ta dioda na
          panelu jest zielona, to wówczas diody nad portami będą wskazywać
          ustawiony tryb dupleksu danego portu. Jeśli dioda nad portem jest:
          wyłączona - oznacza to, że port działa w trybie <em>Half-duplex</em>,
          a jeśli jest zielona - to w trybie <em>Full-duplex</em>.</li>
        <li><strong>SPEED</strong> - dioda prędkości portu. Jeśli ten tryb
          jest włączony, to wówczas diody nad portami mogą być: wyłączone - 
          port działa z prędkością 10Mb/s; zielone stałe - port przesyła dane
          z prędkością 100Mb/s; zielone migają - port przesła dane z prędkością
          1000Mb/s, 1Gb/s.</li>
        <li><strong>PoE</strong> (nie dotyczy wszystkich urządzeń) - dioda
          zasilania przez Ethernet (technologii PoE). W przypadku PoE to dioda
          trybu może być: wyłączona - żaden z portów nie jest zasilany lub
          jest w trybie uszkodzenia; pomarańczowa migająca - że tryb PoE nie
          został wybrany, ale co najmniej jednemy portowi nie dostarczono
          zasilania lub wystąpił błąd PoE. Zielona - tryb PoE został wybrany,
          wówczas diody portów są wyłączone - to oznacza, że PoE jest
          wyłączone; zielone stałe - PoE jest włączone. Migają naprzemiennie
          zielony, pomarańczowy - PoE jest niedostępne, ponieważ
          zapotrzebowanie podłączonego urządzenia przewyższa możliwości
          przełącznika; pomarańczowe migają - PoE jest w stanie awarii;
          pomarańczowe stałe - tryb PoE dla portu został wyłączony.</li>
      </ul>
      <p>
        Z tych trybów i przełączania się między nimi, może wyniknąć dość
        zabawna sytuacja. Otóż podczas przepinania przewodów, możemy omyłkowo
        naciśnąć przycisk <em>MODE</em> i zmienić tryb. W szczególności pod
        <em>STAT</em>-em (domyślnym trybem) jest informacja o dupleksie.
        Patrząc po tem na porty, możemy uznać, że przełacznik się zawiesił.
        Zanim jednak odłączym go od prądu, naciśnijmy przycisk <em>MODE</em>
        kilka razy. Zawieszony przełącznik nie mógł by zmienić trybów.
      </p>
      <p>
        Jednym z celów, dla których uczestniczymy w kursie CCNA jest poznanie
        możliwości wykorzystania sprzętu firmy Cisco, więc jeśli pracujemy na
        sprzęcie, to czasami może zdarzyć się potrzeba <em>przywrócenia go do
        ustawień fabrycznych</em>, przyczym nie wygląda to tak jak w przypadku
        zwykłych urządzeń klasy SOHO. 
      </p>
      <p>
        W pierwszym module na pewno słyszeliśmy, że urządzenia firmy Cisco
        są wyposażone
        w pamięć NVRAM, w której przechowywana jest konfiguracja. Jest to 
        prawdą,
        połowicznie. To stwierdzenie jest prawdziwe w przypadku gdy mówimy
        o routerach. Przełączniki przy najmniej te serii <em>Catalist</em>
        nie mają takich udogodnień jak NVRAM. Tam zastosowano pamięć
        <em>flash</em>, którą mogliśmy się zetknąć podczas omawiania polecenia
        <code class="code-inline">boot system</code>. Tam mimo tego, że do
        kopii konfiguracji wykorzystaliśmy nazwę <em>startup-config</em>, to
        ten rodzaj konfiguracji jest przechowany w pamięci <em>flash</em> pod
        nazwą <em>config.text</em>. I to on będzie celem naszej operacji.
      </p>
      <ol>
        <li>Odłączamy od urządzenia zasilanie, a podłączamy konsole.</li>
        <li>Przytrzymując przycisk <em>MODE</em>, podłączamy zasilanie.
          trzymamy tak długo, aż dioda <em>SYST</em> nie mignie na pomarańczowo.
          Wtedy puszczamy przycisk.</li>
        <li>Na konsoli zostanie wyświetlonych kilka informacji, z możliwymi
          opcjami do wprowadzenia oraz promptem: 
          <code class="code-inline">switch:</code>. Jeśli nie ma opcji to
          wówczas możemy wpisać znak zapytania (<strong>?</strong>) i wtedy
          zostanie nam wyświetlona lista.
<pre class="code-inline">
switch: ?
           ? -- Present list of available commands
        boot -- Load and boot an executable image
      delete -- Delete file(s)
         dir -- List files in directories
  flash_init -- Initialize flash filesystem(s)
        help -- Present list of available commands
      rename -- Rename a file
       reset -- Reset the system
         set -- Set or display environment variables
       unset -- Unset one or more environment variables
</pre>
        </li>
        <li>Tryb edycji wiersza poleceń, w tym przypadku jest bardzo prymitywny
          nie mamy do dyspozycji strzałek czy dopełnienia. Musimy uważnie
          wpisywać polecenia. Zaczniemy od zamontowania systemu plików na
          pamięci <em>flash</em>.
<pre class="code-block">
switch: flash_init
Initializing Flash...
flashfs[0]: 2 files, 0 directories
flashfs[0]: 0 orphaned files, 0 orphaned directories
flashfs[0]: Total bytes: 64016384
flashfs[0]: Bytes used: 4671638
flashfs[0]: Bytes available: 59344746
flashfs[0]: flashfs fsck took 1 seconds.
...done Initializing Flash.
</pre>
        </li>
        <li>Teraz za pomocą polecenia <em>dir</em> i podania mu urządzenia
          w tym przypadku jest pamięć <em>flash</em>, może przejrzeć zawartość
          tej pamięci.
<pre class="code-block">
switch: dir flash:
Directory of flash:/

1    -rw-  4670455   <date>               2960-lanbasek9-mz.150-2.SE4.bin
2    -rw-  1183      <date>               config.text
59344746 bytes available (4671638 bytes used)
</pre>
        </li>
        <li>Teraz w zależności od awarii, albo kasujemy plik 
          <em>config.text</em>, albo ustawiamy zmienną BOOT, aby wybrać
          właściwy obraz systemu operacyjnego.
<pre class="code-block">
switch: delete flash:config.text
Are you sure you want to delete [flash:config.text] (y/n)?y
File "flash:config.text" deleted
</pre>
          W drugim przypadku definiujemy, zmienną BOOT, a jej ustawienie możemy
          zweryfikować za pomocą polecenia <code class="code-inline">set</code>
<pre class="code-block">
switch: BOOT=flash:2960-lanbasek9-mz.150-2.SE4.bin
switch: set
BOOT=flash:2960-lanbasek9-mz.150-2.SE4.bin
</pre>
        </li>
        <li>Po wykonaniu pożądanej czynności może przejść już do uruchomienia
          przełącznika. Za pomocą polecenia
          <code class="code-inline">boot</code>.
<pre class="code-block">
switch: boot
C2960 Boot Loader (C2960-HBOOT-M) Version 12.2(25r)FX, RELEASE SOFTWARE (fc4)
Cisco WS-C2960-24TT (RC32300) processor (revision C0) with 21039K bytes of memory.
2960-24TT starting...
Base ethernet MAC Address: 000D.BDB0.4E5E
Xmodem file system is available.
Initializing Flash...
flashfs[0]: 1 files, 0 directories
flashfs[0]: 0 orphaned files, 0 orphaned directories
flashfs[0]: Total bytes: 64016384
flashfs[0]: Bytes used: 4670455
flashfs[0]: Bytes available: 59345929
flashfs[0]: flashfs fsck took 1 seconds.
...done Initializing Flash.

Boot Sector Filesystem (bs:) installed, fsid: 3
Parameter Block Filesystem (pb:) installed, fsid: 4


Loading "flash:/2960-lanbasek9-mz.150-2.SE4.bin"...
########################################################################## [OK]
</pre>
      </ol>
      <p>
        Uruchamiając przełącznik w trybie opisanym powyżej, przechodzimy do
        czegoś, co można porównać do trybu awaryjnego.
      </p>
      <p>
        Reguła ta nie tyczy się tylko przełączników, ale i większości urządzeń
        firmy Cisco. Te urządzenia nie są skonfigurowane, do zdalnego
        zarządzania. Pierwsza konfiguracja wymaga dostępu fizycznego do
        urządzenia użycia interfejsu konsoli. Jeśli kupujemy nowe urządzenia
        to kabel konsolowy będzię w zestawie. Problemem może okazać dostępność
        portów COM w obecnych komputerach. W przypadku komputerów
        stacjonarnych możemy jeszcze je spotkać, ale w nowych laptopach to
        głównie w seriach tych wzmanianych. Remedium dla tego problemy jest
        za opatrzenie się w adapter USB - RS232, dostępne są one za parę
        złotych na serwiach aukcyjnych czy sklepach internetowych.
      </p>
      <p>
        Bawiąc się przełącznikami w porzednim module, wykorzystwaliśmy domyślny
        VLAN 1, jako SVI. Jednak ze względów bezpieczeństwa nie jest to dobrym
        rozwiązaniem. Dlatego zmienimy trochę koncepcję. Ten podrozdział
        wystarczy sobie przeczytać, ponieważ realizacja przykładu będzie wymagać
        nieco więcej wiedzy, którą poznamy w poźniejszym etapie tego kursu.
        Poniżej znajduje się lista poleceń, która jest już raczej znana:
      </p>
<pre class="code-block">
S1&gt;
S1&gt;enable
S1#configure terminal 
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#interface vlan 99
S1(config-if)#ip address 172.17.99.11 255.255.255.0
S1(config-if)#ipv6 address 2001:db8:acad:99::1/64
S1(config-if)#no shutdown
S1(config-if)#end
S1#copy running-config startup-config
Destination filename [startup-config]? 
Building configuration...
[OK]
</pre>
      <p>
        Uwaga! Aby móc wpisać adres IPv6 przełącznikowi, należy na początek
        skonfigurować w nim IPv6. Nie jest to skomplikowana czynność.
        Wymaga podania jednego polecenia w trybie konfiguracji globalnej oraz
        uruchomienia ponownie urządzenia. Poniższe polecenia przedstawią co
        trzeba zrobić.
      </p>
<pre class="code-block">
S1#
%SYS-5-CONFIG_I: Configured from console by console

S1#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#sdm prefer dual-ipv4-and-ipv6 default
Changes to the running SDM preferences have been stored, but cannot take effect until the next reload.
Use 'show sdm prefer' to see what SDM preference is currently active.
S1(config)#do reload
</pre>
      <p>
        W ostatnim poleceniu użyto polecenia 
        <code class="code-inline">do reload</code>, przerostek
        <code class="code-inline">do</code> pozwala na uruchamianie poleceń
        bez względu na tryb. Oczywiście nie takich specyficznych dla danego
        trybu. Dzięki nie mu możemy uzyskać dostęp do polecenia
        <code class="code-inline">show</code> np. podczas konfigurowania
        interfejsu. Taki <em>pro tip</em>.
      </p>
      <p>
        Jeśli nasz przełącznik będzie znajdować się w innej podsieci to do
        komunikacji z nim wykorzystamy bramę, ale on sam musimy mieć wpisany
        adres bramy. Poniżej znajduje się seria poleceń, służąca konfiguracji
        bramy na urządzeniach Cisco.
      </p>
<pre class="code-inline">
S1#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#ip default-gateway 172.17.99.1
S1(config)#end
S1#
%SYS-5-CONFIG_I: Configured from console by console

S1#copy running-config startup-config
Destination filename [startup-config]? 
Building configuration...
[OK]
</pre>
      <h3 id="2.1.1.lab">Ćwiczenie praktyczne - Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/1.1.7-lab---basic-switch-configuration_pl-PL.pdf">Podstawowa konfiguracja przełącznika</a>
      </p>
      <h2 id="2.1.2.switchportsconfiguration">2.1.2. Konfiguracja portów przełącznika</h2>
      <p>
        Pomimo tego, że portom na przełącznikach, nie ustawia się adresu IP to
        można skonfigurować kilka innych parametrów i to tym się zajmmiemy w 
        w tym podrozdziale.
      </p>
      <p>
        Konfigurację portów rozpoczniemy od skonfigurowania warstwy fizycznej,
        a w niej znajdują się takie pojęcia jak dupleks - rodzaj transmisji
        umożliwiający dwukierunkową transmisję danych, w którym mamy dwie
        możliwości: <strong>full-dupleks</strong> - umożliwiający odbierania i
        nadawanie jednocześnie oraz <em>half-dupleks</em> - umożliwiający
        jedynie nadawanie lub odbieranie. Obecnie nie stosuje się
        pół-dupleksu i urządzenia zazwyczaj działają w trybie pełnego dupleksu.
        Jeśli urządzenie przestawia się w tryb pół-dupleksu, to zazwyczaj
        oznacza to, że ma uszkodzoną kartę sieciową, albo jest naprawdę stare. 
      </p>
      <p>
        Co więcej gigabitowy i 10Gb Ethernet wymagają pełnego dupleksu. W tym
        trybie wyłączony jest obwód detekcji kolizji na karcie sieciowej.
      </p>
      <p>
        Poza dupleksem w warstwie fizycznej występuje jeszcze nominalna
        prędkość z jaką pracuje port - 1Gb/s, 100Mb/s czy 10Mb/s. Te omawaiane
        funkcję są możliwe do ustawienia w trybie konfiguracji interfejsów.
      </p>
<pre class="code-block">
Switch#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#interface FastEthernet 0/1
Switch(config-if)#duplex full
Switch(config-if)#speed 100
Switch(config-if)#end
</pre>
      <p>
        Na szczęście nie musimy tego robić, a wręcz nie powiniśmy. Istnieją
        mechanizmy autonegocjacji tych parameterów, a nie poprawna
        konfiguracja dupleksu, może spowodować problemy z połączeniem między
        przełącznikiem, a urządzeniem.
      </p>
      <p>
        Inną funkcją warstwy fizycznej jest auto-MDIX, czyli automatyczne
        ustalenie potrzebnego rodzaju kabla i wykonanie przeplotu jeśli to
        konieczne już w samym porcie urządzenia. Funkcję możemy wyłączyć
        za pomocą polecenia: <code class="code-inline">mdix auto</code>, w
        trybie konfiguracji interfejsu. Jednak to też jedna z tych domyślnie
        włączonych funkcji w przełącznikach serii 2960 (powszechnie stosowany
        model) oraz 3560 (przełącznik L3) posiadają tę opcję włączoną.
        Natomiast ich starsze odpowiedniki nie posiadają tej funkcjonalności
        wcale, więc tutaj będzie wymagane stosowanie odpowiednich kabli.
      </p>
      <p>
        Poniżej znajduje się lista poleceń wykorzystywana do weryfikacji
        przełącznika:
      </p>
      <ul>
        <li>Wyświetlenie informacji o stanie i konfiguracji interfejsu - 
          <code class="code-inline">S1# show interfaces [id interfejsu]</code></li>
        <li>Wyświetla konfigurację startową - 
          <code class="code-inline">S1# show startup-config</code>.</li>
        <li>Wyświetla bieżącą konfigurację - 
          <code class="code-inline">S1# show running-config</code>.</li>
        <li>Wyświetla informacje o systemie plików pamięci flash - 
          <code class="code-inline">S1# show flash</code></li>
        <li>Wyświetla status sprzętu i oprogramowania - 
          <code class="code-inline">S1# show version</code></li>
        <li>Wyświetla historię wprowadzonych poleceń - 
          <code class="code-inline">S1# show history</code></li>
        <li>Wyświetla informacje związane z adresem IP interfejsu - 
          <code class="code-inline">S1# show ip interface [id interfejsu]</code>
          lub <code class="code-inline">S1# show ipv6 interface [id interfejsu]</code>
        </li>
        <li>Wyświetla tablicę adresów MAC przełącznika - 
          <code class="code-inline">S1# show mac-address-table</code> lub
          <code class="code-inline">S1# show mac address-table</code></li>
      </ul>
      <p>
        Przypomnijmy sobie wyjście polecenia 
        <code class="code-inline">S1# show ip interface brief</code>, ostatnie
        dwie kolumny wkazywały na status portu. Pierwsza kolumn
        <em>Status</em> pokazywała nam status połączenia w warstwie fizycznej
        (1), natomiast druga kolumna <em>Protocol</em>, wskazywała czy
        urządzenia dogadują się na poziomie warstwy łącza danych (2).
        W niektórych przypadkach, możemy spotkać się z takim stanem jak
        <em>up/down</em>, oznacza to, coś jest nie tak w warstwie drugiej.
        Często tego typu przypadki mają miejsce w przypadku łączy szeregowych,
        jednak w jest to najczęsciej związane z nieustawieniem zegara.
        Więcej informacji na ten temat może z wrócić nam polecenie
        <code class="code-inline">show interface [id-interfejsu]</code>
      </p>
<pre class="code-block">
Switch#show interface FastEthernet0/1
FastEthernet0/1 is up, line protocol is up (connected)
  Hardware is Lance, address is 00e0.f9d0.6101 (bia 00e0.f9d0.6101)
 BW 100000 Kbit, DLY 1000 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Keepalive set (10 sec)
  Full-duplex, 100Mb/s
  input flow-control is off, output flow-control is off
  ARP type: ARPA, ARP Timeout 04:00:00
  Last input 00:00:08, output 00:00:05, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/75/0/0 (size/max/drops/flushes); Total output drops: 0
  Queueing strategy: fifo
  Output queue :0/40 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     956 packets input, 193351 bytes, 0 no buffer
     Received 956 broadcasts, 0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort
     0 watchdog, 0 multicast, 0 pause input
     0 input packets with dribble condition detected
     2357 packets output, 263570 bytes, 0 underruns
     0 output errors, 0 collisions, 10 interface resets
     0 babbles, 0 late collision, 0 deferred
     0 lost carrier, 0 no carrier
     0 output buffer failures, 0 output buffers swapped out
</pre>
      <p>
        Pierwsza linia wyjścia polecenia zwraca nam te informacje o których
        mówiłem wcześniej. Port jest w stanie <em>up/up</em>. Jeśli jednak
        byłby w stanie <em>up/down</em>, to warto spojrzeć na informacje w
        licznikach na końcu danych wyjściowych. Mamy tam wiele informacji, np.
        takich o wielkości ramek (<em>runts</em> - za małych,
        <em>giants</em> - za dużych) o błedach w CRC (<em>CRC</em>), poniżej
        znajduje się informacje na temat kolizji (<em>collisions</em>,
        <em>late collisions</em>). Informacje na ten temat mogą być pomocne,
        w diagnozowaniu stanu <em>up/down</em>.
      </p>
      <h2 id="2.1.3.securedremoteaccess">2.1.3. Bezpieczny zdalny dostęp</h2>
      <p>
        Pracując przy administracji sieciami komputerowymi, może zdażyć się
        taka sytuacja, że trzeba będzie skonfigurować urządzenia, do których
        dostęp fizyczny, aby podłączyć się konsolą może być utrudniony lub
        w ogóle niedostępny. Na szczęście urządzenia firmy Cisco zapewniają
        zdalny dostęp swoich urządzeń. To powinniśmy pamiętać z poprzedniego
        modułu.
      </p>
      <p>
        Do wyboru mamy przestarzały <strong>Telnet</strong> (23/TCP), który nie
        zapewnia bezpieczeństwa transmisji, nie szyfruje przesłanych za jego
        pośrednictwem informacji. Raczej nie jest już stosowany.
      </p>
      <p> 
        Inną opcją jest użycie lepszego protokołu, jakim jest 
        <strong>SSH</strong>
        (ang. <em>Secure SHell</em>). SSH wykorzystuje silną krytpografię do
        zabezpieczenia transmisji pomiędzy naszym komputerem, a urządzeniem.
        Jeśli używamy protokołu SSH w wersji 2, szanse na podsłuchanie
        transmisji, są nie mal, że nikłe. SSH wykorzystuje transmisję protokołu
        TCP na porcie 22.
      </p>
      <p>
        Nie wspominałbym gdyby nie to, że nie wszystkie urządzenia posiadają
        obsługę kryptografii - przez co SSH może być dostępne.
        Jak to sprawdzić? Otóż obsługę kryptografii możemy poznać po
        <strong>nazwie pliku z systemem operacyjnym</strong> jeśli w nazwie
        pliku występuje sekwencja <strong>k9</strong> oznacza to, że w wersji
        IOS dla tego urządzenia zaimplementowano kryptografię, a co za tym
        idzie i obsługę SSH. Poniżej przedstawiam listing zawartości pamięci
        <em>flash</em> z urządzeń, które mają możliwość wykorzystać SSH oraz
        takich, w których nie ma takiej możliwości (wg. powyższej zasady).
      </p>
<pre class="code-block">
# Przełącznik Catalyst 2960:
Switch#dir flash:
Directory of flash:/

    1  -rw-     4670455          &lt;no date&gt;  2960-lanbasek9-mz.150-2.SE4.bin

64016384 bytes total (59345929 bytes free)

# Przełącznik Catalist 2950:
Switch#dir flash:
Directory of flash:/

    1  -rw-     3058048          &lt;no date&gt;  c2950-i6q4l2-mz.121-22.EA4.bin

64016384 bytes total (60958336 bytes free)
</pre>
      <p>
        W przypadku pierwszego przełącznika, sekwencja <em>k9</em> znajduje się
        w drugiej części nazwy pliku po ciągu znaku
        <code class="code-inline">lanbase</code>. Inny sposobem na sprawdzenie
        nazwy pliku z IOS jest wydanie polecenia
        <code class="code-inline">show version</code>.
      </p>
      <p>
        Uruchomienie SSH, było w podkoniec zeszłego modułu, ale, żeby ten
        moduł był kompletny, przypmnimy sobie jak się to robi. Na początek
        wydamy sobie polecenie: <code class="code-inline">show ip ssh</code>.
        W przypadku urządzenie ze wsparciem kryptograficznym odpowiedź powinna
        być następująca:
      </p>
<pre class="code-block">
Switch#show ip ssh
SSH Disabled - version 1.99
%Please create RSA keys (of atleast 768 bits size) to enable SSH v2.
Authentication timeout: 120 secs; Authentication retries: 3
</pre>
      <p>
        A jeśli polecenie wydamy na urządzeniu, które nie ma takich funkcji
        (wg. opisywanej wcześniej zasady), jego odpowiedź będzie następująca:
      </p>
<pre class="code-block">
Switch#dir flash:
Directory of flash:/

    1  -rw-     3058048          &lt;no date&gt;  c2950-i6q4l2-mz.121-22.EA4.bin

64016384 bytes total (60958336 bytes free)
Switch#show ip ssh
SSH Enabled - version 1.99
Authentication timeout: 120 secs; Authentication retries: 3
</pre>
      <p>
        Generalnie pomysł z rozponawaniem możliwości kryptograficznych wersji
        IOS po nazwie pliku, nie jest złym pomysłem. Jest nowym pomysłem, ale
        jego twórca, prawdopodobnie zapomniał, że wcześniej istniał inny
        sposób. Dlatego też, nie warto tracić czasu na analizę nazwy pliku.
        Najlepiej od razu powyższe polecenie. W urządzeniach z obsługą SSH oraz
        silnej kryptografii, zwróci na ono takie informacje na jak na
        powyższych przykładach. Jeśli takiego wsparcia nie będzie, to wówczas
        to polecenie nie zostanie rozpoznane w ogóle.
      </p>
      <p>
        Wracając do konfiguracji SSH. Musimy ustawić nazwę hosta oraz 
        nazwę domeny. 
      </p>
<pre class="code-block">
Switch(config)#hostname C2950
C2950(config)#
C2950(config)#ip domain-name example.com
</pre>
      <p>
        SSH w wersji 1, zawiera znane podatności i nie jest już wykorzystywane,
        ani rozwijane. Więc aby użyć tej lepszej - 2 wersji SSH, musimy
        wygenerować nową parę kluczy, o długości co najmniej 768 bitów, aby
        móc włączyć SSH 2. Sugeruje nam to nawet informacja zwraca przez
        polecenie <code class="code-inline">show ip ssh</code>:
        <code class="code-inline">%Please create RSA keys (of atleast 768 bits size) to enable SSH v2.</code>
        Aby wygenerowac parę kluczy, wydajemy poniższe polecenie w trybie
        konfiguracji globalnej. Polecenie po uruchomieniu zapyta się o długość
        klucza. Generalnie przyjęło się, że taką dolną bezpieczną granica są
        klucze o długości 1024 bitów. Chociaż obecnie skłaniamy się do
        tworzenia dwa razy dłużyszch kluczy - 2048 bitów. Ze względu na
        powszchną dostępność dużej mocy obliczeniowej, tak krótkie klucze mogą
        nie wystarczać. Jednak należy pamiętać, że dłuższy klucz spowoduje
        większe obciążenie procesora urządzenia. Decyzja należy do nas. 
      </p>
<pre class="code-block">
C2950(config)#crypto key generate rsa
The name for the keys will be: C2950.example.com
Choose the size of the key modulus in the range of 360 to 4096 for your
  General Purpose Keys. Choosing a key modulus greater than 512 may take
  a few minutes.

How many bits in the modulus [512]: 1024
% Generating 1024 bit RSA keys, keys will be non-exportable...[OK]

C2950(config)#
</pre>
      <p>
        Powyższe informacje, tak jak nazwa host oraz domeny, służą do
        nazwania pary kluczy. SSH wymaga do uwierzytelniania nazwy użytkownika
        oraz hasła. Urządzenia Cisco mogą do uwierzytelniania wykorzystać
        specjalny serwer (RADIUS), lub lokalną bazę danych. Dla celów
        szkoleniowych wykorzystamy lokalną bazę danych. Utworzymy użytkownika
        <em>admin</em> z hasłem <em>ccna</em>. W trybie konfiguracji globalnej
        wydajmy poniższe polecenie.
      </p>
<pre class="code-block">
C2950(config)#username admin secret ccna
</pre>
      <p>
        Teraz możemy skonfigurować linie VTY, przełączniki Catalyst 2950 mają
        zakres tych linii od 0 15. Aby skonfigurować linie VTY, tak aby
        używały SSH wydajemy poniższe polecenia w trybie konfiguracji globalnej
        oraz w trybie konfiguracji linii.
      </p>
<pre class="code-block">
C2950(config)#line vty 0 15
C2950(config-line)#transport input ssh
C2950(config-line)#login local
C2950(config-line)#exit
</pre>
      <p>
        Na koniec pozostaje nam wymusić wersję 2 protokołu SSH. Za pomocą
        poniższego polecenia wydane w trybie konfiguracji globalnej:
      </p>
<pre class="code-block">
C2950(config)#ip ssh version 2
</pre>
      <p>
        Przełączenie wersji, możemy zweryfikować za pomocą polecenia
        <code class="code-inline">show ip ssh</code>. Przed wymuszeniem wersja
        była <em>1.99</em>, a obecnie jest:
      </p>
<pre class="code-block">
C2950#show ip ssh
SSH Enabled - version 2.0
Authentication timeout: 120 secs; Authentication retries: 3
</pre>
      <p>
        Weryfikacji działania SSH, możemy dokonać próbując się podłączyć,
        przy użyciu PuTTY lub innego klienta SSH. Obecnie są one wbudowane
        we większość systemów operacyjnych. Połączenia SSH na urządzeniach
        Cisco możemy sprawdzić za pomocą polecenia
        <code class="code-inline">show ssh</code>.
      </p>
      <h3 id="2.1.3.pka">Ćwiczenie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/1.3.6-packet-tracer---configure-ssh_pl-PL.pdf">Konfiguracja SSH - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/1.3.6-packet-tracer---configure-ssh_pl-PL.pka">Konfiguracja SSH - zadanie</a>
      </p>
      <h2 id="2.1.4.basicrouterconfiguration">2.1.4. Podstawowa konfiguracja routera</h2>
      <p>
        Do tej pory skupialiśmy się głównie na przełącznikach, teraz zajmiemy
        się routerem. Konfigurację routera, możemy podzielić na dwie części
        część pierwsza skupia się głównie na konfiguracji i podstawowym
        zabezpieczeniu systemu operacyjnego, bez konfiguracji interfejsów
        sieciowych. Część druga skupia się na właśnie na tej części sieciowej,
        ustawieniu interfejsów oraz ewentualnie tras.
      </p>
      <p>
        Pierwszą część wałkowaliśmy na pierwszym module, drugą również dlatego
        przedstawię je w postaci zwięzłego bloku kodu, jeśli coś będzie
        wymagało wyjaśnienia to umieszcze je pod nim.
      </p>
<pre class="code-block">
Router&gt;ena
Router#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#hostname R1
R1(config)#enable secret class
R1(config)#line console 0
R1(config-line)#password cisco
R1(config-line)#login
R1(config-line)#exit
R1(config)#line vty 0 4
R1(config-line)#password cisco
R1(config-line)#login
R1(config-line)#exit
R1(config)#service password-encryption
R1(config)#banner motd # Nieautoryzowany dostep jest zabroniony! #
R1(config)#end
R1#
%SYS-5-CONFIG_I: Configured from console by console

R1#copy running-config startup-config
Destination filename [startup-config]? 
Building configuration...
[OK]
</pre>
      <p>
        Innym dość ważnym zadaniem podczas egzaminu może być ustawienie
        aktualnej daty i czasu na urządzeniu. Dokonujemy tego za pomocą
        polecnia <code class="code-inline">clock set</code> w
        <strong>trybie uprzywilejowanym</strong>.
      </p>
<pre class="code-block">
R1#clock set 18:20:00 6 Jul 2024
</pre>
      <p>
        Myślę, że te powyższe proste polecenia nie wymagają dodatkowego
        omówienia. Teraz zajmiemy się częścią sieciową. Na kursie CCNA będziemy
        operować na podwójnym stosie IP - dla IPv4 oraz IPv6 i w taki sposób
        skonfigurujemy nasze interfejsy sieciowe. Na początku warto się
        rozejrzeć, jakie interfejsy mamy dostępne w naszym urządzeniu.
      </p>
<pre class="code-block">
Nieautoryzowany dostep jest zabroniony! 

User Access Verification

Password: 
Password: 

R1&gt;ena
Password: 
R1#show ip interface brief
Interface              IP-Address      OK? Method Status                Protocol 
GigabitEthernet0/0     unassigned      YES NVRAM  administratively down down 
GigabitEthernet0/1     unassigned      YES NVRAM  administratively down down 
Serial0/0/0            unassigned      YES unset  down                  down 
Serial0/0/1            unassigned      YES unset  down                  down 
Vlan1                  unassigned      YES NVRAM  administratively down down
R1#
</pre>
      <p>
        Kiedy już mniej więcej wiemy gdzie co ma być podłączone, możemy przejść
        do właściwej konfiguracji portów.
      </p>
<pre class="code-block">
R1#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
R1(config)#interface gigabitethernet 0/0
R1(config-if)#ip address 192.168.10.1 255.255.255.0
R1(config-if)#ipv6 address 2001:db8:acad:1::1/64
R1(config-if)#description LAN1
R1(config-if)#no shutdown
R1(config-if)#
R1(config-if)#exit
R1(config)#interface gigabitethernet 0/1
R1(config-if)#ip address 192.168.11.1 255.255.255.0
R1(config-if)#ipv6 address 2001:db8:acad:2::1/64
R1(config-if)#description LAN2
R1(config-if)#no shutdown
R1(config-if)#exit
R1(config)#interface Serial 0/0/0
R1(config-if)#ip address 209.165.200.225 255.255.255.252
R1(config-if)#ipv6 address 2001:db8:acad:3::225/64
R1(config-if)#description WAN1
R1(config-if)#no shutdown
R1(config-if)#exit
</pre>
      <p>
        EXAM TIP: Warto używać polecenia <code class="code-inline">description</code>
        podczas ustawiania interfejsów, nawet jeśli nas o to nie proszą czy nie
        podanej wprost treści opisu interfejsu ważne, że polecenie zostało
        wydane w trybie konfiguracji interfejsu.
      </p>
      <p>
        Podczas konfiguracji routera, być może będzie potrzeba skonfigurowania
        adresu pętli zwrotnej. <em>Loopback</em> fizycznie nie istnieje, jest
        adresem programowym, konfigurowanych w celach testowych lub
        pozostawnienia jednego co najmniej aktywnego portu na urządzeniu.
        Pętlę zwrotną konfiguruje się w poniższy sposób. 
      </p>
<pre class="code-block">
R1(config)#interface loopback 0
R1(config-if)#ip address 10.0.0.1 255.255.255.0
R1(config-if)#exit
</pre>
      <h3 id="2.1.4.pka">2.1.4. Ćwiczenie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/1.4.7-packet-tracer---configure-router-interfaces_pl-PL.pdf">Konfiguracja interfejsów routera - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/1.4.7-packet-tracer---configure-router-interfaces_pl-PL.pka">Konfiguracja interfejsów routera - zadanie</a>
      </p>
      <h2 id="2.1.5.interfaceverifyingcommands">2.1.5. Polecenia weryfikacji interfejsu</h2>
      <p>
        Czasami po ustawieniu interfejsów, czy zmianie innej konfiguracji w
        urządzeniach Cisco, chcielibyśmy zobaczyć czy gdzieś nie popełniśmy
        błedu lub też znajdujemy się w sytuacji, w której coś jest nie tak,
        coś nie działa jak należy i trzeba sprawdzić gdzie popełniliśmy błąd.
        Poniżej znajduje się lista przydatnych poleceń: 
      </p>
      <ul>
        <li><code class="code-inline">show ip interface brief</code> i 
          <code class="code-inline">show ipv6 interface brief</code> -
          wyświetlenie podsumowania wszystkich interfejsów wraz z adresami
          IPv4 i IPv6 oraz ich bieżącym stanem.</li>
        <li><code class="code-inline">show running-config interface <em>interface-id</em></code>
          - polecenia zastosowane do konfiguracji podanego interfejsu.</li>
        <li><code class="code-inline">show ip route</code> i
          <code class="code-inline">show ipv6 route</code> - wyświetlenie
            tablicy routingu. Od wersji 15 IOS, dla interfejsów będą dwie trasy
            podłączona (<code class="code-inline">C</code>) i lokalna 
            (<code class="code-inline">L</code>). We wcześniejszych wersjach
            IOS, będzie występować jedynie trasa podłączona
            (<code class="code-inline">C</code>)</li>
        <li><code class="code-inline">show ip interface <em>interface-id</em></code>
          i <code class="code-inline">show ipv6 interface <em>interface-id</em></code>
          - wyświetla szczegółowe informacje na temat podanego interfejsu.
          Identyfikator można pominąć wówczas wyświetlone zostaną wszystkie
          szczegóły wszystkich interfejsów w urządzeniu, po kolei.</li>
      </ul>
      <p>
        Wyjścia polecenia <em>show</em> podelgają filtrowanie, podobnie jak na
        Uniksach,
        stosuje się tutaj znak potoku (<strong>|</strong>), po znaku
        filtrowania (potoku), może wystąpić jedno z czterech poleceń
        filtrujących, a każde z nich przyjmuje jako argument
        <strong>wyrażenie filtrujące</strong>.
      </p>
      <ul>
        <li><code class="code-inline">section</code> - pokazuje całą sekcję 
          rozpoczynjące się od wyrażenia filtrującego</li>
        <li><code class="code-inline">include</code> - wyświetla linie pasujące
          do wyrażenia filtrującego</li>
        <li><code class="code-inline">exclude</code> - wyklucza linie pasujące
          do wyrażenia filtrującego</li>
        <li><code class="code-inline">begin</code> - pokazuje pozostałe linie
          z wyjścia polecenia od określonego przez wyrażenie filtracyjne
          wiersza.</li>
      </ul>
      <p>
        Jak mogliśmy spostrzec lub nie, IOS posiada historię. Historia poleceń
        domyślnie przechowuje tylko 10 wprowadzonych poleceń, a poruszać się
        poniej możemy albo zapomocą strzałek (góra - dół) lub kombinacji
        klawiszy <em>Ctrl+p</em> i <em>Ctrl+n</em> (GNU Readline). Wielkość
        bufora możemy kontrolować, wydając w trybie uprzywilejowanym polecenie
        <code class="code-inline">terminal history size <em>N</em></code>,
        gdzie <em>N</em> jest ilością przechowywanych wierszy. 
      </p>
<pre class="code-block">
R1#terminal history size 200
R1#show history
  ena
  show history
  terminal history size 200
  show history
</pre>
      <p>
        Innym polecenie dotyczącym historii, jest 
        <code class="code-inline">show history</code>, wyświetla cały bufor
        historii poleceń.
      </p>
      <h3 id="2.1.5.pka">2.1.5. Ćwiczenie praktyczne - Pakiet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/1.5.10-packet-tracer---verify-directly-connected-networks_pl-PL.pdf">Weryfikacja bezpośrednio podłączonych sieci - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/1.5.10-packet-tracer---verify-directly-connected-networks_pl-PL.pka">Weryfikacja bezpośrednio podłączonych sieci - zadanie</a>
      </p>
      <h2 id=2.1.summary">Podsumowanie</h2>
      <p>
        W tym rodziale dowiedzieliśmy się w jaki sposób uruchamiany jest system
        IOS na przełącznikach oraz ile informacji są nam stanie przekazać
        zwykłe diody LED tych urządzeń. Nauczyśliśmy się co robić w przypadku,
        kiedy zapisaliśmy w stałej pamięci wadliwą konfigurację czy
        zapomnieliśmy haseł dostępowych. Poznaliśmy metody konfiguracji
        dupleksu, domyślniej prędkości portu oraz mechnizmu Auto-MDIX. Na
        koniec przypomnieliśmy sobie podstawową konfigurację przełącznika i
        routera.
      </p>
      <h1 id="2.2.switchingconcepts">2.2. Koncepcje przełączania</h1>
      <p>
        Koncepcje przełączania i przekazywania ramek są uniwersalne dla
        dla różnego rodzaju sieci. Nie tylko tych informatycznych ale 
        telekomunikacyjnych. Wstępują różne typy przyłączników, a wybór
        metody zależy od przeływu tego ruchu. Z przełączaniem wiązą się dwa
        terminy: <strong>ingress</strong> - określenie stosowane dla portu, z
        którego nadchodzi ramka oraz <strong>egress</strong> - określenie dla
        portu, którego ramki będą używać do opuszczenia przełacznika.
      </p>
      <h2 id="2.2.1.frameforwarding">2.2.1. Przekazywanie ramek</h2>
      <p>
        Podczas przełączania przełączniki wykorzystują tablicę przełącznia.
        Ramki przełączane są na podstawie adresów MAC zapisanych w tej tablicy.
        Tablica wiąże ze sobą porty oraz adresy MAC, przez co ramka z
        określonym adresem docelowym zostanie skierowana na port powiązany w
        tablicy, bez
        względu na to jaki był port wejściowy. Ramka nigdy nie zostanie
        przekazana na port, z którego została odebrana.
      </p>
      <p>
        Tablica przełączania składa się numeru lub identyfikatora portu oraz
        adresu MAC urządzenia do niego podłączonego. Czyli ramki odebrane na
        tym porcie będą zawierać adres źródłowy tego urządzenia. Podczas
        przełączania przełącznik sprawdza adres docelowy czy istnieje
        przypisany do niego port przełącznika. Jeśli tak ramka jest 
        przekazywana na
        ten port. Tablica przełączania czasami nosi nazwę
        <strong>tabeli CAM</strong> od rodzaju pamięci zastosowanej do jej
        przechowywania. 
      </p>
      <p>
        Tablica MAC przełącznika jest uzupełniana na podstawie metod uczenia
        się. Przełącznik analizuje źródłowy adres MAC ramki i zapisuje ją 
        tablicy przypisując jej port, z którego została odebrana. Następnie
        w celu przełączenia ramki analizuje adres docelowy. Jeśli takiego
        adresu nie ma w tablicy wówczas przełącznik zachowuje się jak 
        koncentrator i przekazuje ramkę na wszystkie pozostałe porty. Przez
        kilka pierwszych sekund działania, każdy przełącznik zachowuje się
        koncentrator, ze względu na pustą tablicę. Proces uczenia się 
        nie kończy się na przypisaniu MAC-u do portu. Ze względu na to, że
        tablice MAC ma ją skończoną pojemność, więc trzeba usuwać nieaktywne
        już dowiązania. Jeśli z danego portu ramka nie nadejdzie w ciągu
        5 minut (300 sekund), to port zostaje w tablicy zwolniony, inaczej
        ma się to w przypadku przepięcia innego urządzeń do tego samego
        portu na przełączniku, w tym przypadku dodawny jest nowy wpis. Wpis
        poprzedniego hosta pozostanie w tablicy do upływy wspomnianej ilości
        czasu . Jeśli w ciągu tych 300 sekund, na 
        tym porcie pojawi się ramka, z adresem źródłowym przypisanym w tablicy
        wówczas licznik zostanie zresetowany.
      </p>
      <p>
        Ze względu na użyte układy ASIC
        (ang. <em>Application Specific Integrated Circuits</em>), przełączniki
        bardzo
        szybko dokonują decyzji, redukując tym samym czas obsługi pakietu oraz
        umożliwiając urządzeniom wydajną obsługę wielu urządzeń. Mimo to 
        możemy wyróżnić dwa rodzaj metod przełącznia.
      </p>
      <ul>
        <li><strong>store-and-forward</strong> - przy tej metodzie przełącznik
          dokonuje decyzji o przełączeniu w momencie odebrania całej ramki.
          Sprawdzona ona zostaje pod kątem błedów, na podstawie sumy kontrolnej
          CRC. Jest to domyślna metoda przełącznia ramek stosowana nawet
          przez najtańsze przełączniki, w tym również przełączniki Cisco.</li>
        <li><strong>cut-through</strong> - bardzo szybka metoda, przełącznie
          rozpoczyna się w momecie gdy przełącznik odbierze adres docelowy.</li>
      </ul>
      <p>
        Z najważniejszch cech przełączania <em>store and forward</em> jest
        na pewno sprawdzanie błędów, ale również 
        <strong>automatyczne buforowanie</strong>, jeśli między portami
        występuje różnica w prędkości, ramki są zachowywane przez przełącznik,
        sprawdzane pod kątem błędów, przekazywane do bufora portu wyjściowego,
        i następnie przesyłane dalej do odbiorcy.
      </p>
      <p>
        Metoda <em>cut-through</em>, nie sprawdza ramek pod kątem błędów. Może
        przekazać je dalej. Metoda ta jest bardzo szybka nie czeka nawet na
        odebranie całej ramki. Decyzje podjemuje, gdy odbierze adres MAC
        docelowy. Tego rodzaju przełączania dokonuje się w środowiskach
        HPC wymagających opóźnien na poziomie 10 mikrosekund i mniejszych.
        Metoda ta może mieć negatywny wpływ na wydajność sieci, poprzez
        zapychanie jej nie poprawnymi ramkami, dlatego jeśli ilość błedów
        zwiększa się ta metoda przełącza się w metodę
        <strong>fragment-free</strong> - ta metoda wydłuża nieco ilość
        odebranej ramki (do pola Typ), zanim podejmie decyzje pozwala to
        lepsze sprawdzenie błędów, niż w przypadku zwykłej metody
        <em>cut-through</em> nie wprowadzając przy tym dodatkowych opóźnień.
      </p>
      <h2 id="2.2.2.switchingdomain">2.2.2. Domena przełączania</h2>
      <p>
        W obecnych sieciach zbudowanych na bazie przełącznika, domena kolizyjna
        sprowadza się do pojedyńczego połączenia między urządzeniami. Tym
        przypadku kolizje nie występują i termin ten można uznać za przestarzły.
        Jednym przypadkiem, w którym mogło by dojść do kolizji w takich
        warunkach jest przypadek, gdzie urządzenia nie dogadają się w sprawie
        dupleksu. Jeden port na jednym urządzeniu ustawi się w tryb
        <em>half</em> a drugi w <em>full</em>. Raczej jest jakiś problem z
        urządzeniem, może jego uszkodzenie. Przełączniki domyślnie lobbują
        wyłącznie <em>full-duplex</em>.
      </p>
      <p>
        Inną domeną, w której komputery i przełączniki biorą czynny udział jest
        domena rozgłoszeniowa. Sieci krążą ramki rozgłoszeniowe, aby komputery
        i inne urządzenia znały swoje adresy oraz ewentualnie zasoby jakie mogą
        zaoferować (nie które usługi wysyłają ramki broadcastowe). Duża ilosc 
        takich transmisji
        może spowodować znaczny spadek wydajności. Do podziału domen
        rozgłoszeniowych na mniejsze części może służyć router lub podział
        sieci na mniejsze <strong>sieci wirtualne - VLAN-y</strong> (o
        <em>vlanach</em> będzie przyszły rozdział).  
      </p>
      <p>
        Chcąć mieć wydajną sieć musimy zaopatrzyć się w dobrej jakości
        przełączniki. Poniżej znajduje się kilka cech, które należy sprawdzić
        wybierając przełączniki.
      </p>
      <ul>
        <li><strong>Szybkość portów</strong> - obecnie sieci 100Mb/s ochodzą
          w niepamięć. Obecnie mamym szybie łącza swiatłowodowe lub trasmisję
          sieci komórkowej w standardzie 5G. Gdzie transfery rzędu 100Mb/s
          mogą być nie zadawalające. A przełączniki 1Gb/s są dość powszechne
          i coraz tańsze. Osobiście jeśli nie chcemy sprędzać czasu na
          analizowaniu ruchu to 1 gigabitowy przełącznik z uplinkami
          światłowodowymi do 10Gb/s powinien wystarczyć.</li>
        <li><strong>Szybkie przełączanie wewnętrzne</strong> - prędkość
          wewnętrznej magistrali</li>
        <li><strong>Duży bufor ramek</strong> - ilość pamięci przeznaczona
          na bufor.</li>
        <li><strong>Wysoka gęstość portów</strong> - ilość portów wymaganych
          oraz ile portów pozostanie nadmiarowo i czy to wystarczy na potrzeby
          ewentualnej późniejsz rozbudowy.</li>
      </ul>
      <h2 id="2.2.summary">Podsumowanie</h2>
      <p>
        W tym rodziale przypomnieliśmy sobie o metodach przełącznia oraz o tym
        jak przełączniki przekazują ramki. Na koniec wyjaśnniliśmy sobie
        czym jest domena przełączania oraz na jakie cechy przełączników
        zwrócić uwagę podczas ich zakupu.
      </p>
      <h1 id="2.3.vlannetworks">2.3. Sieci VLAN</h1>
      <p>
        W poprzednim rozdziale omawialiśmy, taką definicję jaką jest domena
        rozgłoszeniowa. Jednym z sposobów dzielenia domeny rozgłoszeniowej
        są <strong>VLAN</strong>-y. VLAN-y to nic innego jak wydzielona
        (a zarazem odizolowana) podsieć wirtualna w sieci przełączanej
        (opartej na przełącznikach). Do komunikacji między
        <strong>różnymi</strong> (to jest istotne) VLAN-ami, potrzebny jest
        router. 
      </p>
      <p>
        VLAN-y poza podziałem na mniejsze domeny rozgłoszeniowe,
        umożliwiają udostępnienie tych samych zasobów sieciowych, nie zależnie
        od miejsca umiejscowanie stanowiska pracy w firmie, oznacza to, że
        nie które działy mogą zajmować różne pokoje w budynkach firmy, ale
        pozostawać wpięci do tej samej fizycznej sieci lokalnej. To nie 
        wszystkie zalety
        wykorzystywania VLAN-ów w sieci LAN. Poniżej znajduje się cała lista.
      </p>
      <ul>
        <li><strong>Mniejsze domeny rozgłoszeniowe</strong> - podział sieci na
          sieci VLAN zmniejsza liczbę urządzeń w domenie rozgłoszeniowej.</li>
        <li><strong>Poprawa bezpieczeństwa</strong> - tylko użytkownicy w tej
          samej sieci VLAN mogą się ze sobą komunikować.</li>
        <li><strong>Zwiększona efektywność IT</strong> - VLAN-y upraszczają
          zarządzanie siecią, ponieważ użytkownicy o tych samych wymaganiach
          mogą się ze sobą komunikować. Sieci VLAN posiadają identyfikatory,
          które ułatwiąją ich rozróżnienie.</li>
        <li><strong>Redukcja kosztów</strong> - VLAN-y zmieniejszają
          zapotrzebowanie na kosztowne uaktualnienia sieci i korzystają z
          istniejącej przepustowości, a upliniki są lepiej wykorzystywane.</li>
        <li><strong>Lepsza wydajność</strong> - mniejsze domeny rozgłoszeniowe
          zmniejszają ilość nie potrzebnego ruchu.</li>
        <li><strong>Prostszy projekt i ułatwione wdrażanie aplikacji</strong>
          - sieci VLAN agregują użytkowników i urządzenia sieciowe w celu
          obsługi biznesu lub wymagań geograficznych. Posiadanie oddzielnych
          funkcji sprawia, że zarządzania projektem lub praca ze
          specjalistycznymi aplikacjami jest łatwiejsza.</li>
      </ul>
      <p>
        Rodzaje VLAN-ów można podzielić na klasę ruchu jaki przesyłaja ale
        również na funkcję jaką pełnią i tutaj możemy wyróżnić:
      </p>
      <ul>
        <li><strong>VLAN domyślny</strong> - na urządzeniach Cisco VLAN
          domyślny ma identyfiktor 1. Do niego przypisane są wszystkie dostępne
          na urządzeniu porty. Ruch kontrolny warstwy drugiej odbywa się w 
          sieci VLAN-u 1. Istotną rzeczą związana z tym VLAN-em są takie fakty
          jak: wszystkie porty są domyślnie przypisane do tego VLAN-u,
          VLAN-em natywnym jest VLAN 1, VLAN-em zarządzania jest 1. Nazwy sieci
          VLAN 1 nie można zmienić, a samego VLAN-u usunąć.</li>
        <li><strong>VLAN danych</strong> - VLAN-y danych są skonfigurowane w
          celu oddzielenia ruchu generowanego przez użytkownika. Sieć VLAN
          danych są używane do wydzielenia w sieci grup użytkowników i
          urządzeń. Nowoczesna sieć może mieć wiele sieci VLAN danych. W
          zależności od wymagań organizacyjnych. Należy pamiętać, że ruch
          głosowy i zarządzania nie powien być dozwolony w sieci VLAN danych.</li>
        <li><strong>Natywna sieć VLAN</strong> - Ruch sieci VLAN, jeśli ma
          zostać przesłany do innego przełącznika, to wykorzystywane są do
          tego porty magistralne, tzw. <strong>trunki</strong>, ruch wówczas
          określany jest jako znakowany. Port ustawiony jako <em>trunk</em>
          802.1Q wstawia 4-bitowy znacznik w nagłówku ramki Ethernet, w celu
          zindentyfikowania sieci VLAN, do której należy ta ramka. Przełacznik
          może jednak chcieć przesłać nieoznakowany ruch przez łącze
          <em>trunk</em>. Tego typu ruch generowany może byc przez przełączniki
          lub inne urządzania starszego typu. Porty <em>trunk</em> umieszczaja
          taki ruch w VLAN-ie natywnym. Domyślnie jest to VLAN 1. Ustawiając
          VLAN natywny najlepiej jest skorzystać z jakiegoś wysokiego
          identyfikatora. Tak zdefiniowany natywny VLAN, jest często
          stosowany dla wszystkich portów <em>trunk</em> w całej sieci.</li>
        <li><strong>VLAN zarządzania</strong> - tego typu VLAN jest
          konfigurowany specjalnie na potrzeby konfiguracji urządzeń oraz ich
          protokołów, takich jak: SSH, Telnet, HTTPS, HTTP czy SNMP. Domyslnym
          VLAN-em zarządzania jest VLAN 1.</li>
        <li><strong>VLAN głosowy</strong> - wymagany do obsługi technologii
          VoIP, ze względu na jego wymagania co do priorytetu ruchu. Warto
          pamiętać, że do poprawnej obsługi VoIP, cała sieć musi być
          zaprojektowana pod jej kątem. Najczęściej do transmisji głosowej
          wykorzystywany jest VLAN 150.</li> 
      </ul>
      <h3 id="2.3.1.pka">Ćwiczenie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.1.4-packet-tracer---who-hears-the-broadcast_pl-PL.pdf">Kto odbiera ruch rozgłoszeniowy? - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.1.4-packet-tracer---who-hears-the-broadcast_pl-PL.pka">Kto odbiera ruch rozgłoszeniowy? - zadanie</a>
      </p>
      <h2 id="2.3.2.vlannetworkwithmanyswitches">2.3.1. Sieci VLAN w infrastrukturze z wieloma przełącznikami</h2>
      <p>
        Jak wspomnieliśmy wcześniej, aby przesłać informacje tej samej sieci
        VLAN, między przełącznikami potrzebne są porty magistralne - 
        <em>trunk</em>-i, które za pomocą enkapsulacji 802.1Q umieszczają
        w ramkach identyfikator sieci VLAN, aby przełączniki mogły rozróżnić,
        z której sieci pochodzą transmitowane dane. Utworzone na przełącznikach
        <em>trunk</em>-i domyślnie przekazuje wszystkie zdefiniowane na
        przełącznikach VLAN-y. 
      </p> 
      <p>
        Porty <em>trunk</em> enkapsulują ramke <em>Ethernet II</em> w ramkę
        802.1Q, dodając po źródłowym adresie MAC, tzw. <em>tag</em> - pole ze
        znacznikiem VLAN-u. Sam tag zawiera kilka mniejszych pól:
      </p>
      <ul>
        <li><strong>Typ</strong> - 2-bajtowa wartość, zwana wartością TPID
          (<em>Tag Protocol ID</em>). Dla sieci Ethernet ma wartość 
          szesnastkową <code class="code-inline">0x8100</code>.</li>
        <li><strong>Priorytet użytkownika</strong> - 3-bitowa wartość,
          obsługująca poziom oraz usługę.</li>
        <li><strong>CFI (<em>Canonical Format Identifier</em>)</strong> -
          1 - bitowy identyfikator (flaga), który umożliwia przenoszenie ramek
          Token Ring przez Ethernet.</li>
        <li><strong>VLAN ID (VID)</strong> - 12-bitowy numer identyfikacyjny VLAN.
          Ze względu na to, że to pole ma 12-bitów. To maksymalny identyfikator
          VLAN-u to 4096.</li> 
      </ul>
      <p>
        Po dodaniu pola znacznika, przełącznika przelicza na nowo FCS i wstawia
        nową wartość do ramki.
      </p>
      <p>
        W przypadku natywnego VLAN-u, znakowanie wygląda trochę inaczej. Ramki
        znakowane, znacznikiem natywnego VLAN-u odebrane przez port
        <em>trunk</em> są odrzucane. Więc trzeba pamiętać aby urządzenia
        podłączone do tego typu portu były skonfigurowane w taki sposób, aby
        nie wysyłały znakowanych ramek, <em>tag</em>-iem natywnego VLAN-u.
      </p>
      <p>
        Inaczej jest gdy na port <em>trunk</em> trafi ramka nieoznakowana,
        jeśli tak już sie zdarzy to przełącznik przekaże ją do natywnej sieci
        VLAN. Jeśli na przełączniku nie ma urządzeń w natywnej sieci VLAN i
        nie ma innych portów magistrali to ramka jest odrzucana. Podczas
        konfiguracji portu magistrali 802.1Q, mamy możliwość ustawienia
        natywnego VLAN-u.
      </p>
      <p>
        Dla usług VoIP wymagany jest osobny VLAN, aby zapewnić odpowiednie
        wymagania QoS i zasad bezpieczeniastwa dla ruchu głosowego. Telefony
        IP firmy Cisco łączy się bezpośrednio z portem przełącznika. Komputer
        natomiast można połaczyć do telefonu IP, aby także uzyskać połączenie
        sieciowe. Port dostępowy przeznaczony dla telefonu IP można
        skonfigurować w taki sposób, żeby korzystał z dwóch oddzielnych sieci
        VLAN. Jeden VLAN dla obsługi ruchu głosowego, a drugi VLAN danych dla
        obsługi ruchu hosta.
      </p>
      <p>
        Port dostępowy przełącznika za pomocą CDP instruuje telefon IP, aby
        wysyłał ruch głosowy za pomocą jednej z trzech metod:
      </p>
      <ul>
        <li>Ruch z Voice VLAN musi być znakowany odpowiednią wartością
          priorytetową klasy usług (CoS) warstwy 2.</li>
        <li>Ruch dostępowej sieci VLAN, można również znakować za pomocą
          wartości priorytetowej CoS warstwy 2.</li>
        <li>VLAN dostępowy nie jest znakowany (bez wartości priorytetowe CoS
          warstwy 2)</li>
      </ul>
      <h3 id="2.3.2.pka">Ćwiczenie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.2.8-packet-tracer---investigate-a-vlan-implementation_pl-PL.pdf">Badanie implementacji sieci VLAN - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.2.8-packet-tracer---investigate-a-vlan-implementation_pl-PL.pka">Badanie implementacji sieci VLAN - zadanie</a>
      </p>
      <h2 id="2.3.3.vlanconfiguration">2.3.3. Konfiguracja sieci VLAN</h2>
      <p>
        Omawiając <em>tag</em> ramek 802.1Q, mówiliśmy o polu VLAN ID, jest ono
        12-bitowe. Tyle przewiduje standard, którym opisane są ramki ze
        znacznikiem. Jednak nie wszystkie przełączniki obsługują tak samo
        sieci VLAN. Tutaj mówimy o zakresach, o zakresie normalnym i
        zakresie rozszerzonym. Spójrzmy jak wygląd lista sieci VLAN na takim
        urządzeniu, na którym nie zdefiniowano żadnych sieci VLAN.
      </p>
<pre class="code-block">
Switch#show vlan brief

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9, Fa0/10, Fa0/11, Fa0/12
                                                Fa0/13, Fa0/14, Fa0/15, Fa0/16
                                                Fa0/17, Fa0/18, Fa0/19, Fa0/20
                                                Fa0/21, Fa0/22, Fa0/23, Fa0/24
                                                Gig0/1, Gig0/2
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active    
</pre>
      <p>
        Sieci VLAN w normalnym zakresie:
      </p>
      <ul>
        <li>Są stosowane we wszystkich małych i średnich sieciach biznesowych i
          korporacyjnych.</li>
        <li>Ich identyfikatory (VLAN ID) zawiera się w przedziale od 1 do 1005.</li>
        <li>Identyfikatory od 1002 do 1005 są zarezerowane dla starszch
          technologii sieciowych (tj. Token Ring i Fibre Distributed Data
          Interface).</li>
        <li>Identyfikatory 1 i od 1002 do 1005 są tworzone automatycznie i nie
          można ich usunąć.</li>
        <li>Konfiguracje są przechowywane w pamięci flash przełacznika w pliku
          bazy danych VLAN o nazwie vlan.dat.</li>
        <li>Po skonfigurowaniu, protokół VTP (VLAN Trunking Protocol) pomoga
          z synchronizować bazę danych VLAN między przełącznikami.</li>
      </ul>
      <p>
        Sieci VLAN o rozszerzonym zakresie:
      </p>
      <ul>
        <li>Wykorzystywane przez ISP lub globalne przedsiębiorstwa,
          wystarczająco duże, aby potrzebować tak dużej ilości VLAN-ów.</li>
        <li>Ich identyfikatory (VLAN ID) zwiera się w przedziale od 1006 do
          4096.</li>
        <li>Konfiguracje są domyślnie zapisywane w konfiguracji bierzącej.</li>
        <li>Obsługują mniej funkcji VLAN niż sieci w normalnym zakresie.</li>
        <li>Wymaga konfiguracji trybu transparentnego VTP do obsługi sieci
          VLAN o rozszerzonym zakresie.</li>
      </ul>
      <p>
        Aby skonfigurować sieci VLAN na przełączniku w trybie konfiguracji
        globalnej wydajemy poniższe polecenia:
      </p>
<pre class="code-block">
Switch(config)#vlan 20
Switch(config-vlan)#name student
Switch(config-vlan)#exit
</pre>
      <p>
        Polecenie <code class="code-inline">vlan</code> wymaga podania numeru
        VLAN-u (identyfikatora). Nazwa nie jest wymagana jednak, pozwala na
        łatwiejsze rozpoznanie VLAN-ów. Jeśli jej nie podamy przełącznik,
        przypisze ją sobie automatycznie, tworząc ją ze słowa VLAN i jeśli
        identyfikator jest dość niski (normalny zakres sieci VLAN) to do
        nazwy zostanie dodany identyfikator poprzedzony zerami. Jak na
        poniższym przykładzie.
      </p>
<pre class="code-block">
Switch#show vlan brief

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9, Fa0/10, Fa0/11, Fa0/12
                                                Fa0/13, Fa0/14, Fa0/15, Fa0/16
                                                Fa0/17, Fa0/18, Fa0/19, Fa0/20
                                                Fa0/21, Fa0/22, Fa0/23, Fa0/24
                                                Gig0/1, Gig0/2
20   student                          active    
30   VLAN0030                         active    
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active
</pre>
      <p>
        Utworzenie VLAN-ów na przełącznikach do tylko połowa pracy do wykonania
        podczas tworzenia sieci VLAN. Teraz trzeba przypisać do tych VLAN-ów,
        odpowiednie porty. W trybie konfigracji globalnej wydajmy poniższe
        polecenia.
      </p>
<pre class="code-block">
Switch#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#interface fastEthernet0/6
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 20
Switch(config-if)#end
</pre>
      <p>
        Na początek trochę teorii. Na przykładzie widzmy polecenie
        <code class="code-inline">switchport</code>. To nie jest tylko takie
        polecenie. Ale porty przełączników Cisco mają różne reprezentacje
        w zależności od warstwy ISO/OSI:
      </p>
<pre class="code-block">
L3 -&gt; SVI
          |
L2 -&gt; Switchport
          |
L1 -&gt; Fa0/6
</pre>
      <p>
        Przypisując port do VLAN-u, konfigurujemy jego warstwę drugą. Za pomocą
        polecenia:
        <code class="code-inline">switchport mode access</code>, ustawiamy
        port jako dostępowy, następnie za pomocą polecenia:
        <code class="code-inline">switchport access vlan 20</code>
        przypisujemy, dla którego VLAN-u ten port ma być portem dostępowym.
        I to tyle. W ten sposób utworzylismy sieć VLAN z jednym portem, dla
        pewności możemy wyświetlić sobie podsumowanie dotyczące VLAN-ów.
      </p>
<pre class="code-block">
Switch#sh vl br

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/7, Fa0/8, Fa0/9
                                                Fa0/10, Fa0/11, Fa0/12, Fa0/13
                                                Fa0/14, Fa0/15, Fa0/16, Fa0/17
                                                Fa0/18, Fa0/19, Fa0/20, Fa0/21
                                                Fa0/22, Fa0/23, Fa0/24, Gig0/1
                                                Gig0/2
20   student                          active    Fa0/6
30   VLAN0030                         active    
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active  
</pre>
      <p>
        Jak możemy zauważyć na powyższym przykładzie port Fa0/6, został zabrany
        z domyślnego VLAN-u 1 i przypisany do VLAN-u 20.
      </p>
      <p>
        W przypadku gdy chcemy przygotować port dostępowy dla telefonii a
        przy okazji do komputera. Musimy wykonać poniższe polecenia.
      </p>
<pre class="code-block">
Switch(config)#vlan 40
Switch(config-vlan)#name office
Switch(config-vlan)#vlan 150
Switch(config-vlan)#name VOICE
Switch(config-vlan)#exit
Switch(config)#int fa0/18
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 40
Switch(config-if)#mls qos trust cos
Switch(config-if)#switchport voice vlan 150
Switch(config-if)#end
</pre>
      <p>
        W tym przypadku utworzyliśmy dwa VLAN-y 40 (dla PC) i 150 (dla telefonu)
        następnie przypisaliśmy do portu: <code class="code-inline">fa0/18</code>
        VLAN dostępowy 40. Następną czynnością jest włączenie QoS, za pomocą
        polecenia <code class="code-inline">mls qos trust cos</code>.
        Ustawienia QoS nie są częścią kursu CCNA, więc można traktować te
        polecenie jako czynność mechaniczną, którą należy wykonać, teraz można
        przypisać drugi dodatkowy VLAN głosowy do tego samego portu.
        <code class="code-inline">switchport voice vlan 150</code>
      </p>
      <p>
        Polecenie podsumowujące VLAN-y znamy:
        <code class="code-inline">show vlan brief</code>. Jednak polecenie
        <code class="code-inline">show vlan</code>, posiada kilka innych
        argumentów. Możemy podać <em>id</em> i następnie identyfikator lub
        <em>name</em> i nazwę. Innym argumentem jest <em>summary</em>, które
        wyświetla kilka statystyk na temat VLAN-ów.
      </p>
<pre class="code-block">
S1# show vlan summary
Number of existing VLANs              : 7
Number of existing VTP VLANs          : 7
Number of existing extended VLANS     : 0
</pre>
      <p>
        Wracają jeszcze do przedniego przykładu z VLAN-em głosowym. Chcąć
        zobaczyć czy nasze zmiany zostały zatwierdzone możemy podejrzeć
        <em>switchport</em> każdego interfejsu.
      </p>
<pre class="code-block">
Switch# show interface fastEthernet0/18 switchport
Name: Fa0/18
Switchport: Enabled
Administrative Mode: static access
Operational Mode: down
Administrative Trunking Encapsulation: dot1q
Operational Trunking Encapsulation: native
Negotiation of Trunking: Off
Access Mode VLAN: 40 (office)
Trunking Native Mode VLAN: 1 (default)
Voice VLAN: 150
Administrative private-vlan host-association: none
...
</pre>
      <p>
        Konfiguracja sieci VLAN, może być monotonnym zajęciem. A przy takich
        czynnościach łatwiej o pomyłkę. Musimy więc dowiedzieć się jak wyjść
        na prostą, gdy coś źle skonfigujemy. Częstym błędem jest przypisanie
        portu nie do tego VLAN-u. Zatem aby zmienić przynależność portu do
        sieci VLAN należy wydać polecenie:
      </p>
<pre class="code-block">
Switch(config)#int fa0/18
Switch(config-if)#no switchport access vlan
Switch(config-if)#end
Switch#
%SYS-5-CONFIG_I: Configured from console by console

Switch#sh vl br

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9, Fa0/10, Fa0/11, Fa0/12
                                                Fa0/13, Fa0/14, Fa0/15, Fa0/16
                                                Fa0/17, Fa0/18, Fa0/19, Fa0/20
                                                Fa0/21, Fa0/22, Fa0/23, Fa0/24
                                                Gig0/1, Gig0/2
40   office                           active    
150  VOICE                            active    Fa0/18
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active    
</pre>
      <p>
        Po wydaniu polecenia,
        <code class="code-inline">no switchport access vlan</code>, port
        Fa0/18 wrócił do VLAN-u domyślnego, natomiast VLAN 40 jest pusty.
        Nie ma przypisanego żadnego portu.
      </p>
      <p>
        Inną czynnością może byc usunięcie VLAN-u. Jednak tutaj musimy pamiętać
        o kilku rzeczach. Na początku trzeba sprawdzić jakie porty są
        przypisane do usuwanego VLAN-u. Następnie te porty należy przepisać
        do innego VLAN-u i na koncu dopieru usunąć VLAN. Jeśli nie wykonamy
        tych czynności, porty osierocone przez usunięcie VLAN-u nie będą mogły
        komunikować się z innymi portami.
      </p>
<pre class="code-block">
Switch#sh vl br

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/10, Fa0/11, Fa0/12, Fa0/13
                                                Fa0/14, Fa0/15, Fa0/16, Fa0/17
                                                Fa0/18, Fa0/19, Fa0/20, Fa0/21
                                                Fa0/22, Fa0/23, Fa0/24, Gig0/1
                                                Gig0/2
20   student                          active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9
40   office                           active    
150  VOICE                            active    Fa0/18
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active

Switch#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#int range fa0/1-9
Switch(config-if-range)#switchport access vlan 40
Switch(config-if-range)#end
Switch#
%SYS-5-CONFIG_I: Configured from console by console

Switch#sh vl br

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/10, Fa0/11, Fa0/12, Fa0/13
                                                Fa0/14, Fa0/15, Fa0/16, Fa0/17
                                                Fa0/18, Fa0/19, Fa0/20, Fa0/21
                                                Fa0/22, Fa0/23, Fa0/24, Gig0/1
                                                Gig0/2
20   student                          active    
40   office                           active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9
150  VOICE                            active    Fa0/18
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active  
 
Switch#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#no vlan 20
Switch(config)#end
Switch#
%SYS-5-CONFIG_I: Configured from console by console

Switch#sh vl br

VLAN Name                             Status    Ports
---- -------------------------------- --------- -------------------------------
1    default                          active    Fa0/10, Fa0/11, Fa0/12, Fa0/13
                                                Fa0/14, Fa0/15, Fa0/16, Fa0/17
                                                Fa0/18, Fa0/19, Fa0/20, Fa0/21
                                                Fa0/22, Fa0/23, Fa0/24, Gig0/1
                                                Gig0/2
40   office                           active    Fa0/1, Fa0/2, Fa0/3, Fa0/4
                                                Fa0/5, Fa0/6, Fa0/7, Fa0/8
                                                Fa0/9
150  VOICE                            active    Fa0/18
1002 fddi-default                     active    
1003 token-ring-default               active    
1004 fddinet-default                  active    
1005 trnet-default                    active    
</pre>
      <p>
        Do usunięcia VLAN-u 20 użyłem polecenia 
        <code class="code-inline">no vlan 20</code>. Wcześniej jednak
        przypisałem na porty tego VLAN-u do innej sieci VLAN.
      </p>
      <h3 id="2.3.3.pka">Ćwiczenie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.3.12-packet-tracer---vlan-configuration_pl-PL.pdf">Konfiguracja sieci VLAN - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.3.12-packet-tracer---vlan-configuration_pl-PL.pka">Konfiguracja sieci VLAN - zadanie</a>
      </p>
      <h2 id="2.3.4.trunkconnections">2.3.4. Połączenia trunk</h2>
      <p>
        Sieci VLAN oparte o jeden przełącznik trochę mijają się z celem, ale
        jeśli założymy tych przełączników jest kilka, a użytkownicy różnych
        sieci VLAN znajdują się w róznych miejscach budynku. To wówczas aby
        zachodziła między użytkownikami komunikacja, potrzebujemy łączy
        magistralnych - <strong>trunk</strong>-ów. Porty magistralne
        konfigurujemy podobnie do portów dostępowych. W trybie konfiguracji
        globalnej wydajemy następującą serię poleceń:
      </p>
<pre class="code-block">
Switch(config)#int gig0/1
Switch(config-if)#switchport mode trunk
Switch(config-if)#switchport trunk native vlan 1
Switch(config-if)#switchport trunk allowed vlan 1,40,150
Switch(config-if)#end
Switch#
</pre>
      <p>
        Po podłaczeniu łączy <em>trunk</em>, będziemy mogli wydać polecenie
        <code class="code-inline">show interface trunk</code>, które pokaże
        nam informacje na temat skonfigurowanych w naszym urządzeniu portów
        magistralnych.
      </p>
<pre class="code-inline">
Switch#sh int tr
Port        Mode         Encapsulation  Status        Native vlan
Gig0/1      on           802.1q         trunking      1

Port        Vlans allowed on trunk
Gig0/1      1,40,150

Port        Vlans allowed and active in management domain
Gig0/1      1,40,150

Port        Vlans in spanning tree forwarding state and not pruned
Gig0/1      1,40,150
</pre>
      <p>
        Jeśli natomiast nasze połącznie <em>trunk</em> nie jest póki co
        zestawione, możemy wydać polecenie:
        <code class="code-inline">show interface gig0/1 switchport</code>. To
        polecenie również zwróci informacje na temat ustawień portu magistrali.
      </p>
<pre class="code-block">
Switch#sh int gig0/1 switchport
Name: Gig0/1
Switchport: Enabled
Administrative Mode: trunk
Operational Mode: trunk
Administrative Trunking Encapsulation: dot1q
Operational Trunking Encapsulation: dot1q
Negotiation of Trunking: On
Access Mode VLAN: 1 (default)
Trunking Native Mode VLAN: 1 (default)
Voice VLAN: none
Administrative private-vlan host-association: none
Administrative private-vlan mapping: none
Administrative private-vlan trunk native VLAN: none
Administrative private-vlan trunk encapsulation: dot1q
Administrative private-vlan trunk normal VLANs: none
Administrative private-vlan trunk private VLANs: none
Operational private-vlan: none
Trunking VLANs Enabled: 1,40,150
Pruning VLANs Enabled: 2-1001
</pre>
      <p>
        Jeśli zajdzie taka potrzeba, to możemy wyczyścić ustawienia natywnego
        VLAN-u oraz sieci VLAN dopuszczonych do ruchu przez ten <em>trunk</em>.
        Aby to zrobić wydajemy poniższe polecenia:
      </p>
<pre class="code-block">
Switch#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#int gig0/1
Switch(config-if)#no switchport trunk native vlan
Switch(config-if)#no switchport trunk allowed vlan
Switch(config-if)#end
</pre>
      <h3 id="2.3.4.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.4.5-packet-tracer---configure-trunks_pl-PL.pdf">Konfiguracja połączeń trunk - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.4.5-packet-tracer---configure-trunks_pl-PL.pka">Konfiguracja połączeń trunk - zadanie</a>
      </p>
      <h3 id="2.3.4.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/3.4.6-lab---configure-vlans-and-trunking_pl-PL.pdf">Konfiguracja sieci VLAN i łączy trunk</a>
      </p>
      <h2 id="2.3.4.dtpprotocol">2.3.5. Protokół DTP</h2>
      <p>
        Protokół DTP jest własnościowym protokołem Cisco, pozwalającym 
        negocjować między sąsiednimi przełącznikami łącza magistralne
        (<em>trunk</em>-i). Jest on domyślnie włączony w przełącznikach
        Catalyst z serii 2960 i 3650, zarządza on negocjacją łączy <em>trunk</em>
        o ile port na urządzeniu obok jest skonfigurowany w trybie trunk i
        wspiera DTP.
      </p>
      <p>
        Jeśli do portu <em>trunk</em> podłączamy urządzenie, które nie
        wspiera DTP, lepiej jest tę funkcję wyłaczyć. Niektóre urządzenia
        mogą źle przekazywać ramki DTP. Inną dość istotną kwestią jest
        bezpieczeństwo. Otóż istnieje oprogramowanie, które pozwoli aby
        zamienić zwykły port <em>Ethernet</em> komputera w port przełącznika
        ustawiony w tryb trunk. Wówczas może dojść do wynegocjowania łącza
        magistralnego między tymi urządzeniami, jeśli tak się stanie, to
        sieci VLAN przestają mieć sens. Ponieważ tak ustawiony komputer może
        połączyć się z dowolnym komputerem w dowolnym VLAN-ie.
      </p>
      <p>
        Dlatego zazwyczaj w sieciach produkcyjnych, ten protokół w ogóle nie
        działa. Łącza <em>trunk</em> ustawiane są ręcznie. Wyłączenia protokołu
        DTP dokonany w trybie konfiguracji interfejsu wydając następujące
        polecenia:
      </p>
<pre class="code-block">
Switch(config)#int gig0/1
Switch(config-if)#switchport mode trunk
Switch(config-if)#switchport nonegotiate
</pre>
      <p>
        Jeśli z jakiś powodów (choćby laboratoryjnych) chcielibyśmy wrócić do
        protokołu DTP. To możemym włączyć go ponownie za pomocą poniższych
        poleceń. Jednak najlepiej pozostawić porty magistralne w trybie
        <code class="code-inline">trunk</code>.
      </p>
<pre class="code-block">
Switch(config-if)#no switchport nonegotiate 
Switch(config-if)#switchport mode dynamic auto
</pre>
      <p>
        Na <em>switchport</em>-ach przełącznika, możemy ustawić kilka trybów,
        negocjacji. Te tryby oddziaływują na siebie, w zależności jaki tryb
        jest ustawiony z jednej czy z drugiej strony, wówczas możemy
        przewidzieć jak może wyglądać komunikacja między urządzeniami na tych
        portach.
      </p>
      <ul>
        <li><strong>access</strong> - Ustawia interfejs w stały tryb dostępu i
          negocjuje przełączenie łącza w tryb nie będący <em>trunk</em>-iem.
          Interfejs nie będzie <em>trunkiem</em>, bez znaczenia czy interfejs
          obok jest nim czy nie.</li>
        <li><strong>dynamic auto</strong> - Umożliwia konwersję interfejsu w
          <em>trunk</em>. Interfejs będzie <em>trunk</em>-iem jeśli sąsiedni
          port jest w trybie <em>trunk</em> lub <em>desirable</em> (pożadany
          <em>trunk</em>). Ten tryb jest domyślny dla wszystkich interfejsów
          <em>Ethernet</em>-owych.</li>
        <li><strong>dynamic desirable</strong> - Interfejs będzie próbować
          przekonwertować się w <em>trunk</em>. Przełączy się w tryb magistrali
          jeśli sąsiedni port jest <em>trnuk</em>-iem</em>, lub jest trybie
          <em>auto</em> lub <em>desirable</em>.</li>
        <li><strong>trunk</strong> - Ustawia interfejs w stały tryb
          <em>trunk</em> i negocjuje przełącznie sąsiedniego portu w tryb
          <em>trunk</em>. Interfejs ten będzie <em>trunk</em>-iem nawet jeśli
          drugi interfejs nim nie jest.</li>
      </ul>
      <p>
        Ustawienie opcji interfejsu <em>nonegotiate</em>, spowoduje że do
        dyspozycji będzie mieć tylko 2 tryby - <em>access</em> oraz
        <em>trunk</em>.
      </p>
      <p>
        W zależności od ustawienia portów, można uzyskać następujące rezulaty
        podczas negocjacji.
      </p>
      <table>
        <thead>
          <tr>
            <th></th>
            <th>Dynamic Auto</th>
            <th>Dynamic Desirable</th>
            <th>Trunk</th>
            <th>Access</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>Dynamic Auto</th>
            <td>Access</td>
            <td>Trunk</td>
            <td>Trunk</td>
            <td>Access</td>
          </tr>
          <tr>
            <th>Dynamic Desirable</th>
            <td>Trunk</td>
            <td>Trunk</td>
            <td>Trunk</td>
            <td>Access</td>
          </tr>
          <tr>
            <th>Trunk</th>
            <td>Trunk</td>
            <td>Trunk</td>
            <td>Trunk</td>
            <td>Ograniczona<br />komunikacja</td>
          </tr>
          <tr>
            <th>Access</th>
            <td>Access</td>
            <td>Access</td>
            <td>Ograniczona<br />komunikacja</td>
            <td>Access</td>
          </tr>
        </tbody>
      </table>
      <p>
        W celu sprawdzenia stanu protokołu DTP, na naszych urządzeniach
        możemy... No własnie w materiałach od Cisco podane jest polecenie
        <em>show dtp interface fa0/1</em>. Przy czym na Packet Tracerze - na
        którym przypomnę zdajemy egzaminy modułowe oraz główny CCNA. To
        polecenie nie występuje. Mimo posiadania najnowszej wersji 8.2.2 oraz
        Cisco IOS w wersji 15.0(2)SE4 - to polecenie nie występuje. Więc albo
        osoba przygotowująca materiały korzystała z nowszego firmware-u albo
        to polecenie jest stare i już go nie ma. Nie mniej jednak, dobra
        robota Cisco - kolejny babol w materiałach, które mają przygotować do
        egzaminu. Koniec rantu.
      </p>
      <h3 id="2.3.5.pka">Zadanie praktyczne - Pakiet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.5.5-packet-tracer---configure-dtp_pl-PL.pdf">Konfiguracja DTP - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.5.5-packet-tracer---configure-dtp_pl-PL.pka">Konfiguracja DTP - zadanie</a>
      </p>
      <h2 id="2.3.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale dowiedzieliśmy się czym są VLAN-y oraz jak podzielić
        dużą domenę rozgłoszeniową na mniejsze sieci wirtualne.
        Skonfigurowaliśmy łącza magistralne, aby hosty tych samych sieci
        VLAN, podłączonych do różnych przełączników mogły się ze sobą
        bez przeszkód komunikować. Na koniec dowiedzielismy się czym jest
        protokół DTP i jak funkcjonuje on w obecnych czasach. 
      </p>
      <h3 id="2.3.6.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.6.1-packet-tracer---implement-vlans-and-trunking_pl-PL.pdf">Wdrożenie sieci VLAN i łączy trunk</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/3.6.1-packet-tracer---implement-vlans-and-trunking_pl-PL.pka">Wdrożenie sieci VLAN i łączy trunk</a>
      </p>
      <h1 id="2.4.intervlanrouting">2.4. Routing między VLAN-ami</h1>
      <p>
        Po skonfigurowaniu sieci VLAN, może okazać się, że pomiędzy niektorymi
        sieciami powinna zachodzić komunikacja lub być może stworzyliśmy
        osobny VLAN dla serwerów i niezbędne jest aby dopuścić ruch do
        konkretnych serwerów.
      </p>
      <p>
        VLAN-y zawsze są odrębnymi sieciami IP, więc do umożliwienia
        komunikacji między nimi, potrzebny będzie router lub przełącznik
        warstwy 3. Mamy trzy możliwości zapewnienia routingu między VLAN-ami.
      </p>
      <ol>
      <li><strong>Tradycyjny routing pomiędzy sieciami VLAN</strong> -
        rozwiązanie bardzo słabo skalowalne. Wymaga, aby router posiadał dla
        każdego VLAN-u osobny fizyczny interfejs. Jeśli ktoś ma małą ilość 
        sieci VLAN to może zastosować takie rozwiązanie.</li>
      <li><strong>Router na patyku</strong> - rozwiązanie wystarczające dla
        małych i średnich sieci. Polega na połączeniu routera do przełącznika
        za pomocą łącza magistralnego.</li>
      <li><strong>Routing między sieciami VLAN z wykorzystaniem przełącznika L3</strong>
        - rozwiązanie stosowane w dużych sieciach. Polega na konfigurowaniu
        SVI dla każdego z VLAN-ów.</li>
      </ol>
      <h2 id="2.4.1.routeronthestick">2.4.1. Router na patyku</h2>
      <p>
        Jak już wcześniej zostało wspomniane ta metoda opera się na pojedynczym
        łączu <em>trunk</em> między przełącznikiem a routerem. Nie jest to
        jednak wszystko. Ze względu na to, że wykorzystujemu jeden interfejs
        routera, musimy w jakiś sposób go podzielić, aby móc przypisać do
        niego wiele adresów IP. Takim rozwiązaniem są 
        <strong>podinterfejsy</strong>. Kolejną czynnością do wykonania jest
        wskazanie jakie ramki ten podinterfejs będzie on otrzymywać.
      </p>
      <p>
        Poniżej znajduje się konfiguracja routera, które skonfigurowałem,
        zgodnie z tą metodą:
      </p>
<pre class="code-block">
Router#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#int gig0/0.30
Router(config-subif)#encapsulation dot1Q 30
Router(config-subif)#ip add 192.168.30.1 255.255.255.0
Router(config-subif)#description VLAN30
Router(config-subif)#exit
Router(config)#int gig0/0.40
Router(config-subif)#encapsulation dot1Q 40
Router(config-subif)#ip add 192.168.40.1 255.255.255.0
Router(config-subif)#description VLAN40
Router(config-subif)#exit
Router(config)#int gig0/0.99
Router(config-subif)#encapsulation dot1Q 99
Router(config-subif)#ip add 192.168.99.1 255.255.255.0
Router(config-subif)#description VLAN99
Router(config-subif)#exit
Router(config)#int gig0/0
Router(config-if)#description Trunk-Switch0
Router(config-if)#no shut
</pre>
      <p>
        Chcąc skonfigurować na interfejsie, podinterfejs należy dodac numer
        podinterfejsu po oznaczeniu interfejsu oddzielając go kropką
        (<code class="code-inline">int gig0/0.30</code>). Po wejsciu do
        konfiguracji podinterfejsu, ustawiamy format ramek dodając przy tym
        identyfikator VLAN-u, ktory ma trafić do tego interfejsu.
        (<code class="code-inline">encapsulation dot1Q 30</code>). Na podstawie
        tej informacji router, jeśli nadejdzie ramka z takim oznaczniem
        to obsłuży ją ten podinterfejs. Poźniej podajemy adres IP oraz
        maskę i możemy dodatkowo opisać te podinterfejsy. Dość istotna jest
        ostatnia czynność. Dla całego interfejsu
        (<code class="code-inline">gig0/0</code>) <strong>nie ustawiamy adresu
        ip</strong> tylko go podnosimy. Możemym dodać opis. Oczywiście należy
        pamiętać o skonfigurowaniu portu <em>trunk</em> podłączonego do routera
        na przełączniku.
      </p>
      <p>
        Testy <em>ping</em> między ewentualnym komputerami podłaczonymi do 
        portów należących do tych sieci VLAN, powinny zakończyć się powodzeniem.
        Natomiast w celach weryfikacyjnych możemy wydać takie polecenia jak:
      </p>
<pre class="code-block">
Router#show ip route
...

Gateway of last resort is not set

     192.168.30.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.30.0/24 is directly connected, GigabitEthernet0/0.30
L       192.168.30.1/32 is directly connected, GigabitEthernet0/0.30
     192.168.40.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.40.0/24 is directly connected, GigabitEthernet0/0.40
L       192.168.40.1/32 is directly connected, GigabitEthernet0/0.40
     192.168.99.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.99.0/24 is directly connected, GigabitEthernet0/0.99
L       192.168.99.1/32 is directly connected, GigabitEthernet0/0.99

Router#show ip interface brief | include up
GigabitEthernet0/0     unassigned      YES unset  up                    up 
GigabitEthernet0/0.30  192.168.30.1    YES manual up                    up 
GigabitEthernet0/0.40  192.168.40.1    YES manual up                    up 
GigabitEthernet0/0.99  192.168.99.1    YES manual up                    up 

Router# show interfaces gig0/0.30 (dla pozostałych .40, .99)
GigabitEthernet0/0.30 is up, line protocol is up (connected)
  Hardware is PQUICC_FEC, address is 0009.7c9a.ce01 (bia 0009.7c9a.ce01)
  Internet address is 192.168.30.1/24
  MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec, 
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation 802.1Q Virtual LAN, Vlan ID 30
  ARP type: ARPA, ARP Timeout 04:00:00, 
  Last clearing of "show interface" counters never

Switch0#show interface trunk
Port        Mode         Encapsulation  Status        Native vlan
Gig0/1      on           802.1q         trunking      1
Gig0/2      on           802.1q         trunking      1

Port        Vlans allowed on trunk
Gig0/1      30,40,99,150
Gig0/2      30,40,99,150

Port        Vlans allowed and active in management domain
Gig0/1      30,40,99,150
Gig0/2      30,40,99,150

Port        Vlans in spanning tree forwarding state and not pruned
Gig0/1      30,40,99,150
Gig0/2      30,40,99,150
</pre>
      <h3 id="2.4.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/4.2.7-packet-tracer---configure-router-on-a-stick-inter-vlan-routing_pl-PL.pdf">Router na patyku - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/4.2.7-packet-tracer---configure-router-on-a-stick-inter-vlan-routing_pl-PL.pka">Router na patyku - zadanie</a>
      </p>
      <h3 id="2.4.2.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/4.2.8-lab---configure-router-on-a-stick-inter-vlan-routing_pl-PL.pdf">Router na patyku</a>
      </p>
      <h2 id="2.4.3.l3switchmethod">2.4.3. Metoda z przełącznikiem 3 warstwy</h2>
      <p>
        Przełączniki L3 zapewniają znacznie szybszy i bardziej skalowalny
        routing dla sieci VLAN niż router na patyku. Przełaczniki te mogą
        routować z jednej sieci do drugiej za pomocą interfejsów SVI.
        Tego typu urządzania zapewniają mozliwość konwersji portu w
        <strong>routed port</strong>. Taki port zachowuje się tak jak port
        routera. Metoda uzycia przełącznika L3, polega skonfigurowaniu dla
        każdego z VLAN-ów osobnego SVI.
      </p>
<pre class="code-block">
MLS0(config)#vlan 10
MLS0(config-vlan)#name Facility
MLS0(config-vlan)#vlan 20
MLS0(config-vlan)#name Student
MLS0(config-vlan)#exit
MLS0(config)#int fa0/1
MLS0(config-if)#switchport mode access
MLS0(config-if)#switchport access vlan 10
MLS0(config-if)#int fa0/2
MLS0(config-if)#switchport mode access
MLS0(config-if)#switchport access vlan 20
MLS0(config-if)#exit
MLS0(config)#int vlan 10
MLS0(config-if)#ip address 192.168.10.1 255.255.255.0
MLS0(config-if)#no shut
MLS0(config-if)#int vlan 20
MLS0(config-if)#ip address 192.168.20.1 255.255.255.0
MLS0(config-if)#no shut
MLS0(config-if)#exit
MLS0(config)#ip routing
MLS0(config)#end
</pre>
      <p>
        Jeśli chodzi o omówienie konfiguracji, to dokonaliśmy tego za pomocą
        poleceń, które znamy z poprzedniego rozdziału oraz poprzedniego modułu.
        Ważne aby wydać polecenie <code class="code-inline">ip routing</code>,
        po całej konfiguracji, aby włączyc routing IP. Bez tego polecenia
        przełącznik L3, jest zwykłym przełącznikiem L2. Użycie tego polecenia
        lub konwersja portu na <em>routed port</em> powoduje właczenie
        dodatkowych funkcji, które wśród fizycnych urządzeń mogą być 
        ograniczane licencyjnie. Mamy bowiem doczynienia z dwiema wersjami
        IOS dla <em>switch</em>-y L3: <em>ipbase</em> oraz <em>ipservices</em>.
      </p>
      <p>
        Weryfikacji możemy dokonać <em>ping</em>-ując hosta z jednego VLAN-u do
        drugiego.
      </p>
      <h3 id="2.4.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/4.3.8-packet-tracer---configure-layer-3-switching-and-inter-vlan-routing_pl-PL.pdf">Konfiguracja przełącznia w warstwie 3 i routingu między sieciami VLAN - scenariusz</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/4.3.8-packet-tracer---configure-layer-3-switching-and-inter-vlan-routing_pl-PL.pka">Konfiguracja przełącznia w warstwie 3 i routingu między sieciami VLAN - zadanie</a>
      </p>
      <h2 id="2.4.4.intervlanroutingtroubleshooting">2.4.4. Rozwiązywanie problemów z routingiem między sieciami VLAN</h2>
      <p>
        Istnieje kilka możliwych problemów związanych z routingiem między
        sieciami VLAN. Poniżej znajduje lista, w której możemym znaleźć kilka
        typowych błędów i sposobów na ich rozwiązania i sposoby na upewnienie
        się, że to naprawdę jest to.
      </p>
      <table>
        <thead>
          <tr>
            <th>Rodzaj problemu</th>
            <th>Jak naprawić</th>
            <th>Jak zweryfikować</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Brakujące sieci VLAN</td>
            <td>
              <ul>
                <li>Utworzenie lub odtworzenie sieci VLAN jeśli nie istnieje</li>
                <li>Sprawdzenie czy port jest przypisany do prawidłowego VLAN-u</li>
              </ul>
            </td>
            <td>
              <code class="code-inline">show vlan [brief]</code><br />
              <code class="code-inline">show interfaces switchport</code><br />
              <code class="code-inline">ping</code>
            </td>
          </tr>
          <tr>
            <td>Problemy dotyczące portów <em>trunk</em></td>
            <td>
              <ul>
                <li>Sprawdzenie czy połączenia <em>trunk</em> są poprawnie
                  skonfigurowane.</li>
                <li>Sprawdzenie czy port jest trybie <em>trunk</em> i czy jest
                  włączony.</li>
              </ul>
            </td>
            <td>
              <code class="code-inline">show interfaces trunk</code><br />
              <code class="code-inline">show running-config</code>
            </td>
          </tr>
          <tr>
            <td>Problemy dotyczące portów dostępowych</td>
            <td>
              <ul>
                <li>Przypisanie portu do właściwej sieci VLAN</li>
                <li>Sprawdzenie czy port pracuje trybie dostępowym i jest
                  włączony</li>
                <li>Host może być niepoprawnie skonfigurowany w niewłaściwej
                  podsieci</li>
              </ul>
            </td>
            <td>
              <code class="code-inline">show interface switchport</code><br />
              <code class="code-inline">show running-config interface</code><br />
              <code class="code-inline">ipconfig</code>
            </td>
          </tr>
          <tr>
            <td>Problemy związane z konfiguracją routera</td>
            <td>
              <ul>
                <li>Adres IPv4 podinterfejsu routeta jest niepoprawnie
                  skonfigurowany</li>
                <li>Podinterfejs routera jest przypisany do identyfikatora
                  VLAN</li>
              </ul>
            </td>
            <td>
              <code class="code-inline">show ip interface brief</code><br />
              <code class="code-inline">show interfaces</code>
            </td> 
          </tr>
        </tbody>
      </table>
      <h3 id="2.4.4.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/4.4.8-packet-tracer---troubleshoot-inter-vlan-routing_pl-PL.pdf">Rozwiązywanie problemów z routingiem między sieciami VLAN - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/4.4.8-packet-tracer---troubleshoot-inter-vlan-routing_pl-PL.pka">Rozwiązywanie problemów z routingiem między sieciami VLAN - zadanie</a>
      </p>
      <h3 id="2.4.4.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/4.4.9-lab---troubleshoot-inter-vlan-routing_pl-PL.pdf">Rozwiązywanie problemów z routingiem między sieciami VLAN</a>
      </p>
      <h2 id="2.4.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale poruszylismy kwestie związane z routingiem między
        sieciami VLAN. Poznaliśmy metody pozwalające na połącznie ze sobą
        sieci VLAN. Każdą z metod poznalismy od strony zarówno teoretycznej
        jak i praktycznej.
      </p>
      <!--<h2 id="2.4.partialexam">Egzamin cząstkowy - Rozdziały: 1 - 4</h2>
      <p>
        <a href="Cisco_-_CCNA_-_SRWE_-_egzamin_czastkowy_roz_1_-_4.html">Egzamin z koncepcji przełączania, sieci VLAN i Routingu pomiędzy sieciami VLAN</a>
      </p>-->
      <h1 id="2.5.stpconcepts">2.5. Koncepcje STP</h1>
      <p>
        Protokół STP, <em>Spanning Tree Protocol</em> jest nie tyle co
        protokołem sieciowym, co pewnego rodzaju standardem zapewniającym
        możliwość istnienia łączy nadmiarowych w sieciach przełączanych
        - opartych na przełącznikach, bez powstawania pętli.
      </p>
      <h2 id="2.5.1.redundacyinswitchingnetworks">2.5.1. Nadmiarowość w siech przełączanych</h2>
      <p>
        Weźmy pod uwagę taką topologię fizyczną, w której mamy trzy
        przełączniki i każdy przełącznik jest połączony z każdym, do
        przełączników podłączonych jest kilka komputerów. Cała topologia,
        znajduje się w jednej domenie rozgłoszeniowej. Jak będzie wyglądać
        transmisja danych w takiej sieci? Otóż załóżmy, że jeden komputer
        chce wysłać wiadomość do komputera podłączonego do innego przełącznika.
        Na początku musi poznać jego adres fizyczny, więc wysyła zapytanie
        ARP. Zapytania ARP są transmisją <em>broadcast</em> - adresowaną do
        każdego hosta w sieci. Takie zapytanie na początku osiągnie
        przełącznik brzegowy pytającego. Następnie ten przełącznika roześle
        pakiet na wszystkie swoje porty. Zapytanie trafia do pozostałych
        przełączników, a te nie wiele myśląc - ze względu, że to
        <em>broadcast</em>, przekażą je dalej na wszystkie swoje porty,
        poza tym, z którego dane zostały odebrane. Warto
        pamiętać, że te przełącznik są połączone każdy z każdym. Spowoduje to
        aktualizację tablicy MAC, tj. według tego przełącznika komputer
        wysłający pakiet ARP, jest teraz wpięty w porty, w który fizycznie
        jest wpięty jeden z przełączników. Ten stan utrzyma się do momentu, aż
        nie przyjdzie to samo zapytanie ARP z drugiego przełącznika, wówczas
        dojdzie do kolejnej aktualizacji tablicy CAM, no i oczywiście
        przełączniki dalej przesyłają ten sam pakiet powielając go przy tym.
        Tak skonfigurowana sieć będzie działać kilka, kilkadziesiąt sekund. Po
        tym czasie, prawidłowa komunikacja zaniknie. Pozostanie tylko w kółko
        przesyłanie i powielanie tej samej wiadomości oraz rosnące zużycie
        zasobów sprzętych przełączników - znaczne zużycie procesora - większy
        pobór prądu oraz więcej wydzielanego przez urządzenia ciepła.
      </p>
      <p>
        W wyżej opisanym przypadku mieliśmy doczynienia ze zjawiskiem 
        <strong>pętli</strong> oraz w jej następstwie z
        <strong>burzą broadcastową</strong>. Pętla jest zjawiskiem w którym
        dochodzi do <strong>nienadzrowanego</strong> połączenia nadmiarowego
        w sieciach przełączanych - najprościej rzecz ujmując jeśli z jednego
        przełącznika przeciągneliśmy dwa kable - jeden na zapas - i podłączymy
        oba naraz, a przełącznik jest <em>prymitywną</em> wersją przełącznika
        sieci <em>Ethernet</em> i nie potrafi takiego połączenia nadzorować.
      <p>
      <p>
        Ramki Ethernetowe nie posiadają mechanizmów kontroli przepływu. Jak
        w przypadku pakietów IP są pola TTL lub <em>Hop Limit</em> - dzięki
        czemu mogą one krążyć w nieskończoność. Tego typu problem wykryto już
        prawie 40 lat temu, mimo że wówczas sieci przełączne kulały, nie było
        przełączników a raczej mosty. W 1985 powstała pierwsza implementacja
        algorytmu drzewa rozpiętego, dając tym samym możliwości dla protokołu
        <strong>STP</strong>
      </p>
      <h3 id="2.5.1.pka">Zadaie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/5.1.9-packet-tracer---investigate-stp-loop-prevention_pl-PL.pdf">Badanie zapobierania pętlom w STP - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/5.1.9-packet-tracer---investigate-stp-loop-prevention_pl-PL.pka">Badanie zapobiegania pętlom w STP - zadanie</a>
      </p>
      <h2 id="2.5.2.stpprotocol">2.5.2. Protokół STP</h2>
      <p>
        Protokół STP jest sposobem na zarządzanie łączami nadmiarowymi w taki
        sposób, aby były one fizycznie obecne i gotowe do pracy, ale nie
        powodowały przykrych skutków swojej obecności w sieciach przełączanych.
        Protokół ten oparty jest algorytm STA
        (<em>Spanning Tree Algorithm</em>), na którym oprzemy omawianie tego
        mechanizmu. Algorytm ten składa się tak naprawdę z czterech kroków:
      </p>
      <ol>
        <li>Wybór mostu głównego - ustalenie punktu odnieśnia, według którego
          będą prowadzone obliczenia określające główne oraz alternatywne
          kanały komunikacji.</li>
        <li>Określenie ścieżek alternatywnych - obliczenie (określenie) łączy
          głównych oraz alternatywnych. Łącza alternatywne są blokowane dla
          głównej komunikacji sieciowej, jednak są wstanie odbierać komunikaty
          protokołu STP, aby wiedzieć kiedy zarządzające nimi urządzenia mają
          je przygotować do pracy.</li>
        <li>Topologia wolna od pętli - normalny stan sieci, pozwalający na
          komunikowanie się hostów ze sobą. Mimo tego komunikaty protokołu
          STP są dalej transmitowane.</li>
        <li>Ponowne obliczenia ścieżek - ten krok wykonywany jest w przypadku
          awarii jedej z głównych ścieżek podczas 3-go kroku, wówczas wymagane
          jest ponowne przeliczenie kanałów komunikacji.</li>
      </ol>
      <p>
        Na przełącznikach Cisco protokół STP jest domyślnie włączony.
      </p>
      <h2 id="2.5.3.howstpworks">2.5.3. Działanie STP</h2>
      <p>
        Wyjaśnienie działania STP, opiera się na omówieniu dwóch pierwszych
        kroków alogorytmu. Pierwszy jest czynnością, wprost wykonywaną przez
        algorytm, ale krok drugi można podzielić na trzy mniejsze czynności:
      </p>
      <ol>
        <li>Wybór portów głównych</li>
        <li>Wybór portów desygnowanych</li>
        <li>Wybór portów alternatywnych (zablokowanych)</li>
      </ol>
      <p>
        Przełączniki podczas działania STP, przesłają informacje
        na temat protokołu w jednostkach <strong>BPDU</strong> - 
        <em>Bridge Protocol Data Units</em>. Komunikaty te zawierają ważną
        informację jaką jest <strong>BID</strong> - 
        <em>Bridge IDentifier</em> - identyfikator mostu. Algorytm STA jest
        dość starym mechnizmem, w czasach jego opracowywania nie było czegoś
        takiego jak przełącznik - wówczas używało się mostów. Na identyfikator
        mostu składa się:
      </p>
      <ul>
        <li><strong>Priorytet</strong> - może być definiowany przez
          administratora. Domyślnie w urządzeniach Cisco wynosi on 32768.
          Zakres wartości priorytetu wynosi 0 - 61440.</li>
        <li><strong>Rozszerzony identyfikator systemu</strong> - to pole
          zawiera identyfikator sieci VLAN.</li>
        <li><strong>Adres MAC</strong> - adres MAC przełącznika.</li>
      </ul>
      <p>
        Wartość BID, często pełni rolę decyzyjną w protokole STP. Na początku
        porównywana (między przełącznikami) jest suma priorytetu oraz
        rozszerzonego identyfikatora. Jeśli one są takie same - np. w
        przełącznikach Cisco pracujących w VLAN-ie 1 - to w takiej sytuacji
        porównywane są adresy MAC. Najniższa wartość szesnastkowa adresu MAC
        wygrywa.
      </p>
      <p>
        Pierwsza czynność algorytmu czyli wybór mostu głównego opiera się
        właśnie na BID. Na początku pod uwagę brana jest wyżej opisana suma,
        którą potocznie nazywa się priorytetem. Jeśli wynik nie będzie
        roztrzygający, wówczas zostanie użyty adres MAC. Tak wybrany
        przełącznik staję się punktem odniesienia do dalszych czynności
        algorytmu.
      </p>
      <p>
        Następną czynnością jest wybór <strong>portu głównego</strong> -
        port ten jest wybierany na podstawie najniższego kosztu ścieżki do
        mostu głównego.
      </p>
      <p>
        Koszt ścieżki obliczany jest na podstawie wszystkich łączy prowadzących
        do mostu głównego. Determinującym czynnikiem jest przepustowość takiego
        łącza. Domyślnie przyjmuje się, że łącza:
      </p>
      <ul>
        <li><strong>10Gb/s</strong> - koszt: 2,</li>
        <li><strong>1Gb/s</strong> - koszt: 4,</li>
        <li><strong>100Mb/s</strong> - koszt: 19,</li>
        <li><strong>10Mb/s</strong> - koszt: 100,</li>
      </ul>
      <p>
        Te wartości pochodzą ze specyfikacji protokołu STP z 1998
        (802.1D-1998), są one domyślne, a pomimo tego jest możliwość
        ich zmiany, aby lepiej zarządzać możliwymi ścieżkami.
      </p>
      <p>
        Jeden z przełączników ma dwie ścieżki, jedna wpięta jest bezpośrednio
        do mostu głównego natomiast druga, przechodzi przez jeszcze jeden
        przełącznik. Przełączniki mają przepustowość łączy 100Mb/s. Zatem
        ta pierwsza ścieżka będzie mieć koszt równy 19, a ta druga 38. Zatem,
        który port będzie portem głównym? W przypadku sieci o różnych
        przepustowościach określenie portów głównych wydaje się proste, ale co
        jeśli mamy wszędzie
        taki sam koszt? Tutaj sprawa się komplikuje i mamy do wyboru trzy
        różne metody, któraś z nich na pewno wyznaczy port główny.
      </p>
      <ul>
        <li><strong>Najniższy BID</strong> - w przypadku kiedy jeden
          z przełączników ma problem z jasnym określeniem portu głównego
          (na podstawie kosztów), wykorzystuje on BID z ramek BPDU i w
          momencie rostrzygnięcia, który BID jest najniższy, to port tego
          przełącznika staje się portem głównym. Natomiast ten drugi będzie
          portem alternatywnym (zablokowanym).</li>
        <li><strong>Najniższy priorytet portu</strong> - wykorzystanie
          tej metody ma miejsce w momencie gdy łączymy ze sobą dwa przełączniki
          ścieżkami o tych samych kosztach. Wtenczas brany jest pod uwagę
          priorytet portu - domyślnie wynosi on 128. Jeśli z jakiegoś powodu
          ustawimy na jednym porcie niższy priorytet, to ten port będzie
          portem alternatywnym (zablokowanym), a ten drugi stanie się portem
          głównym.</li>
        <li><strong>Najniższy identyfikator portu</strong> - ta 
          metoda jest ostatecznością. W przypadku takiej samej sytuacji jak
          w przy najniższym priorytecie portu. W tym przypadku wszystkie porty
          mają priorytet równy 128. To o porcie głównym decyduje najniższy
          identyfikator portu.
          Jeśli podłączone są porty 1 i 2, to najniższym będzie
          1 i to ten port będzie głównym, natomiast
          drugi zostanie zablokowany (port alternatywny).</li>
      </ul>
      <p>
        Drugim krokiem określenia ścieżek alternatywnych protokołu jest STP,
        jest wybór <strong>portów desygnowanych</strong>. Jest określenie
        portu w segmencie (z dwóch przełączników), który ma wewnętrzną ścieżkę
        do mostu głównego. Innymi słowy ma najlepszą drogę do odbierania ruchu
        kierowanego do mostu głównego. Ja to wolę określać słowami, który
        ma najbliżej do mostu głównego. Port desygnowany to port do którego
        połączony jest port główny.
      </p>
      <p>
        W przypadku mostu głównego, wszystkie jego podłączone porty są
        desygnowane. W końcu on ma najlepszą drogę do odbieranie ruchu do samego
        siebie. Podobnie jest z przełącznikami, do których podłączone są hosty
        <strong>porty brzegowe</strong> (port, do którego podłączono inne
        urządzenie niż przełącznik) są portami desygnowanymi.
      </p>
      <p>
        Do roztrzygnięcia pozostaje segment, który nie ma portu głównego, co
        wtedy? W tym przypadku pojawia się czynnik, który nie raz rozstrzygał
        remisy w protokole STP, czyli BID. Przełącznik o najniższym BID
        ustawi swój port w tym segmencie jako port desygnowany.
      </p>
      <p>
        Ostatnią czynnością wykonywaną na ostatnim porcie jest ustawienie go
        jako <strong>portu alternatywnego</strong>. Port ten jest blokowany
        dla normalnego ruchu sieciowego. Jest on w tym stanie odbierać jedynie
        ramki BPDU. 
      </p>
      <p>
        Zestawienie w pełni działającej topologii wolnej od pętli, a
        jednocześnie zapewniającej nadmiarowość nazywane jest
        <strong>konwergencją</strong>. Konwergencja STP jest dość ściśle
        określona w czasie. Oczywście, aby zapewnić jak najlepszą elastyczność
        możemy manipulować tymi wartościami czasowymi. Nie mniej jednak
        przyjmują one następujące wartości.
      </p>
      <ul>
        <li><strong>Hello Timer</strong> - czas <em>Hello</em> to odstęp między
          kolejnym ramkami BPDU, domyślnie ten czas to 2 sekundy. Można to 
          zmienić ustawiając czas od 1 do 10 sekund.</li>
        <li><strong>Forward Delay Time</strong> - opóźnienie przekazywania,
          jest to czas, w którym port jest wstanie nasłuchiwania i uczenia
          się. Domyślną wartością jest 15 sekund. Można zmodyfikować ten
          czas przypisując wartości od 4 do 30 sekund.</li>
        <li><strong>Max Age Time</strong> - maksymalny wiek to czas, w którym
          przełącznik czeka, zanim podejmie próbę zmiany topologii STP.
          Domyślnie są to 2 sekundy. Czas ten można zmienić ustawiając wartości
          od 1 do 10 sekund.</li>
      </ul>
      <p>
        Działanie protokołu STP opiera się na wymianie między przełącznikami
        ramek BPDU. Jeśli port przechodził by odrazu ze stanu blokowania do
        stanu przekazywania, mogłoby brakować pewnych informacji a to może
        doprowadzić do pętli. Dlatego też STP wyróżnia pieć stanów, w których
        znajdują się porty.
      </p>
      <ul>
        <li><strong>Blokowanie</strong> - Port nie przekazuje ramek
          <em>Ethernet</em>-owych,
          jedynie  nasłuchuje ramek BPDU w celu określenia 
          mostu głównego. Ramki BPDU zawierają informacje o rolach portów jakie
          biorą udział w obecnej topologii STP. Port, który przez
          <em>Max Age</em> nie odbierze żadnej ramki BPDU, automatycznie
          przechodzi w stan blokowania. Podczas blokowania portu, wpisy w
          tablicy MAC nie są aktualizowane. </li>
        <li><strong>Nasłuchiwanie</strong> - Port z blokowania przechodzi w
          tryb nasłuchiwania, obiera ramki BPDU w celu określenia ścieżki
          do mostu głównego oraz wysyła własne ramki BPDU, aby poinformować
          o inne przełączniki o tym, że przygotowuje się do czynnego udziału
          w topologii. W tym trybie port dalej nie przekazauje ramek
          <em>Ethernet</em> oraz nie aktualizuje wpisów w tablicy MAC.</li>
        <li><strong>Uczenie</strong> - Po stanie nasłuchiwania port,
          przechodzi w stan uczenia się. Odbiera i wysyła ramki BPDU i
          przygotowuje się do przekazywania ramek <em>Ethernet</em> i zaczyna
          wypełniać tablicę MAC, ale jeszcze nie przesyła ramek użytkowników.
        </li>
        <li><strong>Przekazywanie</strong> - Normalny tryb pracy portu.
          Port odbiera i wysyła ramki BPDU, aktualizuje tablice MAC oraz
          przekazuje ramki użytkowników.</li>
        <li><strong>Wyłączony</strong> - port wyłączony administracyjnie
          nie odbiera ani nie wysła żadnego ruchu, nawet ramek BPDU. Nie
          uczestniczy w procesie STP.</li>
      </ul>
      <p>
        Istnieje odmiana protokołu STP, dedykowana dla VLAN-ów. Pozwala na
        ona na obliczenie topologii STP, dla każdej z wirtualnych sieci.
        Co daje nam wiele różnych mostów głównych i wiele różnych oznaczeń
        portów. Tego rodzaju algorytm nosi nazwę PVST - 
        <em>Per-Vlan Spanning Tree</em>. O innych odmianach protokołu STP,
        będzie cały następny podrozdział.
      </p>
      <h2 id="2.5.3.stpevolution">2.5.3. Ewolucja STP</h2>
      <p>
        Algorytm STA, na którym oparty jest protokół STP, będzie mieć w
        przyszłym roku 40 lat. Omawiany przez nas, w tym rozdziale protokół
        został ratyfikowany 1998 roku, sądząc po jego oznaczeniu
        <strong>802.1D-1998</strong>. Przez ten czas całe 26 lat, wiele
        rzeczy uległo zmienianie. Z pewnością wzrosły prędkości używane przez
        dzisiejsze sieci, ale również i wymagania co do ich konfiguracji.
        Rzadko kiedy można spotkać sieć bez segmentacji czy bez sieci VLAN,
        a w takich środowiskach raczej odnalazłby się oryginalny bohater tego
        tematu. Obecnie przełączniki Cisco z serii Catalyst wykorzystują jako
        protokoł STP, w wersji <strong>PVST+</strong> - to czym ona jest
        dowiemy się tym pod rozdziale. 
      </p>
      <p>
        Z teoretycznego punktu widzenia odmiany protokoły STP, operają się na
        mieszaniu funkcji <strong>RSTP</strong> - <em>Rapid STP</em> lub
        <strong>PVST</strong>. O PVST wspominałem pod koniec poprzedniego
        podrozdziału. Natomiast RSTP jest klasyczną wersją STP z
        przyspieszoną konwergencją. 
      </p>
      <p>
        W przypadku RSTP stany portów zostały uproszczone. Stany STP takie jak:
        wyłączony, zablokowany, nasłuchiwanie, w przypadku RSTP mają jedno
        określenie <strong>stanu odrzucania</strong>. Podobnie jest w
        przypadku ról portów - port (w nomenklaturze STP)
        zablokowany/niedesygnowany, jest dla RSTP
        <strong>portem alternatywnym</strong>. RSTP również z pojęcia portu
        alternatywnego, wyciąga pojęcie <strong>portu zapasowego</strong> jest
        port, do którego podłączono nadmiarowo koncentrator. Port zapasowy
        występuje wyjątkowo rzadko.
      </p>
      <p>
        Ewolucja protokół STP wyklarowała również kilka technologii takich
        <strong>PortFast</strong>, czy <strong>BPDU Guard</strong>. Funkcja
        <em>PortFast</em> stosowana jest wyłącznie na portach brzegowych, do
        których podłączane są hosty sieci, służy ona szybkiemu przełączeniu
        roli portu z zablokowanej na przekazywanie. Jest to podyktowane
        potrzebą przyspieszenia podniesienia portu do stanu użyteczności,
        tak aby hosty miały szanse skomunikować się z mechanizmami automatycznej
        konfiguracji hosta (DHCP).
      </p>
      <p>
        Mechanizm <em>BPDU Guard</em> jest mechanizmem chroniącym porty
        brzegowe przed komunikatami protokołu STP - ramkami BPDU. Jeśli taka
        ramka pojawi się na porcie z włączoną funkcją PortFast, to wówczas
        port zostaje przełączony w stan <em>errdisabled</em>
        (wyłączony przez błąd) i administrator musi go podnieść ręcznie. Jest
        to jeden z mechnizmów ochronnych przed potencjalną pętlą. Działanie
        tego mechanizmu najczęsciej wywołuje podłączenie do portu brzegowego
        kolejnego przełącznika.
      </p>
      <p>
        Pomimo, że STP jest powszechnie stosowane to w najbliższym czasie
        lub już zostało zastąpione przez protokołu routingu warstwy 3 - 
        stosowanie przełączników warstwy 3. Oferują one lepszą wydajność i
        przewidywalność niż protokół STP. 
      </p>
      <p>
        Natomiast z samych odmian protokołu STP możemy wymieć:
      </p>
      <ul>
        <li><strong>PVST+</strong> - możliwe uruchomienie instancji STP dla
          każdego VLAN-u z osobna oraz funkcje dodatkowe jak 
          <em>PortFast</em> i <em>BPDU Guard</em>
          (protokół własnościowy Cisco).</li>
        <li><strong>802.1D-2004</strong> - aktualizacja oryginalnego standardu
          STP, dodając funkcje 802.1w</li>
        <li><strong>RSTP</strong> - 802.1w, przyspieszenie konwergencji STP</li>
        <li><strong>Rapid PVST+</strong> - przyspieszona wersja PVST+
          (protokoł własnościowy Cisco).</li>
        <li><strong>MST</strong> - odmiana protokołu STP, pozwalająca łączyć
          ze sobą sieci VLAN, z wykorzystaniem tej samej logicznej bądź
          fizycznej topologii STP. Wykorzystano tutaj także przyspieszenie
          z wersji <em>Rapid</em> protokołu STP oraz funkcje dodatkowe
          (własnościowy protokół Cisco).
        <li><strong>MSTP</strong> - wolna odmiana MST firmy Cisco,
          zaprojektowana przez IEEE.</li>
      </ul>
      <h2 id="2.5.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale dowiedziliśmy się w jaki sposób zapewnić nadmiarowe
        łącza w sieci przełączanej bez ryzyka pętli a w konsekwencji burzy
        <em>broadcastowej</em>. Możemy tego dokonać za pomocą protokołu STP.
        Poznaliśmy sposób działania protokołu STP - jak wybiera on
        odpowiednie ścieżki i porty. Na koniec omówiliśmy odmiany protokołu,
        które są jego odpowiedzią na dynamicznie zmieniające się warunki
        sieciowe w obecnych czasach.
      </p>
      <h1 id="2.6.etherchannel">2.6. Technologia EtherChannel</h1>
      <p>
        Wróćmy na chwilę do topologii, znanej z rozdziału o STP. Mamy trzy
        przełączniki i łączym je każdy z każdym. Wprowadźmy zmiany do topologii
        dodając do każdego łącza, po jednym dodatkowym łączu zapasowym.
        Z uwagi na to, że STP jest domyślnie włączone, to z dostępnych 6
        fizycznych łączy tylko 2 będą używane. Więc trochę szkoda naszych
        pieniędzy, które wydaliśmy na te dodatkowe łącza. Nie mniej jednak
        istnieje technologia, która pozwoli nam wykorzystać większość łączy,
        a po mimo tego, protokół STP dalej będzie działać przez co 
        wykorzystanę będą dodatkowe 2 łącza, co daje już 66% wykorzystanej
        infrastruktury, a nie 33%. Technologią tego typu jest
        <strong>agregacja łączy</strong>, w przypadku firmy Cisco mówimy
        o technologii <em>EtherChannel</em>. Ta technologia to nie tylko
        lepsze wykorzystanie łączy nadmiarowych, ale także zwiększe ich
        przepustowości, przy czym tutaj należy pamiętać o tym, że ta wspólna
        przepustowość nigdy nie będzie równa sumie natywnych przepustowości
        łączy, wykorzystanych do agregacji. Ale będzie znajdować się gdzieś
        bliżej tej liczy niż w przypadku pojedynczego łącza.
      </p>
      <h2 id="2.6.1.howethchworks">2.6.1. Działanie EtherChannel</h2>
      <p>
        Technologia <em>EtherChannel</em> posiada wiele zalet, między innymi
        takie jak:
      </p>
      <ul>
        <li>Możliwość przeprowadzenia spójnej konfiguracji dla wszystkich
          portów zagregowanych w <em>EtherChannel</em>. Taką konfigurację 
          przeprowadza się dla interfejsu agregującego (<em>Port-Channel</em>).
        </li>
        <li>Oparcie <em>EtherChannel</em> na portach przełącznika, niweluje
          zakup bardziej wydajnych urządzeń w celu zwiększenia przepustowości.
        </li>
        <li><em>EtherChannel</em> równoważy obciążenia pomiędzy połączeniami
          tego samego kanału. W zależności od platfomy sprzetowej może
          wykorzystać do tego różne metody.</li>
        <li>Kanał <em>EtherChannel</em> jest jednym łączem logicznym i tak też
          traktuje je protokół STP. Dzięki czemu możemy wykorzystać więcej
          łączy.</li>
        <li><em>EtherChanel</em> zapewnia nadmiarowość jest jedno logiczne
          połączenie, utrata jednego z fizycznych łączy nie powoduje zmian
          topologii.</li> 
      </ul>
      <p>
        Po za zaletami ta technologia ma też kilka ograniczeń: 
      </p>
      <ul>
        <li>Rodzaje interfejsów nie mogą być mieszane. Porty
          <em>FastEthernetowe</em> i <em>GigabitEthernet</em> nie mogą być
          łączone w jeden <em>EtherChannel</em>.</li>
        <li>Każdy <em>EtherChannel</em>, może składać się z maksymalnie 8
          portów dając przespustować kanału do 800Mb/s lub do 8Gb/s.</li>
        <li>Przełączniki serii Catalyst 2960 mogą mieć maksymalnie 6 kanałów.</li>
        <li>Konfiguracja portów grupy <em>EtherChannel</em>, musi się zgadzać
          na obu urządzeniach. Jeśli na jednym urządzeniu są to <em>trunki</em>
          to na drugim też muszą być w tej samej natywnej sieci VLAN.
          <!--<em>EtherChannel</em> dodatkowo wymaga, aby porty łaczone w kanał
          były warstwy drugiej.--></li>
        <li>Konfigucja <em>EtherChannel</em> będzie mieć wpływ na porty
          fizyczne przypisane do kanałów.</li>
      </ul>
      <p>
        <em>EtherChannele</em> mogą być tworzone na zasadzie auto-negocjacji
        - przy użyciu protokołów PAgP lub LACP. Jednak jest również możliwość
        skonfigurowania statycznego lub bezwarunkowego <em>EtherChannel</em>
        bez udziału wyżej wymienionych protokołów, nie mniej jednak omówimy
        je sobie.
      </p>
      <p>
        Protokół PAgP jest zastrzeżonym protokołem firmy Cisco, pomaga w
        automatycznym tworzeniu połączeń <em>EtherChannel</em>. PAgP umożliwia
        tworzenie łącza EtherChannel poprzez wykrycie konfiguracji każdej ze
        stron i zapewnienie, że linki są kompatybilne w taki sposób, że
        <em>EtherChannel</em> może być włączony w razie potrzeby. Tryby dla
        PAgP są następujące:
      </p>
      <ul>
        <li><strong>on</strong> - Tryb ten zmusza do uruchomienia
          <em>EtherChannel</em> bez protokołu PAgP. Interfejsy skonfigurowane
          w tym trybie nie wymieniają pakietów PAgP.</li>
        <li><strong>desirable</strong> - Ten tryb protokołu umieszcza
          interfejs w stanie aktywnej negocjacji. Interfejs rozpoczyna
          negocjacje z innymi interfejsami po przez wysłanie pakietów PAgP.</li>
        <li><strong>auto</strong> - Ten tryb umieszcza port w trybie
          pasywnej negocjacji. Interfejs odpowiada pakietom PAgP, ale nie
          inicjuje negocjacji.</li>
      </ul>
      <p>
        Ustawienie tych stanów na poszczególnych portach decydują o tym czy
        <em>EtherChannel</em> zostanie w ogóle zestawione. Domyślnie
        <em>EtherChannel</em> nie jest zestawiane. Polecenia konfiguracji mogą
        też zostać poprzedzone słowem <code class="code-inline">no</code> to
        wówczas spowoduje wyłączenie <em>EtherChannel</em>.
      </p>
      <p>
        Tryb <em>on</em> powoduje, że manualne umieszczenie interfejsu w
        kanale <em>EtherChannel</em>. Działa to tylko w tedy gdy druga strona
        jest również w trybie <em>on</em>. Tryb <em>on</em> w ogóle nie
        negocjuje więc jeśli druga strona jest w jednym z trybów protokołu
        PAgP, to kanał się nie utworzy.
      </p>
      <p>
        Poniżej znajduje się tabela przedstawiająca tryby protokołu PAgP
        ustawione na portach dwóch przełączników oraz ich skuteczność w
        zestawianiu kanału <em>EtherChannel</em>.
      </p>
      <table>
        <thead>
          <tr>
            <th>S1</th><th>S2</th><th>Ustanowienie kanału</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><em>On</em></td><td><em>On</em></td><td>Tak</td></tr>
          <tr><td><em>On</em></td><td><em>Desirable/Auto</em></td><td>Nie</td></tr>
          <tr><td><em>Desirable</em></td><td><em>Desirable</em></td><td>Tak</td></tr>
          <tr><td><em>Desirable</em></td><td><em>Auto</em></td><td>Tak</td></tr>
          <tr><td><em>Auto</em></td><td><em>Desirable</em></td><td>Tak</td></tr>
          <tr><td><em>Auto</em></td><td><em>Auto</em></td></td><td>Nie</td></tr>
        </tbody>
      </table>
      <p>
        Drugim protokołem w tym przypadku wolnym - opracowywanym przez 
        IEEE (802.3ad) jest LACP. Jest on łudząco podobny do protokołu PAgP
        Różnice polegają na zestawianiu kanału (jednak, nie będziemy się tym
        tutaj zajmować), możliwość wykorzystania środowisk wielu producentów
        w tym i Cisco oraz w nazewnictwie trybu protokołu.
      </p>
      <table>
        <thead>
          <tr>
            <th>S1</th><th>S2</th><th>Ustanowienie kanału</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><em>On</em></td><td><em>On</em></td><td>Tak</td></tr>
          <tr><td><em>On</em></td><td><em>Active/Passive</em></td><td>Nie</td></tr>
          <tr><td><em>Active</em></td><td><em>Active</em></td><td>Tak</td></tr>
          <tr><td><em>Active</em></td><td><em>Passive</em></td><td>Tak</td></tr>
          <tr><td><em>Passive</em></td><td><em>Active</em></td><td>Tak</td></tr>
          <tr><td><em>Passive</em></td><td><em>Passive</em></td></td><td>Nie</td></tr>
        </tbody>
      </table>
      <h2 id="2.6.2.etherchannelconfig">2.6.2. Konfiguracja EtherChannel</h2>
      <p>
        W poprzednim podrozdziale poznaliśmy teorie dotyczącą
        <em>EtherChannel</em>. Teraz czas nieco pobrudzić sobie łapki i 
        spróbować skonfigrować kilka kanałów, a przy najmniej nauczyć się
        w jaki sposób można to zrobić.
      </p>
      <p>
        Na początku musimy upewnić się, że nasze środowisko (przełączniki,
        porty przełącznika) spełniają odpowiednie wymagania.
      </p>
      <ul>
        <li><strong>Obsługa <em>EtherChannel</em></strong> - porty muszą
          wspierać technologię <em>EtherChannel</em>.</li>
        <li><strong>Szybkość i dupleks</strong> - porty muszą być tej samej
          przepustowości oraz w tym samym trybie dupleksu.</li>
        <li><strong>Zgodność VLAN</strong> - porty muszą być w tym samym
          VLAN-ie, lub skonfigurowane jako <em>trunk</em>.</li>
        <li><strong>Zakres VLAN</strong> - Zakresy dozwolonych sieci VLAN na
          łączach <em>trunk</em> musi być taki sam dla wszystkich portów.</li>
      </ul>
      <p>
        Metody konfiguracji <em>EtherChannel</em> wyglądają podobnie do siebie
        w zależności od protokołu jaki użyjemy. Różnice będą polegać na
        na określeniu trybu protokołu. Poniżej przykładowa konfiguracja kanału
        <em>EtherChannel</em> na jednej ze stron, dla protokołu LACP.
      </p>
<pre class="code-block">
S3(config)#int range fa0/23-24
S3(config-if-range)#shutdown
...
S3(config-if-range)#channel-group 1 mode active
S3(config-if-range)#
Creating a port-channel interface Port-channel 1
S3(config-if-range)#no shutdown
</pre>
      <p>
        Ta konfiguracja jest bardzo podstawowa. Możemy ją rozszerzyć o np.
        nośność sieci VLAN, oczywiście pamiętając o wymaganiach.
      </p>
      <h3 id="2.6.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/6.2.4-packet-tracer---configure-etherchannel_pl-PL.pdf">Konfiguracja EtherChannel - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/6.2.4-packet-tracer---configure-etherchannel_pl-PL.pka">Konfiguracja EtherChannel - zadanie</a>
      </p>
      <h3 id="2.6.2.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/6.4.2-lab---implement-etherchannel_pl-PL.pdf">Implementacja EtherChannel</a>
      </p>
      <h2 id="2.6.3.etherchanneltroubleshooting">2.6.3. Rozwiązywanie problemów z EtherChannel</h2>
      <p>
        Wcześniej konfigurowaliśmy kanał <em>EtherChannel</em> i chcielibyśmy
        się dowiedzieć czy on w ogóle działa. Aby wyświetlić informacje w 
        IOS na temat <em>EtherChannel</em> możemy posłóżyć się kilkoma
        poleceniami, ale najbardziej przydatym z nich będzie
        <code class="code-inline">show etherchannel summary</code>. Tak
        się prezentuje wyjście tego polecenia.
      </p>
<pre class="code-block">
S3&gt;show etherchannel sum
Flags:  D - down        P - in port-channel
        I - stand-alone s - suspended
        H - Hot-standby (LACP only)
        R - Layer3      S - Layer2
        U - in use      f - failed to allocate aggregator
        u - unsuitable for bundling
        w - waiting to be aggregated
        d - default port


Number of channel-groups in use: 2
Number of aggregators:           2

Group  Port-channel  Protocol    Ports
------+-------------+-----------+----------------------------------------------

1      Po1(SU)           LACP   Fa0/23(P) Fa0/24(P) 
2      Po2(SU)           LACP   Fa0/21(P) Fa0/22(P) 
</pre>
      <p>
        Jak możemy zauważyć większość wyjścia tego polecenia to legenda, która
        jest potrzebna do objaśnienia zwięzłej tabeli na dole. Mamy dwie
        grupy, które są własnie tymi <em>EtherChannel</em>-ami. W drugiej
        kolumnie pokazano <code class="code-inline">Port-channel</code>-e, 
        które są wirtualnymi interfejsami reprezentującymi kanał. Na ich
        podstawie możemy skonfigurować nasze kanały jako <em>trunki</em>.
        W nawiasach obok nazw tych interfejsów
        (<code class="code-inline">Po1</code>), znajduje się stan kanału. W
        przypadku stanu <code class="code-inline">SU</code> to jest to
        <em>EtherChannel</em> warstwy drugiej w użyciu (jest operacyjny) - 
        zgodnie z legendą. W kolejnej kolumnie znajduje się protokół użyty do
        agregacji oraz porty, które wchodzą w skład kanału ich rola w nim w
        tym przypadku, pokazane na przykładnie porty, biorą aktywny udział
        w kanale.
      </p>
      <p>
        Innymi poleceniami wartymi uwagi podczas pracy z <em>EtherChannel</em>
        są:
      </p>
      <ul>
        <li><code class="code-inline">show interfaces port-chanel</code></li>
        <li><code class="code-inline">show etherchannel port-channel</code></li>
        <li><code class="code-inline">show interfaces etherchannel</code></li>
      </ul>
      <p>
        Oczywiście podczas konfiguracji czegokolwiek, mogą wystąpić różne
        problemy. Tak samo jest w przypadku <em>EtherChannel</em>. Poniżej
        znajduje się kilka powodów, które sprawiają że nasze kanały nie chcą
        za bardzo działać.
      </p>
      <ul>
        <li>Porty nie w tych samych sieciach VLAN lub nie są <em>trunkami</em>.
          Porty mające różne natywne sieci VLAN nie są w stanie utworzyć
          kanału.</li>
        <li>Skonfigurowano tryb <em>trunk</em> tylko na niektórych, portach
          kanału.</li>
        <li>Zakres sieci VLAN na wszystkich portach kanału nie jest taki sam.</li>
        <li>Pomieszano protokoły z jednej lub z drugie strony kanału.</li>
      </ul>
      <p>
        Istnieje kilka taki stałych kroków, które mogą pomóc nam rozwiązać
        problemy związane z działaniem <em>EtherChannel</em>.
      </p>
      <ol>
        <li>Wyświetl informacje na temat <em>EtherChannel</em>
          (<code class="code-inline">show etherchannel summary</code>)</li>
        <li>Zobacz konfigurację kanału portów
          (<code class="code-inline">show run | begin interface port-channel</code>)</li>
        <li>Popraw błedy w konfiguracji. Tutaj się warto chwilę zatrzymać,
          ponieważ <em>EtherChannel</em> - jej konfiguracja strasnie nie lubi
          nadpisywania. Jeśli już musimy poprawić grupę (kanał) to
          należy na początku usunąć go za pomocą polecenia:
          <code class="code-inline">no interface port-channel X</code>, gdzie
          <code class="code-inline">X</code> jest numerem grupy. Człon
          <code class="code-inline">port-chanel X</code> można skrócić do
          <code class="code-inline">poX</code>. Po usunięciu grupy można
          przystąpić do jej ponownej konfiguracji.</li>
        <li>Zweryfikuj czy <em>EtherChannel</em> działa.</li>
      </ol>
      <h3 id="2.6.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/6.3.4-packet-tracer---troubleshoot-etherchannel_pl-PL.pdf">Rozwiązywanie problemów z EtherChannel - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/6.3.4-packet-tracer---troubleshoot-etherchannel_pl-PL.pka">Rozwiązywanie problemów z EtherChannel - zadanie</a>
      </p>
      <h2 id="2.6.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale dowiedzieliśmy, jak w efektywny sposób wykorzystać
        dodatkowe łącza nadmiarowe stosując technologię agregacji -
        <em>EtherChannel</em>. Poznaliśmy sposób działania tej technlogii,
        metody konfiguracji w systemie IOS oraz rozwiązywanie związanych z nią
        problemów.
      </p>
      <h3 id="2.6.4.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/6.4.1-packet-tracer---implement-etherchannel_pl-PL.pdf">Implementacja EtherChannel</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/6.4.1-packet-tracer---implement-etherchannel_pl-PL.pka">Implementacja EtherChannel</a>
      </p>
      <!--<h2 id="2.6.partialexam">Egzamin cząstkowy - Rozdziały: 5 - 6</h2>
      <p>
        <a href="Cisco_-_CCNA_-_SRWE_-_egzamin_czastkowy_roz_5_-_6.html">Egzamin z nadmiarowosci w sieci</a>
      </p>-->
      <h1 id="2.7.dhcpv4">2.7. DHCPv4</h1>
      <p>
        Komputery w sieci, tak jak my ludzie potrzebujemy adresów, żeby
        otrzymywać móc wysyłać i odbierać komunikaty. Komputerom w sieci
        możemy przypisać adresy ręcznie - co nazwane jest
        <strong>statyczną</strong> konfiguracją hosta, bądź też wykorzystać
        do tego odpowiednie oprogramowanie, które pozwoli na zautomatyzowanie
        procesu oraz na bezobsługowe zarządzanie nim. Jedyną czynnością będzie
        konfiguracja protokołu
        <strong><em>Dynamic Host Configuration Protocol</em></strong>. Za
        konfigurację hostów sieci odpowiada konkretny protokół, który
        dynamicznie przydziela (dzierżawi) adres IPv4 z puli dostępnych
        adresów, na określony czas lub do momentu kiedy host już go nie
        potrzebuje. Czas dzierżawy może być zdefiniowany przez administratora,
        najczęściej są to 24 godziny.
      </p>
      <p>
        Serwer DHCP działa na zasadzie architektury klient-serwer. Serwerami
        DHCP, może być dedykowane oprogramowanie instalowane na dystrybucjach
        Linuksa oraz na systemach MS Windows. Urządzenia z systemem IOS takie
        jak routery, czy przełączniki warstwy 3 mogą również pełnić rolę
        serwera DHCP o czym się przekonamy w dalszej części tego materiału.
      </p>
      <p>
        Komputer będąc skonfigurownym w ten sposób, aby otrzymywał adres
        autotomatycznie, komunikuje się z serwerem DHCP. Między hostami
        wymieniane są komunikaty protokóło, rezultatem czego jest 
        wydzierżawienie
        adresu IP dla tego hosta. Jeśli czas dzierżawy dobiega końca, host
        komunikuje się z serwerem w celu odnowienia dzierżawy, jeśli klient
        nie skontaktuje się z serwerem w odpowiednim czas, dzieżawa wygasa, a
        adres trafia z powrotem do <strong>puli</strong> - zakresu adresów,
        przeznaczonych dla tej sieci - i może zostać wydzierżawiony innym
        hostom. Ten mechanizm pozwala na zwolnienie adresów, które hosty już
        nie potrzebują, bo są np. wyłączone.
      </p>
      <p>
        Wymiana komunikatów protokołu DHCP w celu uzyskania dzierżawy wygląda
        w następujący sposób:
      </p>
      <ol>
        <li>Klient wysyła ramkę <em>broadcast</em>, zawierającą komunikat
          <strong>DHCPDISCOVER</strong>. Klient nie ma adresu IP stąd ten
          <em>broadcast</em>. Ten komunikat mówi, że dany host szuka serwera
          DHCP.</li>
        <li>Serwer odpowiada klientowi, za pomocą komunikatu
          <strong>DHCPOFFER</strong>, przedstawiając mu już konkretną ofertę
          adresu jaki dostanie.</li>
        <li>Klient potwierdza dzierżawę adresu za pomocą komunikatu
          <strong>DHCPREQUEST</strong> wysyłanego w ramce
          <em>broadcast</em>. Mimo, że host mógłby wysłać ten komunikat
          prosto do serwera, z którego otrzymał ofertę, to nie robi tego.
          Ponieważ w sieciach może istnieć więcej niż jeden serwer DHCP.
          Wysłanie DHCPREQUEST na <em>broadcast</em>, przekaże informacje
          innym serwerom DHCP, że host przyją ofertę innego serwera, więc
          tamte serwery mogą przywrócić proponowany adres z powrotem do puli.
        </li>
        <li>Serwer na koniec wysła potwierdzenie akceptacji w postaci 
          komunikatu
          <strong>DHCPACK</strong>. Teoretycznie komunikacja z serwerem DHCP
          tutaj się kończy, ale klient wykonuje jescze jedną czynność.</li>
      </ol>
      <p>
        Mianowicie wysyła pakiet ARP z zapytaniem o przydzielony mu właśnie
        adres. Może zdażyć się taka sytuacja, że mamy część komputerów
        skonfigurowanych ze statycznymi adresami, a część z dynamicznymi.
        A na serwerze DHCP nie dokonano odpowiednich wykluczeń z puli.
        Wówczas serwer DHCP, będzie przydzielać adresy, które już funkcjonują
        w sieci. Wtedy dochodzi do konfilktu adresów IP.
      </p>
      <p>
        Odnowienie adresu IP, skraca powyższą procedurę do dwóch ostatnich
        komunikatów. Klient prosi o odnowienie adresu za pomocą komunikatu
        DHCPREQUEST, a natomiast serwer odpowiada za pomocą DHCPACK.
      </p>
      <h2 id="2.7.1.dhcpv4serveronios">2.7.1. Konfiguracja serwera DHCPv4 na Cisco IOS</h2>
      <p>
        Poznaliśmy niezbędną teorie, to teraz możemy zmusić IOS, nie tylko na
        routerze, ale i na przełącznikach też - do pełnienia funkcji serwera
        <em>DHCPv4</em>.  
      </p>
      <p>
        Możemy tego dokonać za pomocą kilku kroków. Pierwszą czynnością będzie
        uwzględnienie ewentualnych urządzeń z ustawionymi statycznym adresami
        IP. Należy dokonać konkretnych wykluczeń, podając zakres adresów,
        które nie będą przydzielane. Mimo, że nie mamy jeszcze zdefiniowanej
        puli adresowej to już na samym początku konfiguracji możemy podać
        tego typu informacje.
      </p>
<pre class="code-block">
Router(config)#ip dhcp excluded-address 192.168.10.1 192.168.10.10
</pre>
      <p>
        Zakres adresów do wyłączenia przekazujemy podając pierwszy i ostatni
        adres. Chcąc wyłączyć jeden pojedynczy adres, podajemy go zaraz
        po słowie <code class="code-inline">excluded-address</code>. 
        Następnym krokiem jest zdefiniowanie puli. W definicji puli podajemy
        dodatkowe adresy IP jakie host powinien mieć w swojej konfiguracji,
        takie jak adres bramy czy adresy serwerów DNS. Tworzenie puli
        rozpoczyna się od wydania poniższego polecenia.
      </p>
<pre class="code-block">
Router(config)#ip dhcp pool LAN10
</pre>
      <p>
        Po wydaniu tego polecenia zostaniemy przeniesieni do trybu konfiguracji
        puli. W tym trybie podajemy sieć na podstawie, której zostanie
        utworzona pula adresów.
      </p>
<pre class="code-block">
Router(dhcp-config)#network 192.168.10.0 255.255.255.0
</pre>
      <p>
        Następnie dodajemy adres bramy domyślnej oraz serwera DNS:
      </p>
<pre class="code-block">
Router(dhcp-config)#default-router 192.168.10.1
Router(dhcp-config)#dns-servers 8.8.8.8
</pre>
      <p>
        Po wykonaniu tych czynności, możemy opuścić konfigurację. Serwer DHCP
        został skonfigurowany i jest on operacyjny. Możemy to sprawdzić
        ustawiając jeden z interfejsów routera i podłączając do niego komputer.
      </p>
<pre class="code-block">
C:\&gt;ipconfig /all

FastEthernet0 Connection:(default port)

   Connection-specific DNS Suffix..: 
   Physical Address................: 0002.1661.4A3D
   Link-local IPv6 Address.........: FE80::202:16FF:FE61:4A3D
   IPv6 Address....................: ::
   IPv4 Address....................: 192.168.10.11
   Subnet Mask.....................: 255.255.255.0
   Default Gateway.................: ::
                                     192.168.10.1
   DHCP Servers....................: 192.168.10.1
   DHCPv6 IAID.....................: 
   DHCPv6 Client DUID..............: 00-01-00-01-64-36-79-72-00-02-16-61-4A-3D
   DNS Servers.....................: ::
                                     8.8.8.8
</pre>
      <p>
        Teraz kiedy nasz serwer DHCP został skonfigurowany i działa, to możemy
        poznać polecenia, które pozwalą nam sprawdzić informacje odnośnie
        działania DHCP w IOS.
      </p>
      <ul>
        <li><code class="code-inline">show running-config | section dhcp</code>
          - to polecenie filtruje wyświetlenie bierzącej konfiguracji po
          kątem występowania sekcji <code class="code-inline">dhcp</code>.
          Jeśli polecenie zawiera to słowo kluczowe i samo w sobie nie tworzy
          sekcji, to również zostanie uwzględnione przez ten filtr.
<pre class="code-block">
Router#show running-config | section dhcp
ip dhcp excluded-address 192.168.10.1 192.168.10.10
ip dhcp pool LAN10
 network 192.168.10.0 255.255.255.0
 default-router 192.168.10.1
 dns-server 8.8.8.8
</pre>
        </li>
        <li><code class="code-inline">show ip dhcp binding</code> - polecenie
          wyświetla listę dzierżaw serwera DHCP.</li>
<pre class="code-block">
Router#show ip dhcp binding
IP address       Client-ID/              Lease expiration        Type
                 Hardware address
192.168.10.11    0002.1661.4A3D           --                     Automatic
</pre>
        </li>
        <li><code class="code-inline">show ip dhcp server statistics</code> -
          polecenie zwraca statystyki na temat serwera DHCP. Na Packet Tracerze
          to polecenie jest niedostępne, przynajmniej w wersji 8.2.2.</li>
      </ul>
      <p>
        Konfiguracja serwera DHCP wydaje się prosta, w momecie gdy znajduje
        sie on w tej samej sieci lokalnej. A co jeśli będzie znajdować się w
        innej sieci? <em>Broadcast</em> ramek <em>Ethernet</em> nie może 
        przecież
        być routowany. Tutaj wymyślono coś takiego jak adres pomocnika.
        Na interfejsie, który normalnie by oczekiwał na komunikaty
        DHCPDISCOVER, konfigurujemy adres serwera DHCP w innej sieci. Tworząc
        z tego interfejsu coś w rodzaju przekaźnika.
      </p>
<pre class="code-block">
Router(config-if)#int gig0/0
Router(config-if)#ip helper-address 192.168.11.2
Router(config-if)#end
</pre>
      <p>
        W tym przypadku serwer DHCP ma adres
        <code class="code-inline">192.168.11.2</code>. Poza komunikatami DHCP
        za pomocą tego mechanizmu mogą być przekazywane komunikaty usługi DNS
        czy NTP, generalnie te usługi sieciowe, które wykorzystują UDP.
      </p>
      <h3 id="2.7.1.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/7.2.10-packet-tracer---configure-dhcpv4_pl-PL.pdf">Konfiguracja DHCPv4 - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/7.2.10-packet-tracer---configure-dhcpv4_pl-PL.pka">Konfiguracja DHCPv4 - zadanie</a>
      </p>
      <h2 id="2.7.2.iosdhcpclient">2.7.2. Konfiguracja klient DHCP w systemie Cisco IOS</h2>
      <p>
        Konfiguracja interfejsu urządzenia z systemem Cisco IOS jako klienta
        DHCP, jest banalnie prosta. Sprowadzania się ona do wydania
        dwóch/trzech poleceń. Już wcześniej konfigurowaliśmy statyczne adresy
        IP, np. na interfejsach VLAN 1 przełączników. To w tym przypadku
        sprawa ma się podobnie. Wystarczy, że zamiast wpisywania adresu IP oraz
        maski podamy jedno słowo - <em>dhcp</em>.
      </p>
<pre class="code-block">
Switch(config)#int vlan 1
Switch(config-if)#ip address
Switch(config-if)#ip address dhcp
Switch(config-if)#no shutdown
Switch#sh ip int br | section Vlan1
Vlan1                  192.168.10.4    YES DHCP   up                    up
</pre>
      <h2 id="2.7.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy z działaniem protokołu automatycznej
        konfiguracji hosta w wersji 4 - DHCPv4. Dowiedzieliśmy się jak możemy
        wykorzystać system Cisco IOS w roli serwera DHCP, przekaźnika oraz
        na koniec klienta.
      </p>
      <h3 id="2.7.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/7.2.10-packet-tracer---configure-dhcpv4_pl-PL.pdf">Konfiguracja DHCPv4 - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/7.2.10-packet-tracer---configure-dhcpv4_pl-PL.pdf">Konfiguracja DHCPv4 - zadanie</a>
      </p>
      <h3 id="2.7.3.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/7.4.2-lab---implement-dhcpv4_pl-PL.pdf">Wdrożenie DHCPv4</a>
      </p>
      <h1 id="2.8.slaacanddhcpv6">2.8. SLAAC i DHCPv6</h1>
      <p>
        Podobnie do IPv4, mamy możliwość zarówno statycznej jak i dynamicznej
        konfiguracji interfejsów sieciowych dla IPv6. Przy czym, znając budowę
        adresów IPv6, nie wiadomo czy ktoś będzie chciał to robić ręcznie. A w
        przypadku konfiguracji dynamicznej mamy do wykorzystania trzy metody. 
      </p>
      <ul>
        <li>Metoda autokonfiguracji - <strong>SLAAC</strong></li>
        <li>Metoda bezstanowego serwera DHCP - <strong>Stateless DHCPv6</strong></li>
        <li>Metoda stanowowego serwera DHCP - <strong>Stateful DHCPv6</strong></li>
      </ul>
      <p>
        Omówimy sobie pokolei te metody, a następnie zabierzemy się 
        do konfigurowania każdej z nich w systemie Cisco IOS.
      </p>
      <p>
        Za nim jednak do tego przjedziemy, krótkie przypomnienie o IPv6. Adres
        IPv6 ma długość 128 bitów, składa się z 8 hekstetów po 4 cyfyry
        heksadecymalne. Adresy IPv6 dzielą się na dwie grupy
        <strong>GUA</strong> (<em>Global Unicast Address</em>), rozpoczynające
        się od prefiksu: 2000::/3 oraz <strong>LLA</strong>
        (<em>Local Link Address</em>), rozpoczynające się od prefiksu
        fe80::/10. W przypadku IPv6 do określenia części sieciowej adresu IP
        wykorzystuje tzw. <strong>prefiks</strong> - zarezerwowana liczba
        bitów. W przypadku adresów <em>unicast</em> przeważnie adres dzieli się
        na pół - prefiks ma długość 64 bitów. Drugie pół adresu IPv6 określa
        już sam host generując wartości pseudolosowe (w przypadku systemów
        MS Windows) lub korzystając z algorytmu EUI-64. Ta część
        adresu nazwana jest <strong>identyfikatorem hosta</strong>
        Adresy GUA służą do komunikacji
        w Internecie, natomiast adresy LLA, ograniczają się do jednej domeny
        rozgłoszeniowej. Każdy komputer posiada dwa adresy przypisane do
        swojego interfejsu. Przez co każdy komputer może być w prosty sposób
        osiągalny z poziomu Internetu. Urządzenia mają również zapisane
        adresy typu <em>multicast</em> - ff02::1 - adres wszystkich hostów
        obsługujących IPv6 oraz ff02::2 - adres wszystkich routerów z
        routingiem IPv6. Te adresy bedą mieć znaczenie przy dynamicznej
        adresacji hostów. Dynamiczna adresacja hostów, będzie dotyczyć
        wyłącznie adresów GUA. Adresy LLA, są konfigurowane automatycznie na
        hostach.
      </p>
      <h2 id="2.8.1.slaac">2.8.1. SLAAC</h2>
      <p>
        Protokół IPv6, znacznie bardziej angażuje protokół ICMP w wersji 6 do
        pracy niż miało to miejsce w przypadku IPv4 i ICMPv4. Założenie
        IPv6 jak i metody konfiguracji <strong>SLAAC</strong> było takie, że
        gdzie w sieci musi być jakiś router, i jednym z jego zadań jest
        wysłanie co 200 sek komunikatu protokołu ICMPv6 zawierającego takie
        informacje jak:
      </p>
      <ul>
        <li><strong>Flagi</strong> - zbiór bitów, mówiących hostowi w jaki
          sposób będzie konfigurować adres IPv6 w tej sieci.</li>
        <li><strong>Prefiks</strong> - część sieciowa adresu IPv6.</li>
        <li><strong>Długość prefiksu</strong> - długość częsci sieciowej
          adresu IPv6.</li>
      </ul>
      <p>
        Komunikat ten nosi nazwę <em>Router Advertisement</em>, w skrócie
        <strong>RA</strong>. Host po podłączeniu do sieci może wysłać
        inny komunikat ICMPv6 - <em>Router Solicitation</em> - 
        <strong>RS</strong>, który jest prośbą o wysłanie przez router
        komunikatu RA. Komunikaty RS jako adres docelowy wykorzystują adres
        <em>multicast</em> grupy routerów. 
      </p>
      <p>
        Flagi przekazywane w komunikacie RA, wskazują hostowi w jaki sposób
        będzie odbywać się konfiguracji interfejsu IPv6 w tej sieci. Możemy
        wyróżnić takie flagi jak:
      </p>
      <ul>
        <li><strong>M</strong> (<em>Managed</em>) - oznacza ona, że 
        konfiguracja IPv6 będzie odbyć się przy użyciu serwera DHCPv6
        (W nomenklaturze CCNA, stanowego serwera DHCPv6).</li>
        <li><strong>O</strong> (<em>Other</em>) - oznacza ona, że tylko
        dodatkowe informacje takie jak adresy serwerów DNS, będą dostarczane
        przez serwer DHCPv6. (W nomenklaturze CCNA, bezstanowy serwer DHCPv6)</li>
        <li><strong>A</strong> (<em>Autoconfiguration</em>) - oznacza ona,
        że adres IPv6 będzie uzyskiwany metodą autokonfiguracji - SLAAC.
        (Dokument RFC 1970, mówi że ta flaga, znajduje się w sekcji opcji
        odpowiedzialnej za informacje na temat prefiksu, a nie w samym RA
        stricte.)</li> 
      </ul>
      <p>
        Zatem jeśli host otrzyma komunikat RA z ustawiowymi flagami M=0, O=0
        oraz z flagą A=1, w <em>prefix information</em> - oznacza to, że adres
        musi on sobie ustawić sam. Dokonuje tego przy użyciu prefiksu i jego
        długości z komunikatu RA oraz przy użyciu samodzielnie wygenerowanego
        identyfikatora hosta. Czy użyje metod pseudolosowych czy algorytmu
        EUI-64, to już zależy od systemu operacyjnego. Przy czym tak
        wygenerowany należy adres, należy sprawdzić. Szanse są nikłe, ale ta
        czynność jest wykonywana, rozsyłane są między hostami komunikaty ICMPv6
        NA (<em>Neighbor Advertisement</em>) oraz NS
        (<em>Neighbor Solicitation</em>) - co ma być odpowiednikiem protokołu
        ARP. Host wysła komunikat NS na swój
        wygenerowany adres i jeśli odpowiedź nie nadejdziej oznacza to, że
        adres jest operacyjny i może go użyć. W ten sposób działa mechanizm
        <strong>DAD</strong> (<em>Duplicate Address Detection</em>).
      </p>
      <p>
        Ta metoda zapewnia podstawową konfigurację sieciową, pozwalająca na
        komunikację z hostem. Jednak jeśli był by to zwykły komputer klasy PC,
        z którego ma korzystać człowiek, to brakuje informacji takich jak
        adresy serwerów DNS, aby móc korzystać zasobów sieci firmy czy
        Internetu.
      </p>
      <h2 id="2.8.2.statelessdhcpv6">2.8.2. Metoda bezstanowego serwera DHCPv6</h2>
      <p>
        Metoda ta działa na zasadzie uzupełnienia konfiguracji interfesów
        sieciowych IPv6, wstępnie skonfigurowanych przez metodę SLAAC. Dlatego
        też możemy spotkać się określeniem SLAAC+DHCPv6. Działanie tej metody
        zakłada, że w sieci znajduje się serwer DHCPv6, mimo to host dalej
        będą korzystać informacji zawartych w RA, następnie po proszą serwer
        DHCPv6 o uzupełnienie informacji dodatkowych.
      </p>
      <p>
        W przypadku metody bezstanowego serwera DHCPv6, host odbiera RA z
        ustawioną flagą M=0, O=1 i A=1. Ustawia on swoje podstawowe parametry
        sieciowe, na podstawie informacji zawartych komunikacie (poprzez użycie
        SLAAC) następnie host wysła <strong>DHCPv6 SOLICIT</strong> w celu
        odnalezienia serwera DHCP (coś w rodzaju, DHCPDISCOVER) w odpowiedzi
        otrzymuje <strong>DHCPv6 ADVERTISE</strong>, z informacją że jest
        serwer taki, a taki i obsługuje on protokoł DHCPv6. To wówczas
        host wysła komunikat <strong>DHCPv6 INFORMATION-REQUEST</strong> już
        na adres serwera uzyskany z poprzeniego pakietu. W odpowiedzi uzyska
        komunikat <strong>DHCPv6 REPLY</strong> o treści odpowiedniej dla
        <em>DHCPv6 INFORMATION-REQUEST</em>. 
      </p>
      <h2 id="2.8.3.statefulldhcpv6">2.8.3. Metoda stanowego serwera DHCPv6</h2>
      <p>
        Mimo, że SLAAC+DHCPv6, rozwiązuje problemy z niepełną konfiguracją z
        komunikatów RA, wykorzystywanych przez SLAAC, to w sieciach firmowych
        chcielibyśmy mieć kontrolę, chociażby nad tym, kto się podłacza do
        naszej sieci. Dlatego też wprowadzono metodę: stanowego serwera
        DHCPv6, którego działanie jest podobne do serwera DHCPv4.
      </p>
      <p>
        Host wysła komunikat RS, lub udaje mu się odebrać komunikat RA. W nim
        flagi są ustawione: M=1, O=0, A=0. Możemy się czasami spotkać z
        twierdzeniem, że flagi O, nie ma w ogóle, ale jest to raczej błąd. Tak
        ustawione flagi mówią hostowi, że ma korzystać z serwera DHCPv6. To
        host rozpoczyna wymianę pakietów, podobną do metody bezstanowowej, a
        różniącej się tym, że nie korzysta on z informacji zawartych w RA
        (wszystkich), tylko rozpoczyna poszukiwanie serwera DHCPv6. Główną
        różnicą między tymi metodami jest użycie komunikatu
        <strong>DHCPv6 REQUEST</strong>, zamiast <em>INFORMATION-REQUEST</em>.
        Inna również będzie treść wiadomości <em>DHCPv6 REPLY</em>.
      </p>
      <p>
        Ważną informacją obejmującą wszystkie metody dynamicznej konfiguracji
        IPv6 jest to, że hosty <strong>będą korzystać z adresu <em>link-local</em>
        routera (adresu źródłowego komunikatu RA) jako bramy domyślnej</strong>.
        Nie będą korzystać z informacji przekazywanych nawet przez serwer
        DHCPv6.
      </p>
      <h2 id="2.8.4.configurationdhcpv6onios">2.8.4. Konfiguracja DHCPv6 na Cisco IOS</h2>
      <p>
        System operacyjny Cisco IOS, jest wstanie świadczyć usługę DHCP
        również dla IPv6. Przeprowadzimy następujące konfigurację:
      </p>
      <ul>
        <li>Bezstanowego DHCPv6</li>
        <li>Stanowego DHCPv6</li>
        <li>Klienta DHCPv6</li>
        <li>Agenta przekazywania</li>
      </ul>
      <p>
        W przypadku bezstanowego serwera DHCP, na routerze w pierwszej
        kolejności włączamy routing IPv6. Zawsze jest on domyślnie wyłączony.
      </p>
<pre class="code-block">
Srv-DHCPv6(config)#ipv6 unicast-routing 
</pre>
      <p>
        Następnie definiujemy nowa pulę adresów. 
      </p>
<pre class="code-block">
Srv-DHCPv6(config)#ipv6 dhcp pool IPV6-STATELESS
</pre>
      <p>
        Konfigurujemy pule, dodając te opcje, które chcemy aby klienci naszej
        sieci otrzymywali z serwera DHCPv6.
      </p>
<pre class="code-block">
Srv-DHCPv6(config-dhcpv6)#dns-server 2001:db8:acad:1::254
Srv-DHCPv6(config-dhcpv6)#domain-name example.com
</pre>
      <p>
        Teraz musimy przypisać pulę do interfejsu, ale także zmodyfikować
        flagę w komunikatach RA. Dokonujemy tego za pomocą poniższych 
        poleceń.
      </p>
<pre class="code-block">
Srv-DHCPv6(config-if)#ipv6 nd other-config-flag
Srv-DHCPv6(config-if)#ipv6 dhcp server IPV6-STATELESS
</pre>
      <p>
        Pierwsze polecenie:
        <code class="code-inline">ipv6 nd other-config-flag</code> ustawia
        flagę <strong>O</strong> w komunikatach RA. Natomiast drugie polecenie:
        <code class="code-inline">ipv6 dhcp server IPV6-STATELESS</code>
        przypisuje pulę interfejsu. Teraz możemy skonfigurować klienckiego
        PC-ta, aby pobrał konfigurację IPv6 z naszej infrastruktury.
      </p>
<pre class="code-inline">
Cisco Packet Tracer PC Command Line 1.0
C:\&gt;ipconfig /all

FastEthernet0 Connection:(default port)

   Connection-specific DNS Suffix..: example.com 
   Physical Address................: 0060.4784.E138
   Link-local IPv6 Address.........: FE80::260:47FF:FE84:E138
   IPv6 Address....................: 2001:DB8:ACAD:1:260:47FF:FE84:E138
   IPv4 Address....................: 0.0.0.0
   Subnet Mask.....................: 0.0.0.0
   Default Gateway.................: FE80::1
                                     0.0.0.0
   DHCP Servers....................: 0.0.0.0
   DHCPv6 IAID.....................: 1699464132
   DHCPv6 Client DUID..............: 00-01-00-01-61-90-B4-E8-00-60-47-84-E1-38
   DNS Servers.....................: 2001:DB8:ACAD:1::254
                                     0.0.0.0
</pre>
      <p>
        Konfiguracja PC-ta, jest banalna wystarczy kliknąć jedną opcje. A co
        w przypadku systemu Cisco IOS? Spróbujmy to zrobić, wykorzystując do
        tego drugi router. Po przejściu do konfiguracji globalnej, włączamy
        routing IPv6.
      </p>
<pre class="code-block">
Cli-DHCPv6(config)#ipv6 unicast-routing
</pre>
      <p>
        Następnie włączamy IPv6 na interfejsie sieciowym i ustawiamy aby
        pobrał on konfigurację z DHCP. Na koniec podnosimy interfejs.
      </p>
<pre class="code-block">
Cli-DHCPv6(config)#ipv6 unicast-routing
Cli-DHCPv6(config)#int gig0/0/1
Cli-DHCPv6(config-if)#ipv6 enable
Cli-DHCPv6(config-if)#ipv6 address autoconfig
Cli-DHCPv6(config-if)#no shut
Cli-DHCPv6(config-if)#end
Cli-DHCPv6#sh ipv6 int br
GigabitEthernet0/0/0       [administratively down/down]
    unassigned
GigabitEthernet0/0/1       [up/up]
    FE80::201:64FF:FE98:9802
    2001:DB8:ACAD:1:201:64FF:FE98:9802
GigabitEthernet0/0/2       [administratively down/down]
    unassigned
Vlan1                      [administratively down/down]
    unassigned
Cli-DHCPv6#sh ipv6 dhcp interface
GigabitEthernet0/0/1 is in client mode
  State is INFORMATION-REQUEST(0)
  Rapid-Commit: disabled
</pre>
      <p>
        Ostatnie dwa polecenia:
        <code class="code-inline">sh ipv6 int br</code>
        (<code class="code-inline">show ipv6 interface brief</code>) oraz
        <code class="code-inline">sh ipv6 dhcp interface</code> mogą nam
        posłużyć do sprawdzenia konfiguracji IPv6 interfejsów oraz konfiguracji
        DHCPv6 interfejsu. W tym przypadku na podstawie wyjścia drugiego
        polecenia, może stwiedzić, że działa on w trybie bezstanowego serwera
        DHCPv6.
      </p>
      <p>
        Kolejny rodzajem konfiguracji jaki możemym przeprowadzić jest stanowy
        serwer DHCPv6 oraz stanowy klient. Konfiguracja dla serwera wygląda
        w następujący sposób:
      </p>
<pre class="code-block">
Srv2-DHCPv6(config)#ipv6 unicast-routing
Srv2-DHCPv6(config)#ipv6 dhcp pool IPV6-STATEFUL
Srv2-DHCPv6(config-dhcpv6)#address prefix 2001:db8:acad:1::/64
Srv2-DHCPv6(config-dhcpv6)#dns-server 2001:4860:4860::8888
Srv2-DHCPv6(config-dhcpv6)#domain-name example.com
Srv2-DHCPv6(config-dhcpv6)#exit
Srv2-DHCPv6(config)#int gig0/0/1
Srv2-DHCPv6(config-if)#ipv6 addr 2001:db8:acad:1::1/64
Srv2-DHCPv6(config-if)#ipv6 addr fe80::1 link-local
Srv2-DHCPv6(config-if)#ipv6 nd managed-config-flag
Srv2-DHCPv6(config-if)#ipv6 dhcp server IPV6-STATEFUL
Srv2-DHCPv6(config-if)#no shutdown
</pre>
      <p>
        Konfigurując IOS jako serwer stanowy DHCPv6, musimy w definicji puli
        wpisać prefiks naszej sieci. Następnie w konfiguracji interfejsu
        ustawiamy flagę <strong>M</strong> i przypisujemy odpowiednią do
        interfejsu pulę DHCPv6. Reszta konfiguracji pozostaje bez zmian.
      </p>
      <p>
        W materiałach występuje jeszcze jedno polecenie:
        <code class="code-inline">ipv6 nd prefix default no-autoconfig</code>
        jednak może być ono niedostępne w wersjach oprogramowania IOS
        dostarczanych wraz z Packet Tracer-em. 
      </p>
      <p>
        Natomiast konfiguracja stanowego klienta wygląda w opisany poniżej
        sposób.
      </p>
<pre class="code-block">
Cli2-DHCPv6(config)#ipv6 unicast-routing
Cli2-DHCPv6(config)#int gig0/0/1
Cli2-DHCPv6(config-if)#ipv6 enable
Cli2-DHCPv6(config-if)#ipv6 address dhcp
Cli2-DHCPv6(config-if)#no shutdown
Cli2-DHCPv6#sh ipv6 int br
GigabitEthernet0/0/0       [administratively down/down]
    unassigned
GigabitEthernet0/0/1       [up/up]
    FE80::201:96FF:FEB3:8A02
    2001:DB8:ACAD:1:D0CF:E066:3BF5:2825
GigabitEthernet0/0/2       [administratively down/down]
    unassigned
Vlan1                      [administratively down/down]
    unassigned
Cli2-DHCPv6#sh ipv6 dhcp interface
GigabitEthernet0/0/1 is in client mode
  State is OPEN
  Renew will be sent in 0d0h
  List of known servers:
    Reachable via address: FE80::1
    DUID: 0003000100062ACD7E01
    Preference: 0
    Configuration parameters:
      IA PD: IA ID 226950255, T1 0, T2 0
      Address: 2001:DB8:ACAD:1:D0CF:E066:3BF5:2825/64
              preferred lifetime 86400, valid lifetime 172800
              expires at September 7 2024 3:47:3 pm (172800 seconds)
      DNS server: 2001:4860:4860::8888
      Domain name: example.com 
      Information refresh time: 0
  Prefix name: 
  Rapid-Commit: disabled
</pre>
      <p>
        W taki sposób wygląda to od strony serwera:
      </p>
<pre class="code-block">
Srv2-DHCPv6#show ipv6 dhcp interface 
GigabitEthernet0/0/1 is in server mode
  Using pool: IPV6-STATEFUL
  Preference value: 0
  Hint from client: ignored
  Rapid-Commit: disabled
Srv2-DHCPv6#show ipv6 dhcp binding 
Client: FE80::201:96FF:FEB3:8A02
  DUID: 00030001000196B38A01
  IA NA: IA ID 226950255, T1 0, T2 0
    Address: 2001:DB8:ACAD:1:D0CF:E066:3BF5:2825
            preferred lifetime 86400, valid lifetime 172800
            expires at September 7 2024 3:50:18 pm (172800 seconds)
Srv2-DHCPv6#show ipv6 dhcp pool 
DHCPv6 pool: IPV6-STATEFUL
  Address allocation prefix: 2001:db8:acad:1::/64 valid 172800 preferred 86400 (2 in use, 0 conflicts)
  DNS server: 2001:4860:4860::8888
  Domain name: example.com
  Active clients: 1
</pre>
      <p>
        <code class="code-inline">binding</code>, przedstawia listę klientów
        serwera DHCPv6. Natomiast <code class="code-inline">pool</code>,
        pokazuje nam statystyki oraz opcje dodane do utworzynych na serwerze
        pul adresowych.
      </p>
      <p>
        Ostatnią konfiguracją będzie konfiguracja agenta przekazującego.
        Nie mniej jednak na Packet Tracerze, nie będziemy w stanie tego zrobić.
        Dlatego można potraktować to jako suchą wiedzę. Na interfejsie
        nasłuchującym w sieci, z którego normalnie powinniśmy otrzymać adres IP
        wpisujemy poniższe polecenie.
      </p>
<pre class="code-block">
 Rly-DHCPv6(config)#int gig0/1
Rly-DHCPv6(config-if)#ipv6 dhcp ?
  client  Act as an IPv6 DHCP client
  server  Act as an IPv6 DHCP server
Rly-DHCPv6(config-if)#ipv6 dhcp relay destination 2001:db8:acad:1::2 gig0/0
                                ^
% Invalid input detected at '^' marker.
	
Rly-DHCPv6(config-if)#exit
</pre>
      <p>
        W poleceniu <code class="code-inline">relay destination</code>
        podajemy adres serwera. Dodatkowo, jeśli adresem serwera DHCP będzie
        LLA, musimy podać wyjściowy interfejs taki jak na przykładzie
        (<code class="code-inline">gig0/0</code>).
      </p>
      <h3 id="2.8.4.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/8.5.1-lab---configure-dhcpv6_pl-PL.pdf">Konfiguracja DHCPv6</a>
      </p>
      <h2 id="2.8.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale dowiedzieliśmy się jak wyglądają metody dynamicznej
        adresacji hostów dla protokołu IPv6. Poznaliśmy w jaki sposób te
        metody działają oraz jakie komunikaty klient oraz serwer (w zależności
        od metody) ze sobą wymieniają aby finalnie skonfigurować adres IPv6 dla
        interfejsu. Na koniec poznaliśmy jakie w tym zakresie możliwości ma
        system Cisco IOS oraz jakim <em>crapem</em> są materiały, w których 
        funkcjonuje jedno zagadnienie, a nie jest ono możliwe do zrealizowania
        w środowisku symulacyjnym jakim jest Packet Tracer. Nie prościej było
        to usunąć lub poprawić tego Packet Tracer-a. Czy to tak wiele dla tak
        dużej firmy?
      </p>
      <h1 id="2.9.fhrpconcepts">2.9. Koncepcje FHRP</h1>
      <p>
        Po zakończeniu omawiania VLAN-ów, zaczeliśmy rozmiawiać o metodach
        pozwalających na istnienie łączy nadmiarowych bez ryzka powstawania
        pętli. Później stwierdziliśmy, że w przypadku kilku łączy nadmiarowych
        normalnie wykorzystywana jest tylko ich część, co nie za bardzo nam
        się niepodobało - chcielśmy wykorzystać je wszystkie lub przynajmniej
        większą część, zatem zaczeliśmy agregować te łącza. Mimo tak zbudowanej
        topologii, to gdzieś tam na jej górze znajduje się router brzegowy,
        który łączy naszą sieć z inną siecią, np. z Internetem. Zastanówmy się
        przez chwilę co w takiej topologii pozostaje słabym ogniwem? Takie
        rozwiązania, które nie mają zapewnionej nadmiarowości. W tym przypadku
        jest to nasz router, który umożliwia dostęp do zasobów zewnętrznych
        sieci.
      </p>
      <p>
        Oczywiście możemy zapewnić dodatkowy router, podłączony do sieci
        usługodawcy, mnie mniej jednak, co w przypadku awarii podstawowego
        routera czy będziemy zmieniać na komputerach klientów adresy bramy
        lub wymuszać na nich ponowne skomunikowanie się z serwerem DHCP?
        Istnieją metody przełączania między routerami pozostające dla
        użytkowników końcowych niewidoczne. Tego rodzaju rozwiązania są
        zapewniane przez protokoły <strong>FHRP</strong>
        (<em>First Hop Redundancy Protocol</em>).
      </p>
      <p>
        Działa to na na takiej zasadzie, że routery wymienią ze sobą komunikaty
        w zależności od rodzaju protokołu. FHRP to nazwa zbiorcza dla
        technologii, która zbiera pod sobą kilka różnych protokołów.
        Na podstawie wymienionych informacji między sobą decydują o tym, który
        z nich będzie urządzeniem przekazującym lub urządzeniem pasywnym,
        pozostającym w gotowości. Tutaj również dzieje się bardzo ciekawa
        rzecz, mianowicie: routery na swoich interfejsach nie mogą mieć więcej
        niż jeden adres. W przypadku skonfigurowania jednego z protokołów
        FHRP, interfejsy będą miały jeszcze jeden komplet z adresu MAC oraz
        IPv4 należące do <strong>wirtualnego routera</strong> i to ten adres 
        IPv4 będą miały hosty zapisany jako adres
        bramy. Podczas pracy routery, przesyłają miedzy sobą komunikat, aby
        dać znać, że działają. Wysyłają go co określoną ilość czasu, jeśli
        przez jakiś określony czas router pasywny nie otrzyma tego pakietu, to
        uzna on, że obecne urządzenie aktywne uległo awarii i przejdzie w tryb
        aktywny. Do określenia ról routerów w tym protokole wykorzystuje się
        nazewnictwa - <em>standby</em> (w gotowości, pasywny) oraz
        <em>active</em> (aktywny, przekazujący). Natomiast między sobą routery
        wysyłają pakiety <em>hello</em>, służące do monitorowania stanu
        operacyjności.
      </p>
      <p>
        Tak jak wspomniałem FHRP, to określenie zbiorcze technologii, które
        zbierają kilka protokołów pod sobą. Oto one:
      </p>
      <ul>
        <li><strong>HSRP</strong> (<em>Hot Standby Router Protocol</em>) - 
          Zastrzeżony przez Cisco protokół FHRP. Umożliwia on transparentny
          tryb <em>failover</em> dla urządzenia pierwszego skoku IPv4.</li>
        <li><strong>HSRP IPv6</strong> - HSRP dla IPv6</li>
        <li><strong>VRRPv2</strong>
          (<em>Virtual Router Redundancy Protocol</em>) - Otwarty protokół 
          FHRP, działa na podobnej zasadzie do HSRP.</li>
        <li><strong>VRRPv3</strong> - Ulepszona wersja VRRPv2, poprawiono
          skalowalność.</li>
        <li><strong>GLBP</strong> (<em>Gateway Load Balancing Protocol</em>) -
          Zastrzeżony przez Cisco protokół FHRP, zapewniający tą samą
          funkjonalność HSRP czy VRRP oraz rozszerzający ją o równoważenie
          obciążenia łączy.</li>
        <li><strong>GLBP IPv6</strong> - Wersja GLBP dla IPv6.</li>
      </ul>
      <h2 id="2.9.1.hsrpprotocol">2.9.1 Protokół HSRP</h2>
      <p>
        Protokół HSRP jest zastrzeżoną przez Cisco implementacją 
        transparentnego trybu <em>failover</em> zapewniający zawsze 
        dostęp do routera dla hostów IPv4, po przez przełączanie się pomiedzy
        urządzeniem aktywnym, a <em>standby</em>-em. HSRP łączy routery w grupy
        i przełącza je w tych grupach, przyczym jeden router może należeć do
        wielu grup. Także nie ma tutaj obaw, podobnych do <em>spanning tree</em>,
        że nie wszystkie możliwości są w pełni wykorzystane. 
      </p>
      <p>
        W przypadku tego protokołu urządzenia dokonują elekcji na podstawie
        <strong>priorytetu</strong> (w którym decyduje największa wartość - 
        120&gt;100) lub jeśli priotety są takie same (domyślnie 100) to
        decyduje najwyższy adres IP (.1.100&gt;.1.1). Priorytet przyjmuje
        wartość od 0 do 255, przyczym rolę routerów można wymusić
        (polecenie <code class="code-inline">standby preempt</code> - użycie
        tego polecenia ustawi go w roli aktywnego urządzenia).
        W tym protokole
        komunikaty <em>hello</em> przesyłane są co 3 sekundy, natomiast
        <em>standby</em> czeka na nie przez 9 sekund, zanim rozpocznie
        procedurę przełącznia. HSRP dokonuje przełączania na podstawie awarii
        łącza lub na podstawie warunków, jednak one wykraczają poza ramy kursu
        CCNA. HSRP wystawia wirtualny router (dodatkowy adres dla
        interfejsu), który będzie bramą domyślną jednej z grup.
      </p>
      <p>
        Podczas ustalania roli routera w HSRP interfejs (najczęściej bramy 
        sieci LAN)
        będzie przechodzić przez następujące stany, za nim okaże się, że ma być
        przekazującym czy pasywnym w trybie <em>stanby</em>. Poniżej znajduje
        opis tych stanów oraz ich zachowanie względem komunikatów
        <em>hello</em>.
      </p>
      <ul>
        <li><strong>Init</strong> - ten stan jest wprowadzany podczas zmiany
          konfiguracji lub podczas uruchamiania interfejsu.</li>
        <li><strong>Learn</strong> - Router nie określił wirtualnego adresu IP,
          nie odebrał jeszcze komunikatów <em>hello</em> z aktywnego routera.
          W tym stanie router czeka na <em>hello</em> od aktywnego routera.</li>
        <li><strong>Listen</strong> - Router zna wirtualny adres IP, ale nie
          jest jeszcze aktywnym ani pasywnym urządzeniem w grupie. Router
          nasłuchuje wiadomości <em>hello</em> od innych urządzeń w grupie.</li>
        <li><strong>Speak</strong> - Router okresowo wysyła ramki <em>hello</em>,
          aktywnie bierze udział w elekcji urządzenia pasywnego/aktywnego.</li>
        <li><strong>Standby</strong> - Router jest kandydatem, aby stać się
          urządzeniem aktywnym, okresowo wysyła komunikaty <em>hello</em>.
      </ul>
      <p>
        Ilości czasu między wysyłanymi wiadomościami <em>hello</em> oraz okres
        czasu oczekiwania na tego typu wiadomość można modyfikować. Jednak nie
        zaleca się ustawiania pierwszej wartości po niżej 2 sekund a drugiej
        poniżej 4. Spowoduje to znaczne zużycie zasobów urządzeń oraz 
        nie potrzebne przełączanie się w przypadku drobnego, krótkotrwałego
        przeciążenia sieci.
      </p>
      <h2 id="2.9.3.hsrpconfiguration">2.9.3. Konfiguracja HSRP</h2>
      <p>
        Załóżmy że mamy taką topologię:
      </p>
<pre class="code-block">
H-b -- S-2
       |    192.168.1.0/24
       |
       R(d)-2   LAN2
--------------------
      / \  R-2 -N- R(d)-1: 172.16.0.0/16
     N   N R(d)-2 -N- R-3: 172.17.0.0/16
    /     \
--------------------
   R(d)-1  R-3  LAN1
    \     /
     \   /
       S-1 192.168.20.0/24
      / \
     /   \
    H-a   H-c

Legenda:
H - Host
S - Switch
R - Router
(d) - Serial DCE
-N- - Połączenie szeregowe
- - Połączenie Copper/Fiber
-[A-Za-z][0-9] - identyfikator urządzenia
</pre>
      <p>
        Topologia przedstawia dwie sieci LAN połączone ze sobą łączami
        szeregowymi. Pierwsza sieć LAN, zawiera hosty: H-a, H-c, S-1, R-1 i R-3.
        Druga natomiast: H-b, S-2 i R-2. Host H-a w sieci LAN1 ma bramę
        ustawioną na adres interfejsu fa0/0 routera R-1, natomiast host H-c
        na adres interfejsu fa0/0 routera R-3, a host H-b na interfejs fa0/0
        routera R-2. Między routerami skonfigurowano protokół routingu EIGRP,
        hosty mogą swobodnie komunikować się ze sobą. 
      </p>
      <p>
        Załóżmy, że dokonaliśmy odpowiednich pomiarów. Chcemy skonfigurować
        HSRP, aby ruch hosta H-c przechodził przez R-1, ale w przypadku jego
        awarii, został przełączony na R-3, natomiast ruch hosta H-a ma
        zostać wysłany przez R-3 i w przypadku awarii ma zostać przełączony
        na R-1. Aby to zrealizować potrzebne nam są dwie grupy HSRP.
        Konfigurację grup zaczynamy od ustalenia adresów IP dla wirtualnych
        routerów, następnie na routerze R-1 wydajemy poniższe polecenia.
      </p>
<pre class="code-block">
R1(config)#int fa0/0
R1(config-if)#standby version 2
R1(config-if)#standby 1 ip 192.168.20.100
R1(config-if)#standby 1 priority 120
R1(config-if)#standby 1 preempt 
R1(config-if)#standby 2 ip 192.168.20.200
R1(config-if)#standby 2 priority 100
</pre>
      <p>
        Po przejściu do interfejsu uruchamiamy nowszą wersję protokołu HSRP.
        Następnie w trzecim poleceniu definujemy grupę 1 oraz adres IP dla
        wirtualnego routera. W kolejnym poleceniach: ustawiamy wiekszy
        priorytet niż domyślny (<code class="code-inline">120</code>) i
        wywłaszczamy rolę <em>active</em> dla tego właśnie urządzenia w tej
        grupie oczywiście. Ostatnie dwa polecenia służą definicji grupy drugiej
        (wszystkie routery grupie powinny mieć te definicje) wraz z adresem
        wirtualnego routera dla grupy drugiej. Na koniec podajemy priorytet
        w sposób jawny, aby nie pozostawiać niczego domysłom. Na drugim
        routerze w tej sieci, dokonujemy analogicznej konfiguracji ale dla
        grupy drugiej jako natywna (R-3 będzie urządzeniem aktywnym w tej
        grupie), natomiast grupe pierwszą wskazujemy jako definicję aby to
        urządzenie również było jej <em>członkiem</em>.
      </p>
<pre class="code-block">
R3(config)#int fa0/0
R3(config-if)#standby version 2
R3(config-if)#standby 2 ip 192.168.20.200
R3(config-if)#standby 2 priority 120
R3(config-if)#standby 2 preempt
R3(config-if)#standby 1 ip 192.168.20.100
R3(config-if)#standby 1 priority 100
</pre>
      <p>
        W ten sposób prezentują się informacje na temat użycia protokołów
        FHRP (HSRP) na routera Cisco:
      </p>
<pre class="code-block">
R1#show standby brief
                     P indicates configured to preempt.
                     |
Interface   Grp  Pri P State    Active          Standby         Virtual IP
Fa0/0       1    120 P Active   local           192.168.20.3    192.168.20.100 
Fa0/0       2    100   Standby  192.168.20.3    local           192.168.20.200 

R3#show standby brief
                     P indicates configured to preempt.
                     |
Interface   Grp  Pri P State    Active          Standby         Virtual IP
Fa0/0       2    120 P Active   local           192.168.20.1    192.168.20.200 
Fa0/0       1    100   Standby  192.168.20.1    local           192.168.20.100 
</pre>
      <p>
        Teraz po skonfigurowaniu HSRP, możemy ustawić hostom H-a oraz H-c
        odpowiednie adresy bramy domyślnej. Jeśli spróbujemy osiągnąć z H-c,
        host H-b to trasa będzie wyglądać następująco (interfejs fa0/0 R-1 ma
        adres IP: 192.168.20.1):
      </p>
<pre class="code-block">
C:\&gt;tracert 192.168.1.3 (host: H-b)

Tracing route to 192.168.1.3 over a maximum of 30 hops: 

  1   0 ms      0 ms      0 ms      192.168.20.1
  2   0 ms      1 ms      0 ms      172.16.0.2
  3   0 ms      1 ms      1 ms      192.168.1.3

Trace complete.
</pre>
      <p>
        Ale jeśli usunelibyśmy to połącznie między S-1 a R-1, to
        H-c nie miało by jak się skomunikować z R-1, na R-3 nie odebrało by
        wiadomości <em>hello</em> i przełączyłoby się w tryb aktywny. Wówczas
        ta sama trasa wyglądała by jak na poniższym przykładzie (interfejs fa0/0
        R-3 ma adres: 192.168.20.3):
      </p>
<pre class="code-block">
C:\&gt;tracert 192.168.1.3 (host: H-b)

Tracing route to 192.168.1.3 over a maximum of 30 hops: 

  1   1 ms      0 ms      0 ms      192.168.20.3
  2   0 ms      15 ms     0 ms      172.17.0.2
  3   10 ms     1 ms      0 ms      192.168.1.3

Trace complete.
</pre>
      <p>
        Jeśli mielibyśmy w tej sieć mieć tylko jedną grupę HSRP, to wówczas
        ograniczylibyśmy się do dwóch poleceń na urządzeniu <em>standby</em>:
      </p>
<pre class="code-block">
R3(config)#int fa0/0
R3(config-if)#standby version 2
R3(config-if)#standby 1 ip 192.168.20.100
</pre>
      <h2 id="2.9.2.pka">Zadanie praktyczne - Packet Tracer</h2>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/9.3.3-packet-tracer---hsrp-configuration-guide_pl-PL.pdf">Przewodnik konfiguracji HSRP - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/9.3.3-packet-tracer---hsrp-configuration-guide_pl-PL.pka">Przewodnik konfiguracji HSRP - zadanie</a>
      </p>
      <h2 id="2.9.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy z technologią FHRP, poznaliśmy metody
        działania jej protokołów oraz ich rodzaje. Omówiliśmy sobie protokół
        Cisco HSRP oraz skonfigurowaliśmy przykładową sieć, aby przedstawić
        w jaki sposób można wykorzystać w pełni jej potencjał przy użyciu
        protokołów tego rodzaju.
      </p>
      <!--<h2 id="2.9.partialexam">Egzamin cząstkowy - Rozdziały: 7 - 9</h2>
      <p>
        <a href="Cisco_-_CCNA_-_SRWE_-_egzamin_czastkowy_roz_7_-_9.html">Egzamin z dostępności i niezawodności sieci</a>
      </p>
      -->
      <h1 id="2.10.securityconcepts">2.10. Koncepcje bezpieczeństwa</h1>
      <p>
        Konfigurując sieć prędzej czy później będziemy musieli zająć tematem
        bezpieczeństwa. Obecnie najbardziej prawdopodobnymi ataki z jakimi
        będziemy musieli się zmierzyć będą to:
      </p>
      <ul>
        <li><strong>Ataki odmowy usługi (DoS/DDoS)</strong> - w tym przypadku
          atakujący
          wykorzystuje serwer i działające na nim usługi. Przy użyciu ogromnej
          liczby żądań usługi przeciąża ją, wówczas dla osób, które faktycznie 
          chcą z niej skorzystać, staje się ona niedostępna.</li>
        <li><strong>Naruszenie danych</strong> - tutaj najczęściej padają
          ofiarą hosty użytkowników końcowych oraz serwery. Dane z tych
          komputerów mogą zostać skradzione.</li>
        <li><strong>Malware</strong> - złośliwe opgrogramowanie dokonujące
          lub pozwalające na inne rodzaje ataków.</li>
      </ul>
      <p>
        Ataki najczęsciej, choć nie jest to reguła, będą pochodzić z zewnątrz.
        Dlatego też musimy wykorzystać dobrej jakości rozwiązania, takie jak:
      </p>
      <ul>
        <li><strong>Router z VPN</strong> - implementacja tuneli VPN w sieciach
          pozwalających na zdalny dostęp do zasobów to podstawa bezpieczenej
          transmisji danych między firmą a pracownikami zdalnymi. Taki router 
          przeważnie znajduje się na brzegu sieci.</li>
        <li><strong>NGFW</strong> - zapora sieciowa nowej generacji. Tak jak
          tradycyjne urządzenia filtrują ruch na podstawie informacji
          warstwy 3 oraz 4. W przypadku urządzeń nowej generacji filtrowanie
          nieporządanych wiadomości, może odbywać się na poziomie komunikatów
          warstwy aplikacji.</li>
        <li><strong>NAC</strong> - urządzenia opowiadające za uwierzytelnianie,
          autoryzacje oraz ewidencjonowanie.
      </ul>
      <p>
        Na ataki najczęciej podatne są punkty końcowe. Są one zazwyczaj
        chronione prze <strong>AMP</strong> - zaawansowaną ochronę
        antywirusową. Są to programy spełniające rolę platformy bezpieczeństwa
        zawierającą pakiet programu antywirusowego, zaporę sieciową
        zapobieganie włamaniom i wiele innych. Projektując system 
        bezpieczeństwa
        sieci, musimy wdrożyć takie rozwiązania, które spowodują, że to wyżej
        wymionione oprogramowanie będzie miało jak najmniej do pracy. W sieci
        możemy wdrożyć takie rozwiązania jak <strong>ESA</strong> - system
        bezpieczeństwa poczty (filtr spamu, skaner załączników) lub/i 
        <strong>WSA</strong> - system bezpieczeństwa sieci Web (filtr treści).
      </p>
      <h2 id="2.10.1.accesscontrol">2.10.1. Kontrola dostępu</h2>
      <p>
        W przypadku urządzeń koncowych, kontrolę dostępu zapewniają nam hasła.
        Podobnie może być w przypadku sieci. Wymagane jest wówczas wdrożenie
        mechanizmów AAA (w nomenklaturze Cisco). Ten skrót sprowadza się
        do trzech czynności: autentykacji, autoryzacji oraz ewidencjonowania.
        <strong>Autentykacja</strong> jest sposobem pozwalającym na
        stwierdzenie czy jesteśmy tymi, za których się podajemy.
        <strong>Autoryzacja</strong>, natomiast określa nam co możemy zrobić
        w systemie - określa ona nasze uprawnienia.
        Ostatnim czynnikiem jest zapewnienie <strong>ewidencjonowania</strong>
        tj. zbierania oraz raportowania tego co użytkownik robi w sieci czy
        na urządzeniu.
        Rozwiązania tego typu mogą dostarczyć informacji potrzebnych do audytu,
        czy pomóc przy rozliczeniu. Wprowadzenie tego
        typu zabezpieczeń spowoduje, że podczas podłączania do sieci
        wymagane będzie podanie loginu hasła.
      </p>
      <p>
        Innym rodzajem kontroli dostępu do sieci może być standard IEEE 802.1X,
        jest to oparty na portach protokół, który pozwala na uwierzytelnianie
        oraz autoryzacje
        użytkownika w sieci. Decydując się na tego typu rozwiązanie do 
        dyspozycji będziemy mieć dwie implementacje, takie jak otwarty
        <strong>RADIUS</strong> oraz zastrzeżony przez Cisco
        <strong>TACACS+</strong>. W przypadku 802.1X każdy komputer ma swoją
        rolę:
      </p>
      <ul>
        <li><strong>Klient (suplikant)</strong> - są to urządzenia z
          zainstalowanym oprogramowaniem klienckim zgodnym z 802.1X. 
          Oprogramowanie tego typu może być stosowane zarówno dla hostów
          przewodowych jak i bezprzewodowych.</li>
        <li><strong>Przełącznik (wystawca uwierzytelnienia)</strong> -
          jest swojego rodzaju pośrednik, żądający od klienta danych
          uwierzytelniających i weryfikujący je z serwerem uwierzytelnienia.
          Po weryfikacji wysyła on odpowiedź do klienta. Innym urządzeniem,
          które może działać jako wystawca uwierzytelnienia jest punkt
          dostępowy.</li>
        <li><strong>Serwer uwierzytelniania</strong> - oprogramownie 
          sprawdzające tożsamość klienta, powiadamia ono przełącznik lub
          punkt dostępowy czy klient może uzyskać dostęp do sieci.</li>
      </ul>
      <h2 id="2.10.3.layer2concerns">2.10.3. Zagrożenia warstwy 2</h2>
      <p>
        Warstwa druga jest poziomem gdzie sygnały elektryczne zaczynają
        spotykać się z jakąś logiką. Na tym poziomie możemy już określać
        pewne obawy co do bezpieczeństwa transmisji jak i samego połączenia.
        Istnieje kilka ataków, które mogą zaistnieć w naszej sieci. Działania
        te głównie skupiają się wokół przełącznika, a urządzenia Cisco
        posiadają odpowiednie środki zapobiegawcze mogące spowodować, że będą
        one niewrażliwego na te zagrożenia.
      </p>
      <ul>
        <li><strong>Ataki na tablice MAC</strong> - Obejmują ataki polegające 
          na zalewaniu adresami MAC. Środek zapobiegawczy:
          <strong>zabezpieczenia portu</strong>.</li>
        <li><strong>Ataki na sieci VLAN</strong> - Obejmują ataki z przeskokiem
          i podwójnym znakowaniem VLAN. Obejmują one również ataki między 
          urządzeniami we wspolnej sieci VLAN. Środek zapobiegawczy:
          <strong>wyłączenie protokołu DTP, zmiana natywnej sieci VLAN</strong></li>
        <li><strong>Ataki na DHCP</strong> - Obejmują ataki polegające na
          blokowaniu i fałszowaniu DHCP. Środek zapobiegawczy: 
          <strong>DHCP Snooping</strong>.</li>
        <li><strong>Ataki na ARP</strong> - Obejmują <em>spoofing</em> ARP
          oraz ataki zatucia ARP. Środek zapobiegawczy:
          <strong>dynamiczna inspekcja ARP (DAI)</strong>.</li>
        <li><strong>Ataki z podszywaniem się.</strong> - Obejmują ataki
          polegające na sfałszowaniu adresów MAC i IP. Środek zapobiegawczy:
          <strong>IP Source Guard (IPSG)</strong>.</li>
        <li><strong>Ataki na STP</strong> - Obejmują ataki manipulacji
          protokołem <em>Spanning Tree</em>. Środek zapobiegawczy:
          <strong>włączenie funkcji PortFast oraz BPDU Guard.</strong>.</li>
      </ul>
      <p>
        Oczywiście nasze starania mogą nie być wystarczające szczególnie wtedy
        gdy protokoły nie będą wystarczająco zabezpieczone. Zaleca się
        porzucenie protokołów nie posiadających żadnych sensownych 
        zabezpieczeń, na rzecz bezpieczniejszych wersji, korzystających z
        warstwy TLS czy wykorzystanie protokołów pochodnych od SSH. Innym
        czynnikiem może być wydzielenie odrębnej sieci VLAN dla zarządzania
        urządzeniami.
      </p>
      <h2 id="2.10.4.lanattacks">2.10.4. Ataki na sieć LAN</h2>
      <p>
        Pierwszym bardzo prostym atakiem do przeprowadzenia jest atak na
        tablicę MAC przełącznika. Polega on na zalewaniu przełącznika ramkami
        ze źródłowym losowym adresem MAC, przez co tablica MAC będzie cały
        czas się wypełniać. W momencie jej przepełnienia przełącznik zaczyna
        się zachowywać jak koncentrator. Takie działanie pozwoli atakującemu
        przechwycić ruch sieciowy, który nie jest zaadresowany do niego.
      </p>
      <p>
        Metodami zapobiegawczymi takiego działania jest skonfigurowanie
        zabezpieczeń portów (zajmiemy się tym w następnym rozdziale), pozwoli
        to ogranicznie nauki adresów na tych portach do podanej konkretnej
        wartości. Choćby jednego adresu.
      </p>
      <p>
        Podatność na ataki względem VLAN-ów jest niedopatrzeniem z strony
        administratora. Pozostawienie włączonego protokołu DTP, może pozwolić
        intruzowi na wymuszenie pomiędzy jego urządzeniami, a przełącznikiem
        portu <em>trunk</em>. Jeśli administrator zapomiał o wyłączeniu DTP to
        na łączach magistralnych dopuszcza ruch za pewne dla całego zakresu
        sieci VLAN. Zatem nic nie stoi na przeszkodzie, aby atakujący mógł
        skomunikować z dowolnym hostem w sieci, mimo skonfigurowania sieci
        VLAN. Tego typu nazywany jest <strong>atak z przeskokiem VLAN</strong>.
      </p>
      <p>
        Innym atakiem na sieci VLAN, jest
        <strong>atak podwójnego tagowania</strong>, atakujący znając
        identyfikator natywnego VLAN-u, może wysłać dane do dowolnym hostem
        w dowolnym VLAN-ie, powodując np. atak odmowy usługi. 
        Jego zadaniem będzie przygotowanie ramki 
        zawierającej pole 802.1Q z identyfikatorem natywnego VLAN-u, jak i
        drugie pole 802.1Q zawierające identyfikator docelowej sieci VLAN.
        Domyślnie natywną siecią VLAN, jest VLAN 1. Natomiast <em>id</em>
        konkretnej sieci VLAN, jest zapisany w adresie IP hosta. W momencie
        osiągniecia pierwszego przełącznika, pierwszy znacznik zostaje zdjęty
        (przez VLAN natywny, przysyłany jest ruch <em>nietagowany</em>), 
        natomiast drugi przełącznik zauważy <em>tag</em> i przekaże te ramki
        do odpowiedniej sieci VLAN.
      </p>
      <p>
        Ochrona przed tego typu czynnościami, wymaga od nas wykonania czynności,
        które wykonywaliśmy przy okazji konfiguracji łączy <em>trunk</em>
        oraz protokołu DTP. Należy ten protokoł bezwzględnie wyłączyć, na
        łączach magistralnych oraz zmienić natywny VLAN z 1 na jakiś inny
        losowy. Warto również na sztywno przypisać portom działanie w trybie
        dostępu.
      </p>
      <p>
        Kolejne ataki, które są omawiane to ataki przeciwko DHCP. Pierwszym
        z nich jest <strong>atak zagłodzenia</strong> - swojego rodzaju
        atak typu DoS (pojedynczy atak DDoS), ponieważ uniemożliwia on
        prawowitym hostom uzyskanie adresu IP z serwera DHCP. Atakujący
        wyczerpuje całą pulę po przez wielkrotną komunikację z serwerem DHCP,
        przy użyciu komunikatów o losowych adresach źródłowych. Cała pula
        zostaje wyczerpana przez losowe adresy, które nawet nie wyślą jednej
        ramki.
      </p>
      <p>
        Innym atakiem jest <strong>atak sfaszowanego DHCP</strong>. Intruz
        może na swoim komputerze uruchomić serwer DHCP i skonfigurować go
        taki sposób, aby nasz ruch był odpowiednio kierowany. Takiego rodzaju
        działanie ma za zadanie przechwycić nasz ruch. Atakujący może
        udostępnić nam, przez swój komputer połącznie z inną siecią, taką jak
        Internet, przez co może do woli przeglądać nasz nieszyfrowany ruch.
      </p>
      <p>
        Metodą zapobiegawczą dla tego rodzaju zagrożenia, jest uruchomienie
        na portach mechnizmu <strong>DHCP Snooping</strong>, pozwala on na
        wybranie portu z którego mogą przychodzić odpowiedzi z serwera DHCP
        oraz nałożenie limitów na ilość zapytań - komunikatów DHCPDISCOVER.
        Ciekawym faktem jest to, że uruchomienie tej funkcjonalności pozwala
        nam zamienić przełącznik, działający w warstwie 2 w nieco bardziej
        inteligente urządzenie, które musi spojrzeć aż do pola danych w 
        przesyłanych ramkach.
      </p>
      <p>
        Ataki ARP takie jak <strong>zatrucie</strong> czy
        <strong>fałszowanie</strong> są do siebie bardzo zbliżone w metodach
        do ich przeprowadzania. Można by nawet rzec, że identyczne. Protokołu
        ARP używa się w celu uzyskania adresu MAC na podstawie adresu IP.
        Zadaniem atakującego jest wysyłanie fałszywych odpowiedzi na
        zapytanie ARP, przez co najczęściej host straci połączenie z innymi
        w sieci. Przy czym tutaj warto powiedzieć, że te wysyłanie odpowiedzi
        musi być ciągłe. Inaczej po zaprzestaniu wysyłania tych odpowiedzi,
        komunikacja po kilku minutach wróci do normy. Tego typu działanie
        jest właśnie, zatruciem ARP. Fałszowanie ma na celu najczęściej
        zmianę trasy ruchu sieciowego, więc tutaj używa się komunikatu
        <strong>gratisowego</strong> ARP, który jest częścią standardu
        ARP. Jego wykorzystanie różni się tym, że przy normalnej komunikacji
        host ofiary nie zapyta o adres jeśli ma go w swojej tablicy ARP, ale
        w przypadku pakietu gratisowego, host ofiary musi aktualizować wpis,
        którego on dotyczy. 
      </p>
      <p>
        Przed atakami na ARP, jest się ciężko obronić. Ponieważ te funkcję,
        które uważamy za słabe, są jego częścia. Nie mniej jednak Cisco
        posiada metodę zwaną <strong>DAI - Dynamiczną inspekcją ARP</strong>.
        DAI do swojego działania wymaga DHCP Snoopingu. Podobnie tak jak
        w przypadku DHCP wybieramy zaufany, który nie będzie sprawdzany.
        Następnie możemy ustawić inspekcję ARP dla konkretnego VLAN lub całego
        przełącznika, możemy wybrać dodatkowo sprawdzany kryterium czy 
        sprawdzany ma być adres MAC źródłowy czy docelowy.
      </p>
      <p>
        Atak fałszowania adresów, może pozwolić atakującemu na przejście przez
        zaporę sieciową. Atak ten polega na wygenrowaniu zarówno ramek i jak
        i pakietów IP ze sfałszowanymi adresami. Dodatkowo pamiętając
        jak działają przełączniki, to możebyć wielce prawdopodbne, otrzymamy
        odpowiedź na sfałszowany adres, gdyż przełącznik zapisze w tablicy MAC,
        że ten komputer jest podłączony do takiego portu.
      </p>
      <p>
        Przed <em>spoofingiem</em> może ochronić nas mechanizm
        <strong>IPSG - IP Source Guard</strong>.
      </p>
      <p>
        Ostatnim omawianym atakiem jest atak na STP. Intruz może chcieć 
        manipulować protokołem w celu wymuszenia zmiany mostu głównego, aby
        moc przechwytywać ruch z sieci. Dokonuje on tego po przez wysłanie
        komunikatu BPDU, zawierającego BID o bardzo wysokim piorytecie. Wówczas
        trasy zostaną ponownie przeliczone, a atakujący uzyska dostęp do naszej
        transmisji.
      </p>
      <p>
        Sposobem na zapobiegnięcie takiemu obiegowi sprawy, należy na
        na portach dostępowych uruchomić mechanizmy takie jak
        <strong>PortFast</strong> czy <strong>BPDU Guard</strong>. Reagują one
        na pojawieni się na porcie komunikatu BPDU. Najczęściej port jest
        blokowany w stan <em>err-disabled</em>, po tym jak kolwiek komunikacja
        zostanie zaprzestana z hostem podłączonym do niego.
      </p>
      <p>
        Innym zagrozniem nie wyrządzającym szkody bezpośrednio hostom jest
        <strong>rozpoznanie CDP</strong>. CDP to własnościowy protokół Cisco
        wykorzystywany do konfiguracji urządzeń tego producenta. Urządzenia
        mają domyślnie włączony ten protokołu i wymieniają miedzy sobą
        informacje za jego pomocą. CDP jest pomocnym protokołem jednak przesyła
        zbyt wiele informacji w sposób niebezpieczny. Jedną z nich jest
        jest natywna sieć VLAN. Dlatego zaleca się wyłącznie jego oraz
        jego otwartego odpowiednika - LLDP
        (<em>Link-Layer Discovery Protocol</em>).
      </p>
      <h2 id="2.10.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy się koncepcjami bezpieczeństwa warstwy
        drugiej. Dowiedzieliśmy się jak są rodzaje ataków i środki zaradcze.
        Na koniec szerzej omówiliśmy każdy z rodzajów ataków, aby mieć ich
        obraz podczas konfiguracji.
      </p>
      <h1 id="2.11.configureswitchsecurity">2.11. Konfiguracja zabezpieczeń przełącznika</h1>
      <p>
        W poprzednim rodziale omówiliśmy zagrożenia z jakimi możemy się
        spotkać w warstwie drugiej. W tym rodziale dowiemy się w jaki sposób
        skonfigurować system IOS na przełączniku, aby móc się przed nimi
        chronić.
      </p>
      <h2 id="2.11.1.portsecurity">2.11.1. Zabezpieczenia portów</h2>
      <p>
        Pierwszą i w prawdzie najważniejszą rzeczą są zabezpieczenia portów.
        Za pomocą tego mechanizmu możemy nakazać aby konkrety port mógł
        nauczyć się tylko jednego adresu MAC, który jeśi będziemy sobie tego
        życzyć będzie może trafić do konfiguracji. Zabezpieczenia portów
        są podstawą linią obrony przed atakami warstwy drugiej.
      </p>
      <p>
        Omawianie zabezpieczeń portów, rozpoczniemy od najprostszej czynności
        jaką możemy wykonać. Jeśli intruz będzie w zasiegu dostępnego gniazda
        <em>Ethernet</em>, może sprawdzić czy jest ono aktywne. Jeśli tak, to 
        może
        udać mu się uzyskać dostęp do sieci. Dlatego czasami najprostrze
        rowiązania są najlepsze. Zatem może warto
        <strong>wyłączyć nieużywane porty</strong> administracyjnie. Wydając
        proste polecenie <code class="code-inline">shutdown</code>. Domyślnie
        wszystkie porty przełącznika <strong>nie są</strong> wyłączone
        administracyjnie.
      </p>
<pre class="code-block">
S1(config)#do sh ip int br
Interface              IP-Address      OK? Method Status                Protocol
Vlan1                  unassigned      YES unset  administratively down down    
FastEthernet0/1        unassigned      YES unset  down                  down    
FastEthernet0/2        unassigned      YES unset  down                  down    
FastEthernet0/3        unassigned      YES unset  down                  down    
FastEthernet0/4        unassigned      YES unset  down                  down    
FastEthernet0/5        unassigned      YES unset  down                  down    
...
</pre>
      <p>
        Przejść do konfiguracji wiecej niż jednego portu możemy poprzez
        użycie polecenia <code class="code-inline">int range</code> podając
        zakres portów lub też ich listę jeśli porty są nie po kolei. Oczywiście
        możemy mieszać ze sobą ten rodzaj parametrów. 
      </p>
<pre class="code-block">
S1(config)#int range fa0/1-24
S1(config-if-range)#shutdown 
S1(config-if-range)#do sh ip int br
Interface              IP-Address      OK? Method Status                Protocol
Vlan1                  unassigned      YES unset  administratively down down    
FastEthernet0/1        unassigned      YES unset  administratively down down    
FastEthernet0/2        unassigned      YES unset  administratively down down    
FastEthernet0/3        unassigned      YES unset  administratively down down    
FastEthernet0/4        unassigned      YES unset  administratively down down    
FastEthernet0/5        unassigned      YES unset  administratively down down    
FastEthernet0/6        unassigned      YES unset  administratively down down
...
</pre>
      <p>
        Po wyłączeniu portów, nie ma możliwości aby ktoś bez naszej wiedzy
        mógł się podłączyć do sieci. Administracyjne wyłącznie portów fizycznie
        wyłącza zasilanie na portach przełącznika.
      </p>
      <p>
        Poza dostępem do sieci, możemy również chcieć zabezpieczyć nasz
        przełącznik, aby nigdy nie udało się zrobić z koncentratora. Z
        poprzedniego rodziału wiemy jak tego dokonać. Zabezpieczenia portów
        obejmują możliwość wskazania ilość adresów MAC, których przełącznik
        może się nauczyć, w jaki sposób ma się ich uczyć, kiedy i jaki sposób
        adres w tablicy ulega przedawnieniu czy co zrobić
        w przypadku naruszenia zasad zabezpieczeń portów.
      </p>
      <p>
        Samo włączenie zabezpieczeń portu spowoduje, że zostaną nałożone na
        niego pewne zasady. Za nim jednak przejdziemy do uruchomienia tej
        opcji to musimy sobie wyjaśnić pewną rzecz. Domyślnie włączony jest
        protokoł DTP, natomiast porty znajdują się w domyślnym stanie
        <em>dynamic auto</em>. Zabezpieczenia portu wymagają, aby port był
        portem dostępowym, więc przed uruchomienieniem zabezpieczeńm portów
        musimy przełączyć port w tryb dostępu: 
      </p>
<pre class="code-block">
#Domyślnie:
S1(config)#do show int fa0/1 switchport
Name: Fa0/1
Switchport: Enabled
Administrative Mode: dynamic auto
Operational Mode: down
Administrative Trunking Encapsulation: dot1q
Negotiation of Trunking: On
Access Mode VLAN: 1 (default)
Trunking Native Mode VLAN: 1 (default)
Administrative Native VLAN tagging: enabled

S1(config)#int fa0/1
S1(config-if)#switchport mode access
S1(config-if)#do show interface fa0/1 switchport
Name: Fa0/1
Switchport: Enabled
Administrative Mode: static access
Operational Mode: down
Administrative Trunking Encapsulation: dot1q
Negotiation of Trunking: Off
Access Mode VLAN: 1 (default)
Trunking Native Mode VLAN: 1 (default)
Administrative Native VLAN tagging: enabled
Voice VLAN: none
</pre>
      <p>
        Teraz możemy włączyć zabezpieczenia portu.
      </p>
<pre class="code-block">
S1(config-if)#switchport port-security
</pre>
      <p>
        Reguły narzucone przez uruchomienie zabezpieczeń portu to, ustawienie
        trybu naruszenia na najbardziej restrykcyjny oraz ustawienie ilości
        adresów MAC do nauczenia się dla tego portu na 1.
      </p>
<pre class="code-block">
S1#show port-security interface fa0/1
Port Security              : Enabled
Port Status                : Secure-down
Violation Mode             : Shutdown
Aging Time                 : 0 mins
Aging Type                 : Absolute
SecureStatic Address Aging : Disabled
Maximum MAC Addresses      : 1
Total MAC Addresses        : 0
Configured MAC Addresses   : 0
Sticky MAC Addresses       : 0
Last Source Address:Vlan   : 0000.0000.0000:0
Security Violation Count   : 0
</pre>
      <p>
        Tryb naruszenia <code class="code-inline">Violation Mode</code>,
        został ustawiony na <code class="code-inline">Shutdown</code>, co
        spowoduje, że jeśli ktoś inny podłączy się do tego portu, to zostanie
        on ustawiony w tryb <em>error disabled</em>. Liczba możliwych adresów
        do nauczenia (<code class="code-inline">Maximum MAC Address</code>)
        wynosi 1.
      </p>
      <p>
        Jeśli chcemy zdecydować o tym ilu adresów pownieni móc nauczyć się
        port wówczas wyskorzysujemy następujące polecenie:
      </p>
<pre class="code-block">
Switch(config-if)# switchport port-security maximum &lt;1-8129&gt;
</pre>
      <p>
        Po za podaniem ilości dozwolonych adresów MAC do zapamiętania, możemy
        manipulować samym jego procesem. Np. podać statyczny adres MAC lub
        przełącznik będzie się ich uczył dynamicznie. Co jest domyślną metodą
        przy włączeniu zabezpieczeń portów. Inna wariacją jest dynamiczne
        uczenie się z wykorzystaniem NVRAM do zapamiętania adresów MAC.
        Poniższe polecenia uruchamiają poniższe tryby:
      </p>
      <ul>
        <li><strong>Przypisanie statyczne</strong> - 
          <code class="code-inline">S1(config-if)#switchport port-security
            mac-address 00de.adbe.ef00</code></li>
        <li><strong>Uczenie się dynamiczne</strong> -
          <code class="code-inline">S1(config-if)#switchport port-security</code></li>
        <li><strong>Uczenie się dynamiczne z wykorzystaniem NVRAM</strong>
          <code class="code-inline">S1(config-if)#switchport port-security
          mac-address sticky</code></li>
      </ul>
      <p>
        W przypadku tych trybów to można je mieszać, ustawiając ilość
        adresów na 4 i podając np. 2 adresy statycznie a resztę pozostawić
        do nauki dynamicznej z wykorzystaniem NVRAM. W przpadku uczenia się
        adresów MAC, przydatne może być polecenie:
      </p>
<pre class="code-block">
S1#show port-security address
          Secure Mac Address Table
------------------------------------------------------------------------
Vlan    Mac Address       Type                     Ports   Remaining Age
                                                              (mins)    
----    -----------       ----                     -----   -------------
   1    001f.1618.0d37    SecureSticky             Fa0/2        -
   1    00de.adbe.ef00    SecureConfigured         Fa0/2        -
------------------------------------------------------------------------
Total Addresses in System (excluding one mac per port)     : 1
Max Addresses limit in System (excluding one mac per port) : 8192
</pre>
      <p>
        Statystyki dla tego portu przezentują się następująco:
      </p>
<pre class="code-block">
S1#sh port-sec int fa0/2
Port Security              : Enabled
Port Status                : Secure-up
Violation Mode             : Shutdown
Aging Time                 : 0 mins
Aging Type                 : Absolute
SecureStatic Address Aging : Disabled
Maximum MAC Addresses      : 2
Total MAC Addresses        : 2
Configured MAC Addresses   : 1
Sticky MAC Addresses       : 1
Last Source Address:Vlan   : 001f.1618.0d37:1
Security Violation Count   : 0
</pre>
    <p>
      Port jest podniesiony (<code class="code-inline">Port Status: Secure-up</code>)
      i nie nastąpiło żadne naruszenie zasad
      (<code class="code-inline">Security Violation Count: 0</code>).
    </p>
    <p>
      Zabezpieczenia portów pozwalają na określenie okresu ważności dla
      bezpiecznych adresów (Przypisanych statycznie lub nauczonych w ramach
      dynamicznej nauki, zgodnie z określonym limitem). Mamy dwa rodzaje
      przedawnienia (okresu ważności):
    </p>
    <ul>
      <li><strong><em>Absolute</em></strong> (ang. bezwględy) - adresy MAC są
        usuwane po upłynięciu podanego okresu czasu.</li>
      <li><strong><em>Inactivity</em></strong> (ang. nieaktywność) - adresy
        MAC są usuwane po upłynięciu podanego okresu czasu nieaktywności.</li>
    </ul>
    <p>
      Za ustawianie przedawnienia odpowiedzialne jest polecenie
      <strong>aging</strong> zabezpieczania portów. Może ono przyjąć
      następujące opcje:
    </p>
    <ul>
        <li><strong>static</strong> - włącza okres przedawnienia dla statycznie
          przypisanych adresów MAC.</li>
        <li><strong>time</strong> &lt;czas&gt; - Czas w minutach określający
          przedawnienie. Przyjmuje wartości od 0 do 1440. Przy czym ustawienie
          0, wyłącza przedawnienie dla tego portu.</li>
        <li><strong>type</strong> <em>Absolute</em>/<em>Inactivity</em> - 
          określa rodzaj przedawnienia dla portu.</li>
    </ul>
    <p>
      Dla przykładu ustawiłem na porcie 2 czas przedawnienia 10 minut
      nieaktywności interfejsu.
    </p>
<pre class="code-block">
S1(config)#int fa0/2
S1(config-if)#switchport port-security aging time 10
S1(config-if)#switchport port-security aging type inactivity 
</pre>
      <p>
        W momencie gdy dojdzie do przekroczenia zasad skonfigurownych na porcie
        występuje naruszenie, może mieć one różne skutki. Od zaprzestania
        transmisji dla nieznanych adresów na czas potrzebny do usunięcia 
        nadmiarowych adresów MAC do
        przestawienia portu w stan <em>error-disabled</em>. Istnieją trzy tryby:
      </p>
      <ul>
        <li><strong>shutdown</strong> (domyślny) - Port przechodzi natychmiast
          do stanu <em>error-disabled</em>, wyłącza kontrolkę LED i wysła 
          komunikat do <em>Syslog</em>. Licznik naruszeń jest zwiększany</li>
        <li><strong>restrict</strong> - Ten tryb powoduje zaprzestanie
          transmisji dla nieznaych adresów do momentu usunięcia namiarowych
          pozycji. Porty nie są wyłączane. Licznik naruszeń jest zwiększany
          oraz wysłane są komunikaty <em>syslog</em></li>
        <li><strong>protect</strong> - działa na takiej samej zasadzie jak
          <em>restrict</em>, przyczym żadne logi nie są wysłane oraz nie jest
          zwiększany licznik naruszeń. Jest najmniej bezpieczny z trybów.</li>
      </ul>
      <p>
        Do ustawienie trybu wybierany wykorzystywane jest polecenie
        <strong>violation</strong>, zabezpieczeń portów.
      </p>
<pre class="code-block">
S1(config)#int fa0/2
S1(config-if)#switchport port-security violation restrict
</pre>
      <p>
        Stan <em>error-disabled</em> - wyłączony przez błąd, może być
        spowodowany przez użytkownika, w momencie gdy naruszy on zasady
        zabezpieczeń portów. Transmisja przez taki port zostaje zatrzymana,
        wyłączona jest również kontrolka LED. Włączenie takowego portu
        wymaga działania administratora.
      </p>
      <p>
        Do tej porty poznaliśmy polecenia, które pozwolą nam ustawienie
        zabezpieczeń portów oraz na wyświetlenie informacji o nich. Nie których.
        Bowiem istnieje jeszcze jedno polecenie, które pozwoli na wyświetlenie
        zabezpieczeń na wszystkich portach.
      </p>
<pre class="code-block">
S1#show port-security
Secure Port  MaxSecureAddr  CurrentAddr  SecurityViolation  Security Action
                (Count)       (Count)          (Count)
---------------------------------------------------------------------------
      Fa0/1              1            0                  0         Shutdown
      Fa0/2              2            2                  0         Restrict
---------------------------------------------------------------------------
Total Addresses in System (excluding one mac per port)     : 1
Max Addresses limit in System (excluding one mac per port) : 8192
</pre>
      <h3 id="2.11.1.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/11.1.10-packet-tracer---implement-port-security_pl-PL.pdf">Wdrożenie zabezpieczeń portów - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/11.1.10-packet-tracer---implement-port-security_pl-PL.pka">Wdrożenie zabezpieczeń portów - zadanie</a>
      </p>
      <h2 id="2.11.2.limitvlanattacks">2.11.2. Ograniczanie ataków na sieci VLAN</h2>
      <p>
        Ataki na sieci VLAN omawiane były dwa: atak z przeskokiem, gdzie
        atakującemu udawało się wynegocjować łącze <em>trunk</em> i uzyskać
        dostęp do innych VLAN-ów, niż ten do którego należy jego gniazdo.
        Drugim atakiem był atak podwójnego znakowania, gdzie atakujący tworzył
        ramkę z podwójnym znacznikiem, pierwszy zawierał znacznik natywnej
        sieci VLAN, a drugi sieci docelowej. 
      </p>
      <p>
        Metodą zabezpieczenia się przed tego typu działaniami są kolejno:
      </p>
      <ol>
        <li>Wyłączenie negocjacji DTP na innych portach niż <em>trunk</em>, 
          przy użyciu polecenia
          <code class="code-inline">switchport mode access</code></li>
        <li>Nie używane porty należy umieść w innym VLAN-ie niż domyślny.</li>
        <li>Na portach przeznaczonych jako <em>trunk</em>, tryb ten włączamy
          jest ręcznie przy użyciu polecenia
          <code class="code-inline">switchport mode trunk</code>.</li>
        <li>Wyłączamy autonegocjacje DTP na portach <em>trunk</em>, za pomocą
          polecenia: <code class="code-inline">switchport nonegotiate</code>.</li>
        <li>Zmieniamy natwyną sieć VLAN dla łączy <em>trunk</em>, przy użyciu
          polecenia: <code class="code-inline">switchport trunk native vlan X</code>,
          gdzie <code class="code-inline">X</code>, oznacza numer sieci VLAN.</li>
      </ol>
<pre class="code-block">
S1(config)#vlan 1000
S1(config-vlan)#name UNUSED_PORTS
S1(config-vlan)#vlan 999
S1(config-vlan)#name NATIVE
S1(config-vlan)#exit
S1(config)#
S1(config)#int range fa0/3-12
S1(config-if-range)#switchport mode acces
S1(config-if-range)#exit
S1(config)#int range fa0/13-20
S1(config-if-range)#switchport mode access
S1(config-if-range)#switchport access vlan 1000
S1(config-if-range)#shutdown
S1(config-if-range)#exit
S1(config)#int fa0/21-24
S1(config-if-range)#switchport mode trunk
S1(config-if-range)#switchport nonegotiate 
S1(config-if-range)#switchport trunk native vlan 999
S1(config-if-range)#end
</pre>
      <p>
        Na powyższym przykładzie skonfigurowano wyżej wymienione
        zabezpieczenia. Porty 3-12 są portami dostępowymi. Porty 13-20 nie są
        obecnie używane. Ostatnie 4 porty są łączami <em>trunk</em>.
      </p>
      <h2 id="2.11.3.limitingdhcpattacks">2.11.3. Ograniczanie ataków na DHCP</h2>
      <p>
        Znamy dwa ataki wobec usługi DHCP, pierwsza z znich jest zagłodzenie -
        tj. wyczerpanie puli przez atakującego. Ochroną przed tego typu
        działaniem jest ustawienie limitu zapytań do DHCP na portach
        niezaufanych (innych niż te, z których będzie przychodzić odpowiedź
        od serwera). Drugim atakiem, jest fałszowanie - atakujący podstawia
        swój serwer DHCP. Metodą ochrony przed takim działaniem jest
        ustawienie portu zaufanego - z którego będą przychodzić komunikaty
        serwera DHCP. Reszta portów będzie domyślnie ustawiana jako
        niezaufane. Te metody oferuje mechanizm <em>DHCP Snooping</em>. Kroki 
        jakie
        należy wykonać w celu skonfigurowania tej metody prezentują się
        następująco:
      </p>
      <ol>
        <li>Włączamy <em>DHCP Snooping</em> za pomocą polecenia
          <code class="code-inline">ip dhcp snooping</code> w konfiguracji
          globalnej</li>
        <li>Porty z odpowiedzią DHCP uznajemy za zaufane za pomocą polecenia:
          <code class="code-inline">ip dhcp snooping trust</code>.</li>
        <li>Na portach niezaufanych ustawiamy limit zapytań do DHCP - liczbę
          odebranych komunikatów DHCPDISCOVER na sekundę. Dokonujemy tego
          za pomocą polecenia:
          <code class="code-inline">ip dhcp snooping limit rate X</code>, gdzie
          <code class="code-inline">X</code> to liczba zapytań.</li>
        <li><em>DHCP Snooping</em> możemy również włączyć dla określonej sieci
          VLAN lub dla wielu sieci, wydając w konfiguracji globalnej polecenie:
          <code class="code-inline">ip dhcp snooping Y</code>, gdzie
          <code class="code-inline">Y</code> to numer/numery sieci VLAN lub ich
          zakres.</li> 
      </ol>
<pre class="code-block">
S1#conf t
S1(config)#ip dhcp snooping
S1(config)#int g0/1
S1(config-if)#ip dhcp snooping trust
S1(config-if)#exit
S1(config)#int range fa0/1-24
S1(config-if-range)#ip dhcp snooping limit rate 6
S1(config-if-range)#exit
S1(config)#ip dhcp snooping vlan 1000
</pre>
      <p>
        Na powyższym przykładzie skonfigurowano opcje zabepieczeń przed atakami
        na DHCP. W IOS mamy możliwość wyświetlenia informacji o konfiguracji
        <em>DHCP Snooping</em> za pomocą polecenia:
        <code class="code-inline">show ip dhcp snooping</code>.
      </p>
<pre class="code-block">
S1#show ip dhcp snooping
Switch DHCP snooping is enabled
DHCP snooping is configured on following VLANs:
1000
DHCP snooping is operational on following VLANs:
1000
DHCP snooping is configured on the following L3 Interfaces:

Insertion of option 82 is enabled
   circuit-id default format: vlan-mod-port
   remote-id: ecc8.8212.b200 (MAC)
Option 82 on untrusted port is not allowed
Verification of hwaddr field is enabled
Verification of giaddr field is enabled
DHCP snooping trust/rate is configured on the following Interfaces:

Interface                  Trusted    Allow option    Rate limit (pps)
-----------------------    -------    ------------    ----------------   
FastEthernet0/1            no         no              6         
  Custom circuit-ids:
FastEthernet0/2            no         no              6         
  Custom circuit-ids:
FastEthernet0/3            no         no              6         
  Custom circuit-ids:
FastEthernet0/4            no         no              6         
  Custom circuit-ids:
FastEthernet0/5            no         no              6         
  Custom circuit-ids:
...
FastEthernet0/23           no         no              6         
Interface                  Trusted    Allow option    Rate limit (pps)
-----------------------    -------    ------------    ----------------   
  Custom circuit-ids:
FastEthernet0/24           no         no              6         
  Custom circuit-ids:
GigabitEthernet0/1         yes        yes             unlimited
  Custom circuit-ids:
</pre>
      <h2 id="2.11.4.limitingarpattacks">2.11.4. Ograniczenie ataków na ARP.</h2>
      <p>
        Ataki ARP są do siebie bardzo podobne. Chodzi o manipulację tablicą
        ARP na komputerze ofiary. Pierwszym atakiem jest zatrucie, przez które
        ofiara całkowicie traci łączność, ponieważ atakujący odpowiada na jej
        żądania losowowymi adresami fizycznymi. Drugim atakiem jest fałszowanie
        ataków, przy użyciu pakietu gratisowego ARP. Użycie tego pakietu
        wymusza na ofierze, aktualizację wpisu w tablicy ARP, którego dotyczy
        ten pakiet. Chronić się przed działania tego typu możemy za pomocą
        mechanizmu <em>Dynamic Arp Inspection - DAI</em>.
      </p>
      <p>
        Dynamiczna inspekcja ARP (DAI) wymaga działania mechanizmu
        <em>DHCP Snooping</em>, pomaga zapobiegać atakom poprzez:
      </p>
      <ul>
        <li>Nie przykazywanie nieprawidłowych lub gratisowych odpowiedzi ARP
          do innych portów w tej samej sieci VLAN.</li>
        <li>Przechwytywanie wszystkich żądań i odpowiedzi ARP na niezaufanych
          portach.</li>
        <li>Sprawdzenie każdego przechwyconego pakietu pod kątem prawidłowego
          powiązania IP do MAC.</li>
        <li>Odrzucanie i rejestrowanie odpowiedzi ARP, posiadające
          nieprawdziwe informacje, aby zapobiec zatruciu ARP.</li>
        <li>Przełączenie interfejsu w stan <em>error-disabled</em>, jeśli
          skonfigurowana w DAI liczba pakietów ARP zostanie przekroczona.</li>
      </ul>
      <p>
        W celu wykorzystania mechnizmu DAI, musimy podąrząć zgodnie z poniższymi
        wskazówkami:
      </p>
      <ol>
        <li>Włączamy globalnie <em>DHCP Snooping</em>.</li>
        <li>Włączamy <em>DHCP Snooping</em> dla konkretnej sieci VLAN.</li>
        <li>Włączamy DAI dla wybranej sieci VLAN.</li>
        <li>Na koniec konfigurujemy zaufane interfejsy dla
          <em>DHCP Snooping</em> i DAI.</li>
      </ol>
<pre class="code-block">
S1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#ip dhcp snooping
S1(config)#ip dhcp snooping vlan 1000
S1(config)#ip arp inspection vlan 1000
S1(config)#interface fa0/24
S1(config-if)#ip dhcp snooping trust 
S1(config-if)#ip arp inspection trust 
</pre>
      <p>
        Na powyższym urządzeniu włączyłem globalnie <em>DHCP Snooping</em>,
        <code class="code-inline">S1(config)#ip dhcp snooping</code> następnie
        skonfigurowałem <em>DHCP Snooping</em> oraz DAI dla VLAN-u 1000 - 
        <code class="code-inline">S1(config)#ip dhcp snooping vlan 1000</code>,
        <code class="code-inline">S1(config)#ip arp inspection vlan 1000</code>.
        Na koniec skonfigurowałem interfejs <code class="code-inline">fa0/24</code>
        jako zaufany dla <em>DHCP Snooping</em>-u oraz inspekcji ARP.
      </p>
      <p>
        Mechanizm DAI może zostać również skonfigurowany w taki sposób aby
        weryfikował adresy przekazywane we wiadomości ARP z adresami zawartymi
        w nagłówku ramki <em>Ethernet</em>. Do wyboru mamy takie warunki jak:
      </p>
      <ul>
        <li><strong>Docelowy MAC</strong> - porównanie docelowego adresu MAC
          w nagłówku ramki z tym we wiadomości ARP.</li>
        <li><strong>Źródłowy MAC</strong> - porównianie źródłowego adresu MAC
          w nagłówku ramki z tym we wiadomości ARP.</li>
        <li><strong>Adres IP</strong> - sprawdza komunikat pod kątem nie
          prawidłowych i nieoczekiwanych adresów IP, takich jak: 0.0.0.0,
          255.255.255.255 czy wszystkich adresów <em>multicastowych</em>.</li>
      </ul>
      <p>
        Do ustawiania weryfikacji adresów w ARP służy polecenie:
        <code class="code-inline">ip arp inspection validate</code> po czym
        podajemy rodzaj sprawdzania adresów. Nic nie stoi na przeszkodzie, aby
        ustawić je wszystkie.
      </p>
<pre class="code-block">
S1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#ip arp inspection validate src-mac dst-mac ip
</pre>
      <p>
        Od teraz komunikaty ARP, bedą sprawdzane pod kątem poprawności adresów.
      </p>
      <h2 id="2.11.5.limitingstpattacks">2.11.5. Ograniczanie ataków STP</h2>
      <p>
        W przypadku ataków STP, atakujący może podłączyć swoje urządzenie i
        wymusić zmianę topologii poprzez wysłanie BPDU z wysokim priorytetem w
        BID. Ochroną przed tego typu działaniami jest użycie technologii
        <strong>PortFast</strong> oraz <strong>BPDU Guard</strong>.
      </p>
      <p>
        <em>PortFast</em> przyspiesza stan gotowości portu o przesyłania
        danych. Port przenoszony jest natychmiast ze stanu blokowania w stan
        przekazywania. <em>PortFast</em> jest przeznaczony dla użytkowników
        końcowych i tylko dla nich powinien być stosowany. <em>BPDU Guard</em>
        jest mechanizm zabezpieczającym przed pojawieniem się komunikatów BPDU
        na niepożądanych portach. Jeśli taki komunikat się pojawi przy
        skonfigurowanym <em>BPDU Guard</em>, taki port zostanie ustawiony w
        stan <em>error-disabled.</em>.
      </p>
      <p>
        Konfiguracji <em>PortFast</em>, możemy dokonać na dwa sposoby.
        Konfigurować po kolei każdy z portów tak jak przedstawiono to na
        poniższym przykładzie.
      </p>
<pre class="code-block">
S1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#int fa0/4
S1(config-if)#switchport mode access
S1(config-if)#spanning-tree portfast
%Warning: portfast should only be enabled on ports connected to a single
 host. Connecting hubs, concentrators, switches, bridges, etc... to this
 interface  when portfast is enabled, can cause temporary bridging loops.
 Use with CAUTION

%Portfast has been configured on FastEthernet0/4 but will only
 have effect when the interface is in a non-trunking mode.
</pre>
      <p>
        Możemy również skonfigurować <em>PortFast</em> domyślnie dla całego
        przełącznika. Tak jak na przykładzie:
      </p>
<pre class="code-block">
S1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#spanning-tree portfast default
%Warning: this command enables portfast by default on all interfaces. You
 should now disable portfast explicitly on switched ports leading to hubs,
 switches and bridges as they may create temporary bridging loops.
</pre>
      <p>
        Aby sprawdzić konfigurację <em>PortFast</em> możemy użyć polecenia
        <code class="code-inline">show spanning-tree summary</code>. Poniżej
        znajduje się wynik jego działania:
      </p>
<pre class="code-block">
S1#show spanning-tree summary 
Switch is in pvst mode
Root bridge for: none
Extended system ID           is enabled
Portfast Default             is enabled
PortFast BPDU Guard Default  is disabled
Portfast BPDU Filter Default is disabled
Loopguard Default            is disabled
EtherChannel misconfig guard is enabled
UplinkFast                   is disabled
BackboneFast                 is disabled
Configured Pathcost method used is short

Name                   Blocking Listening Learning Forwarding STP Active
---------------------- -------- --------- -------- ---------- ----------
Total                        0         0        0          0          0
</pre>
      <p>
        Drugim mechanizm do skonfigurowania jest <em>BPDU Guard</em>. Metoda
        jest taka sama jak w przypadku <em>PortFast</em>, różnią się tylko
        polecenia.
      </p>
<pre class="code-block">
S1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
S1(config)#int fa0/4
S1(config-if)#spanning-tree bpduguard enable
S1(config-if)#exit
S1(config)#spanning-tree portfast bpduguard default 
</pre>
      <p>
        Teraz możemy wyświetlić sobie jeszcze raz podsumowanie konfiguracji
        STP.
      </p>
<pre class="code-block">
S1#show spanning-tree summary
Switch is in pvst mode
Root bridge for: none
Extended system ID           is enabled
Portfast Default             is enabled
PortFast BPDU Guard Default  is enabled
Portfast BPDU Filter Default is disabled
Loopguard Default            is disabled
EtherChannel misconfig guard is enabled
UplinkFast                   is disabled
BackboneFast                 is disabled
Configured Pathcost method used is short

Name                   Blocking Listening Learning Forwarding STP Active
---------------------- -------- --------- -------- ---------- ----------
Total                        0         0        0          0          0
</pre>
      <p>
        Możemy skonfigurować przełącznik w taki sposób, aby automatycznie
        odblokowywał porty w stanie <em>error-disabled</em>. W przypadku
        naruszenia <em>BPDU Guard</em>, możemy uruchomić to poleceniem:
      </p>
<pre class="code-block">
S1(config)#errdisable recovery cause psecure-violation
</pre>
      <p>
        Domyślnym okresem karencji jest 300 sekund = 5 minut. Konfigurację
        automatycznego podnoszenia portu ze stanu <em>error-disabled</em>
        możemy sprawdzić (w tym i okres karencji) za pomocą polecenia
        <code class="code-inline">show errdisable recovery</code>
      </p>
<pre class="code-block">
S1#show errdisable recovery 
ErrDisable Reason            Timer Status
-----------------            --------------
arp-inspection               Disabled
bpduguard                    Disabled
channel-misconfig            Disabled
dhcp-rate-limit              Disabled
dtp-flap                     Disabled
gbic-invalid                 Disabled
inline-power                 Disabled
link-flap                    Disabled
mac-limit                    Disabled
loopback                     Disabled
pagp-flap                    Disabled
port-mode-failure            Disabled
psecure-violation            Disabled
security-violation           Disabled
sfp-config-mismatch          Disabled
small-frame                  Disabled
storm-control                Disabled
udld                         Disabled
vmps                         Disabled

Timer interval: 300 seconds
</pre>
      <h2 id="2.11.6.turnoffcdp">2.11.6. Wyłączenie protokołu CDP</h2>
      <p>
        Jeśli chcielibyś uchronić nasze urządzenia przez pozyskiwaniem z nich
        danych, które można wykorzystać do ataków (przed rozpoznaniem). To
        dobrym pomysłem jest wyłącznie protokołu CDP oraz LLDP. Te protokoły
        możemy wyłączyć globalnie lub dla poszczególnych interfejsów.
      </p>
      <ul>
        <li>Wyłącznie globalne CDP i LLDP -
          <code class="code-inline">no cdp run</code> i
          <code class="code-inline">no lldp run</code>.</li>
        <li>Wyłącznie na interfejsie - 
          <code class="code-inline">no cdp enable</code> i
          <code class="code-inline">no lldp transmit</code>,
          <code class="code-inline">no lldp receive</code>.</li>
      </ul>
      <p>
        Ponowne włączenie tych protokołów wymaga użycia tych samych poleceń,
        ale bez słowa <code class="code-inline">no</code> na początku.
      </p>
      <h2 id="2.11.summary">Podsumowanie</h2>
      <p>
        W tym rodziale dowiedzieliśmy się jak możemy skonfigurować Cisco IOS na
        przełącznikach, aby zapobiec atakom z poznanym w 10 rozdziale. 
        Poznaliśmy zabezpieczenia portów oraz metody ochrony przez atakami na
        sieci VLAN, DHCP, ARP oraz STP.
      </p>
      <h3 id="2.11.7.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/11.6.1-packet-tracer---switch-security-configuration_pl-PL.pdf">Konfiguracja zabezpieczeń przełącznika - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/11.6.1-packet-tracer---switch-security-configuration_pl-PL.pka">Konfiguracja zabezpieczeń przełącznika - zadanie</a>
      </p>
      <h3 id="2.11.7.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/11.6.2-lab---switch-security-configuration_pl-PL.pdf">Konfiguracja zabezpieczeń przełącznika</a>
      </p>
      <h1 id="2.12.wlanconcepts">2.12. Koncepcje WLAN</h1>
      <p>
        Sieci bezprzewodowe są wygodną alternatywą dla połączeń kablowych.
        Dzięki nim, możemy podłączyć wiele urządzeń bez prowadzenia kabli.
        Połączenia bezprzewodowe pozwalają nam na korzystanie z takich urządzeń
        jak tablety czy smartfony. Przy dobrze skonfigurowanej sieci
        bezprzewodowej, możemy swobodnie przemieszczać się po firmie bez utraty
        połączenia z siecią. Korzystając z wielu zalet łączności bezprzewodowej
        nie które firmy decydują się na użycie okablowania tam tylko gdzie jest
        ono niezbędne, natomiast hosty końcowe wykorzystują jedynie połączenia
        bezprzewodowe.
      </p>
      <p>
        Sieci bezprzewodowe są oparte na standardach IEEE i można je ogólnie
        podzielić na cztery główne typy: WPAN, WLAN, WMAN, WWAN.
      </p>
      <ul>
        <li><strong>Wireless Personal-Area Networks (WPAN)</strong> - Nadajniki
          w tej sieci korzystają z niskiej mocy. Zasieg zwykle osiąga od 6 do 9
          metrów. Przykładami takich sieci może być technologia
          <strong>Bluetooth</strong> czy <strong>ZigBee</strong> (wykorzystywane
          głównie w IOT). Technologię wykorzystywaną do sieci WPAN opisują
          standardy 802.15. Sieci tego typu wykorzystują częstotliwości 2.4GHz.
        </li>
        <li><strong>Wireless LAN (WLAN)</strong> - Sieć bezprzewodowa
          wykorzystywana do komunikacji przypominającej klasyczną sieć
          komputerową. Jej nadajnik zwykle obejmują średni obszar, do około
          100m. Sieci tego rodzaj świetnie nadają się do wymiany informacji
          w średniej wielkości biurze lub domu. Nie kiedy pochodne komunikacji
          tego rodzaju wykorzystywane są do łączenia sieci między budynkami,
          czy nieco dłuższe odległości. Sieci WLAN opisują technologie 802.11 i
          korzystają one z ogólnodostępnych pasm 2.4 GHz oraz 5 GHz.</li>
        <li><strong>Wireless MANs (WMAN)</strong> - Łączność bezprzewodowa
          rozciągająca się na obszarze jednego miasta lub określonej jego
          części. Wykorzystuję najczęściej licencjonowane częstotliwości.</li>
        <li><strong>Wireless WANs (WWAN)</strong> - Wykorzystanie nadajników
          bezprzewodowych aby zapewnić zasięg na rozległym obszarze
          geograficznym. Wykorzystują do tego licencjonowane częstotliwości
          radiowe.</li>
      </ul>
      <p>
        Wykorzystwane przez użytkowników technologie radiowe, wykorzystują
        nielicencjonowane aby móc zapewnić transmisję danych między 
        użytkownikami. Każdy może z nich korzystać zaopatrując się chociażby 
        w router bezprzewodowy klasy SOHO czy telefon komórkowy wykorzystujący
        technologię <em>Bluetooth</em>. Spośród takich technologii
        bezprzewodowych możemy wyróżnić:
      </p>
      <ul>
        <li><strong>Bluetooth</strong>, technologia wykorzystująca
          częstoliwości nielicencjonowane do przesyłania plików z urządzenia
          na urządzenie czy strumieniowania dźwieku do jego odtwarzacza np.
          do słuchawek. Technologia ta wykorzystywana jest również przez
          systemy internetu rzeczy. Możemy wyodrębnić dwie technologie takie
          jak <strong>BLE</strong> (<em>Bluetooth Low Energy</em>),
          wykorzystywaną przez różnego rodzaju czujniki. Działa ona za zasadzie
          siatki, gdzie jedne z uczestników wymiany informacji w sieci tego
          rodzaju, przekazuje informacje dalej, aż do odbiorcy. Inną 
          technologią jest <strong>BR/ERD</strong> (<em>Bluetooth Basic Rate/
          Enchanced Rate</em>), wykorzystując topologę punkt-punkt, w celu
          np. strumieniowania muzyki. Bluetooth obejmuje standard 802.15 WPAN.</li>
        <li><strong>WiMAX</strong> - Standard IEEE 802.16 WWAN, opracowany
          jako alternatywa dla szerokopasnowych łączy kablowych. Nie przyjął
          się jednak i szybko został zastąpiony przez sieci komórkowe.</li>
        <li><strong>Szerokopasmowa sieć komórkowa</strong> - Sieci
          bezprzewodowe wykorzystywane głównie przez telefonię komórkową, ale
          mogą, działać za pomocą specjalnych modemów na innych urządzeniach
          takich jak tablety czy laptopy. Osiągają dobre przepustowości, a
          gęsta sieć komórek (obszarów działania stacji bazowej wraz z jej
          klientam (telefonami)) powoduje, że rzadko kiedy tracimy zasięg z
          taką siecią. Mogą spadać jej właściwości nośne, które mogą być
          uzależnione od wielu czynników, tak ich jak ilość klientów w danej
          komórce. Istnieją dwa rodzaje sieci komórkowej <strong>GSM</strong> -
          standard międzynarodowy oraz <strong>CDMA</strong> działający jedynie
          w Stanach Zjednoczonych. Obecna dominującą technologią w sieci
          komórkowej jest sieć 4 generacji, jednak już wiele urządzeń korzysta
          sieci 5 generacji, pozwalającej na 100 razy szybsze transfery oraz
          większą pojemność komórek.</li>
        <li><strong>Szerokopasmowe łącza satelitarne</strong> - Tego rodzaju
          technologią jest wyborem ostatecznym. Działa tam gdzie inne
          technologie są niedostępne. Technologia ta korzysta z satelit
          krążących po orbice ziemi.</li>
      </ul>
      <p>
        Na tym kursie, będziemy skupiać się na bezprzewodowych sieciach LAN.
        Sieci te pracują z częstoliwoscią 2.4 GHz lub 5 GHz. Wykorzystując przy
        tym odpowiednie standardy IEEE 802.11, takie jak:
      </p>
      <ul>
        <li><strong>802.11</strong> - 2.4 GHz - Prędkość do 2 Mbps.</li>
        <li><strong>802.11a</strong> - 5 GHz - Prędkość do 54Mb/s, mniejszy
          zasięg, brak kompatybliność z poźniejszym standardami.</li>
        <li><strong>802.11b</strong> - 2.4 GHz - Prędokość do 11 Mb/s, większy
          zasięg, niż 802.11a, lepsza propagacja sygnału.</li>
        <li><strong>802.11g</strong> - 2.4 GHz - Prędkość do 54Mb/s,
          kompatybilny z 802.11b.</li>
        <li><strong>802.11n</strong> - 2.4 GHz/5 GHz - Wyższa prędkość transmisji
          od 150 do 600Mb/s przy dobrych warunkach środowiskowych (propagacji).
          Punkty dostępowe oraz klienci wymagają wielu anten oraz technologi
          MIMO, kompatybilny z 802.11a/b/g, z uwzględenieniem ograniczeń
          prędkości.</li>
        <li><strong>802.11ac</strong> - 5GHz - zapewnia szybkość transmisji od
          450 do 1,3Gb/s wykorzystując MIMO. Obsługuje do ośmiu anten.
          Kompatybilny z urządzeniami 802.11a/n z uwzględnieniem ograniczeń
          prędkości.</li>
        <li><strong>802.11ax</strong> - 2.4GHz/5GHz - Najnowszy standard
          umożliwiający wyższe szybkości transmisji danych, wiekszą wydajność,
          obsługę wielu urządzeń oraz poprawioną wydajność energetyczną.</li>
      </ul>
      <p>
        Na normalizację standardów bezprzewodowych, odpowiada trzy
        organizacje: ITU (regulacje częstotliwości radiowych i orbit
        satelitarnych), IEEE (modulacja sygnałów częstoliwości radiowej),
        oraz WiFi Alliance, które nie tyle zajmuje się normalizowaniem
        łączności bezprzewodowej co promowanie rozwoju technologii oraz
        wydawanie producentom odpowiednich certyfikatów za zgodność ze
        standardami.
      </p>
      <h2 id="2.12.1.wlancomponents">2.12.1. Komponenty siec WLAN</h2>
      <p>
        Jako komponenty sieci bezprzewodowej możemy wymienić takie jak:
      </p>
      <ul>
        <li><strong>Bezprzewodowe karty sieciowe</strong> - specjalnego rodzaju
          adapter wpinany w porty USB lub montowany w komputerze, aby móc
          wykorzystać częstotliwości radiowe jako medium transmisyjne.</li>
        <li><strong>Bezprzewodowy router domowy</strong> - urządzenie sieciowe
          integrujące w sobie 3 rodzaje urządzeń: punkt dostepowy, przełącznik
          oraz router. Zapewnia użytkownikom domowym za pewnia zarówno
          przewodowy jak i bezprzewodowy dostęp do Internetu.</li>
        <li><strong>Bezprzewodowe punkty dostępowe</strong> - punkt dostępowy
          łączy hosty bezprzewodowe z siecią kablową. Jego zadaniem jest
          właśnie pozwolić urządzeniom, które nie mogą fizycznie wpiąć kabla
          na dostęp do takich samych zasobów, jak hosty kablowe. Oczywiście
          w teorii.</li>
      </ul>
      <p>
        Same punkty dostępowe dzielą się na dwie kategorie:
          <strong>autonomiczne punkty dostępowe</strong> oraz
          <strong>bezprzewodowe punkty dostępu oparte na kontrolerze</strong>.
          Autonomiczne punkty to zwykłe urządzenia, które podłączamy do
          prądu i do sieci następnie konfigurujemy, i to wszystko. W przypadku
          tej drugiej kategorii, punkty dostępowe można powiedzieć, że służą
          z nadajniki sygnału radiowego. O większości rzeczy decyduje kontroler,
          w którym to konfigurujemy całą infrastrukturę. W przypadku
          autonomicznych punktów, trzebą by te czynności powtórzyć, lub 
          załadować konfigurację. W przypadku kontrolera robimy to raz. W tym
          również przypadku (kontrolera) konfiguracja może okazać nieco
          bardziej skonplikowana.
      </p>
      <p>
        Ostatnim z komponentów są <strong>anteny</strong>, do wyboru mamy:
        <strong>dookólne</strong> - które propagują sygnał w kształcie kuli,
        <strong>kierunkowe</strong> - których propagacja jest bardziej
        skupiona w jednej wiązce sygnału (takie anteny trzeba ustawiać).
        Ostatnim rodzajem anten są to anteny <strong>MIMO</strong> - system
        wielu anten, który stostuje aby zwiększyć przepustowość, tego rodzaju
        rozwiazania wykorzystywane są w standardaach od 802.11n do ax. W MIMO
        można używać nawet do 8 anten.
      </p>
      <h2 id="2.11.2.howwlanworks">2.11.2. Działanie sieci WLAN</h2>
      <p>
        Lokalne sieci bezprzewodowe, podobnie do sieci kablowych mają określone
        topologie, określane mianem trybu pracy, takimi jak:
      </p>
      <ul>
        <li><strong>Tryb ad hoc</strong> - w tym trybie urządzenia łączą się
          ze sobą. Każdy z każdym, bez udziału punktu dostępowego lub
          routera bezprzewodowego. Tego typu siecią są, wszelkie połaczenia
          <em>Bluetooth</em>.</li>
        <li><strong>Tryb infrastruktury</strong> - gdzie do połączenia
          wykorzystywany jest punkt dostępowy lub router bezprzewodowy.
          Te urządzenia łączą się do sieci przy użyciu systemu dystrybucyjnego
          jakim raczej będzie <em>Ethernet</em>.</li>
        <li><strong>Tethering</strong> - w tym trybie pracy urządzenia łączą
          się z punktem centralnym, aby uzyskać dostęp do innej sieci
          bezprzewodowej, takiej jak sieć komórkowa. Ten tryb pracy jest
          odmianą trybu <em>ad hoc</em>.</li>
      </ul>
      <p>
        Tryb infrastruktury dzieli się na dwa bloki konstrukcyjne. Podstawowy -
        BSS oraz rozszerzony - ESS. W przypadku <strong>BSS</strong> jeśli 
        wyjdziemy poza
        obszar zasiegu naszej sieci bezprzewodowej, wówczas utracimy możliwość
        komunikacji z innymi jej hostami. Natomiast w przypadku
        <strong>ESS</strong> gdzie punkty dostępowe rozgłaszające BSS są
        połączone ze sobą za pomocą systemu dystrybucyjnego, nie stracimy
        łączności z hostami naszej macierzystej BSS, mimo opuszczenia obszaru
        jej działania.
      </p>
      <p>
        Ramka 802.11 różni się w nagłówku od standardowej ramki
        <em>Ethernet</em>. Zawiera ona takie pola jak:
      </p>
      <ul>
        <li><strong>Kontrola ramki</strong> - Identyfikuje rodzaj ramki 
          bezprzewodowej i
          zawiera pola podrzędne, takie jak wersja protokołu, typ ramki, typ
          adresu, zarządzanie energią oraz ustawienia zabezpieczeń.</li>
        <li><strong>Czas trwania</strong> - zazwyczaj używane do określenia
          czasu pozostałego do odbioru ramki.</li>
        <li><strong>Adres 1</strong> - Zazwyczaj zawiera adres MAC
          bezprzewodowego urządzenia odbierającego lub punktu dostępu.</li>
        <li><strong>Adres 2</strong> - Zazwyczaj zawiera adres MAC
          bezprzewodowego urządzenia wysyłającego lub punktu dostępu.</li>
        <li><strong>Adres 3</strong> - Czasami zawiera docelowy adres MAC,
          przykładowo adres interfejsu routera (bramy domyślnej), do którego
          połączony punkt dostępu.</li>
        <li><strong>Sekwencja kontrolna</strong> - zawiera informacje do
          kontrolowania skwencjonowania i fragmentowania ramek.</li>
        <li><strong>Adres4</strong> - Przeważnie pozostaje pusty, ponieważ
          stosuje się go tylko w trybie <em>ad hoc</em>.</li>
      </ul>
      <p>
        Poza nagłówkiem w ramce znajduje się jeszcze pole danych oraz pole
        sumy kontrolnej (FCS).
      </p>
      <p>
        Sieci WLAN wykorzystują półdupleksowe medium w postaci kanału
        częstotliwości radiowej. Przez co nie możliwe jest jednoczene
        nadawanie i odbieranie danych. Dlatego też w bezprzewodowych sieciach
        LAN do kontroli dostępu do medium, wykorzystywany jest algorytm
        <strong>CSMA/CA</strong>, który jest
        wariacją algorytmu CSMA/CD, znanego z technologii <em>Ethernet</em>.
      </p>
      <p>
        Połącznie bezprzewodowe klienta oraz punktu dostępu czy bezprzewodowego
        routera, nazywane jest <strong>skojarzeniem</strong>, jest to
        proces trój-etapowy, w którym to klient musi: wykryć punkt dostępu,
        uwierzytelnić się przed nim i przypisać (skojarzyć) się pod niego. Aby
        do tego doszło muszą zgadzać się takie czynniki jak: SSID (nazwa sieci),
        hasło (bez tego uwierzytelnianie nawet się nie uda), tryb sieci
        (standardy, chociaż większość standardów jest kompatybilna wstecz),
        tryb zabezpieczeń (zgodność między stronami z WEP, WPA, WPA2, WPA3),
        czy ustawienia kanału. Te parametry muszą być ustawione na obu
        stronach takie same, aby doszło do skojarzenia.
      </p>
      <p>
        Samo wykrywanie sieci bezprzewodowych może odbywać w dwóch trybach.
        W trybie <strong>pasywnym</strong> punkt dostępu wysyła co jakiś czas
        ramki 802.11, zwane <em>beacon</em>-ami. Zawierają one, nazwe sieci,
        obsługiwane standardy oraz ustawienia zabezpieczeń. W przypadku drugiego
        trybu <strong>aktywnego</strong>, to klient wysyła próbki w przestrzeń
        w celu znalezienia punktu dostępu rozgłaszającego żądaną przez niego
        sieć. W takiej próbce wysyła nazwę sieci oraz obsługiwane standardy,
        wówczas punkt dostępu odpowiemu podobnym komunikatem uzupełnionym o
        ustawienia zabezpieczeń. Obecnie urządzenia klientów, działają
        zarówno w jednym jak i w drugim trybie. Wyświetlając dostępne
        sieci - poprzez tryb pasyny i próbując podłączyć się sieci, z którymi
        już wcześniej się łączyły - przez tryb aktywny. Tryb aktywnym możemy
        wymusić pod czas konfiguracji sieci bezprzewodowej, ukrywając jej
        nazwę.
      </p>
      <h2 id="2.12.3.capwap">12.3. Działanie CAPWAP</h2>
      <p>
        Do tej pory mówilśmy o autonomicznych punktach dostępowych. To teraz
        coś o punktach dostępowych zarządzanych przez kontroler.
      </p>
      <p>
        <strong>CAPWAP</strong> jest protokołem pozwalającym na zarządzanie
        wieloma punktami dostepowymi jak i sieciami WLAN. Jest on również
        odpowiedzialny za enkapsulację i przezywanie ruch klienta między AP
        oraz WLC. Jest to protokołu otwarty, opracowany przez IEEE.
      </p>
      <p>
        Ważnym elementem działania CAPWAP jest rodzielenie kontroli dostępu
        do medium między dwa komponenty: MAC AP oraz MAC WLC.
      </p>
      <p>
        MAC AP odpowiada za <em>beacon</em>-y oraz odpowiedzi na próbkowanie,
        przetwarzenie pakietów i retransmisje, kolejkowanie ramek i
        priorytetyzacje oraz szyfrowanie i deszyfrowanie warstwy MAC.
      </p>
      <p>
        Natomiast MAC WLC odpowiada za uwierzytelnienie, skojarzenia i 
        ponowne kojarzenie klientów roamingowych, translacji ramek na inne
        protokoły oraz zakończenie ruchu 802.11 na interfejsie przewodowym.
      </p>
      <p>
        Możliwe jest dodatkowe zabezpieczenie zarówno danych klientów jak i
        danych sterujących między WLC a AP, za pomocą protokołu
        <strong>DTLS</strong>. Domyślnie ten protokół, jest włączony dla
        ruchu sterującego, ale dla ruchu danych musi zostać włączony przez
        adminstratora. Dodatkowo DTLS, gdy ma szyfrować dane użytkowników 
        wymaga licencji,
        w którą należy się zaopatrzyć przed uruchomieniem tego protokołu na
        AP. DTLS daje dodatkową warstwę ochrony, gdzie tak naprawdę jej nie
        ma. Metody zabezpieczeń sieci bezprzewodych tyczą się tylko i wyłącznie
        odcinka od klient do punktu dostępowego.
      </p>
      <p>
        Oczywiście możliwe jest kontrolowanie przez WLC, punktów dostępowych
        w innych sieciach, także w oddziałach firmy przez Intenet. Niestety
        połączenia internetowe bywają zawodne na co 
        firma Cisco swojego czasu wprowadziła takie rozwiązania jak
        <strong>FlexConnect AP</strong>, pozwalają one działanie w dwóch 
        trybach w trybie Autonomicznym i WLC. W zależności od dostępności WLC
        przez CAPWAP. Jeśli nie będzie miał on połączenia z WLC to wówczas
        przejmie część obowiazków na siebie, np. przełącznie ruchu danych
        klienta czy wykonywanie uwierzytelniania.
      </p>
      <h2 id="2.12.4.managingtransmissionchannel">2.12.4. Zarządzenia kanałem transmisji</h2>
      <p>
        Urządzenia korzystające ze sieci bezprzewodowych, są odbiornikami
        radiowymi dostrojonymi do określonej częstotliwości. Częstotliwości
        za przypisywane w zakresach, nazwanych <strong>kanałami</strong>.
        Gdy dany kanał jest zbyt intensywnie wykorzystywany wówczas staje się
        kanałem przesyconym, co pogarsza warunki transmisyjne. Przez lata
        opracowano kilka technik pozwalających zmniejszyć przesycenie kanałów
        w sieci bezprzewodowych wykorzystuje się trzy z nich: DSSS,
        FHSS (<em>bluetooth</em>) oraz <strong>OFDM</strong>, który jest
        wykorzystywane przez obecnie stosowane standardy sieci bezprzewodowych.
        Najnowszy standard wykorzystuję odmianę OFDM - OFDMA. 
      </p>
      <p>
        W wiekszości standandardów sieci WLAN wykorzystujących częstotliwość
        2,4 GHz
        mają do dyspozycji 11 kanałów (dla Ameryki Północnej), 13 (dla Europy),
        oraz 14 (dla Japonii) w zależności od położenia geograficznego sieci.
        Było by wszystko w porządku gdyby nie fakt, że każdy kanał ma
        przydzielone pasmo 22 MHz i kanały odzielone są od siebie o 5 MHz.
        Co oznacza, że one nakładają się na siebie, w praktyce jeśli sieci,
        które punkty dostępowe rozgłaszają sieci z ustawionymi kanałami zbyt
        blisko siebie to mogą się one wzajemnie zakłócać. Dlatego też
        konfigurując ten parameter, warto wiedzieć o tym że tylko częstotliwość
        co cztery kanały, tj. 1, 6 i 11, nie będą się na siebie na kładać.
      </p>
      <p>
        Nieco inaczej jest w przypadku częstotliwości 5 GHz. Tutaj są 24 kanały
        oddzielone od siebie o 20 MHz. Mimo, że występują drobe nałożenia, to
        kanały nie bedą się zakłócać. W przypadku tej częstotliwości kanały
        numerowane są od 36 co 4 do 64, następnie do 100 do 140, ostatnią
        grupą jest są kanały od 149 do 161 i co dwa kanały występuję kanał,
        którego częstotliwość nie będzie wchodzić w częstotliwość innego kanału. 
      </p>
      <p>
        Chcąc wdrożyć sieć WLAN, w firmie należy wziąć pod uwagę takie czynniki
        jak: dobre rozgłaszanie sygnału (najlepiej na środku biura), 
        potencjalne źródła zakółceń czy
        umiejscowienie punktów dostępowych (powinny znajdować się tam gdzie
        zazywczaj będą klienci). 
      </p>
      <h2 id="2.12.5.wlanthreats">2.12.5. Zagrożenia w sieciach WLAN</h2>
      <p>
        Sieci bezprzewodowe niosą ze sobą oczywiście wiele zagrożeń. Pierwszą
        taką obawą jest fakt, że do takiej sieci może podłączyć się każdy,
        ponieważ nie możemy okiełznać fal radiowych - zamykając je w jednym
        pomieszczeniu (oczywiście tych, z których korzystamy na codzień). Mając
        odpowiedni sprzęt możemy próbować się podłączyć do sieci będącej
        dość głęboko w budynku. Te warunki fizyczne niosą ze sobą kilka
        zagrożeń takich jak: 
      </p>
      <ul>
        <li><strong>Przechwytywanie danych</strong> - informacje w sieci
          bezprzewodowej powinny być szyfrowane, aby zapobiec przechywceniu.</li>
        <li><strong>Intruzi bezprzewodowi</strong> - techniki uwierzytelniania
          w sieciach bezprzewodowych szybko zniechęcają nieutoryzowanych
          użytkowników próbujących uzyskać dostęp do zasobów sieciowych.</li>
        <li><strong>Ataki odmowy usługi (DoS)</strong> - czasami sieć
          bezprzewodowa może nie działać prawidło i może mieć to dwojaką
          przycznę, albo jest to przypadek, albo celowe złośliwe działanie.</li>
        <li><strong>Obce punkty dostępu</strong> - atakujący mogą próbować się
          podszywać pod obecną infrastrukturę, w celu potencjalnego wyłudzenia
          danych.</li>
      </ul>
      <p>
        Ataki DoS w sieciach WLAN mogą wynikiem: nierprawidłowej konfiguracji
        urządzeń - urządzenia mogły zostać źle skonfigurowane przypadkowo lub
        celowo przez intruza, przez co prawowici użytkownicy nie mogą korzystać
        z połączeń bezprzewodowych; Intruzi mogą celowo ingerować w komunikację
        poprzez zakłócenie, wyłączenie sieci lub podstawienie punktu
        dostępowego, które nie zapewni odpowiedniej komunikacji z innymi
        hostami czy zasobami sieci. Taki atak DoS, może też zostać wywołany
        przez nas samych prze nieuwagę, wystarczy gdzieś między hostem a
        punktem dostępowym ustawić źródło zakłóceń. W przypadku 5 GHz, to ta
        częstotliwość jest bardziej odporna na zakłócenia, ponieważ w naszym
        otoczenie nie znajduje się wiele urządzeń, które mogły by emitować
        tą częstotliwość.
      </p>
      <p>
        Obce punkty dostępowe mogą być umieszczane na obszarze sieci z dwóch
        różnych pobudek. Pierwszą z nich jest przeprowadzenie ataku
        <em>Man in the Middle</em>, w celu przechwycenia informacji
        użytkowników sieci bezprzewodowych lub celu odłączenia go od zasobów
        sieci. Jedną z metod ochrony, jest skanowanie częstotliwości w celu
        w celu wykrycia takich podstawionych urządzeń. Inną metodą jest
        skonfigurowanie nie słabszego niż WPA2 AES (będzie o tym w następnym
        podrozdziale) trybu uwierzytelniania.
      </p>
      <p>
        O ataku <em>Man in the Middle</em> wpominaliśmy podczas omawiania
        obecego punktu dostępu. Atak tego typu polega na ustawieniu się
        atakującego w roli pośrednika, w celu przechwycenia informacji
        wysyłanych i odbieranych przez innych użytkowników sieci. Czasami do
        przeprowadzenia takiego ataku wystarczy odpowiednie warunki sieciowe
        oraz odpowiednia antena, warunki sieciowe i oprogramowanie.
      </p>
      <h2 id="2.12.6.securingwlans">2.12.6. Zabezpieczanie sieci WLAN</h2>
      <p>
        Metod na zabezpieczenie sieci WLAN jest kilka. Możemy zaczać od tego,
        że wymusimy na klientach tryb aktywny, po przez ukrycie SSID oraz
        dodamy do odpowiedniej listy adresy MAC urządzeń, które faktycznie mają
        łączyć się z tą siecią. Jednak zabepieczenia tego typu to tylko
        protezy, jeśli nie mamy zaimplementowanych metod uwierzytelniania. 
      </p>
      <p>
        Metody uwierzytelniania możemy wydzielić dwie, pierwszą z nich jest
        <strong>uwierzytelnianie systemu otwartego</strong>, ta metoda to
        tak naprawdę jego brak. Klikamy nazwę sieci i jesteśmy podłączeni.
        Obecnie nawet publicznie dostępne sieci, rezygnują z tego rozwiązania
        na rzecz udostępionego publicznie klucza współdzielnego (tzw. hasła do
        WiFi). Drugą metodą powszechnie stosowaną jest użycie <strong>klucza
        współdzielonego</strong>, metoda ta wymaga znajomości tego klucza, 
        przez klienta.
        Ta metoda poza uwierzytelnieniem zapewnia szyfrowanie transmisji danych
        między klientem a punktem dostepu.
      </p>
      <p>
        Metoda uwierzytelniania z użyciem klucza posiada klika wykorzystywanych
        w sieciach technik, takich jak: WEP, WPA, WPA2, WPA3. 
      </p>
      <ul>
        <li><strong>Wired Equivalent Privacy (WEP)</strong> - słaby
          standard zabezpieczeń, łatwy do złamania. Nie powino się go
          sotosować.</li>
        <li><strong>Wi-Fi Protected Access (WPA)</strong> - pierwszy ze
          standarów WPA, ten rodzaj korzysta z WEP, ale stosuje silniejsze
          szyfrowanie w postaci mechanizmu TKIP, który zmienia klucz dla
          każdego pakietu.</li>
        <li><strong>WPA2</strong> - standard bezpieczeństwa sieci
          bezprzewodowych. Wykorzystuje zawansowany i silny mechanizm
          szyfrowania <strong>Advanced Encryption Standard</strong>
          (AES). Uważany za najśliniejszy mechanizm szyfrowania, do tej pory.</li>
        <li><strong>WPA3</strong> - najnowszy standard uwierzytelniania w
          sieci bezprzewodowej, urządzenia z jego obsługą nie pozwalają na
          korzystanie z innych starszych rozwiązań, wymagają również
          stosowania mechanizmy Protect Management Frames (PMS).</li>
      </ul>
      <p>
        Chcąc skonfigurować metodę uwierzytelnia na domowym routerze możemy
        spotkać się z różnymi technikami, takimi jakie wpisałem powyżej,
        natomiast w przypadku WPA oraz WPA2, będzie mieć do czynienia z:
      </p>
      <ul>
        <li><strong>Personal</strong> - uwierzytelnienia z pomocą klucza
          współdzielonego, dobre do zastosowań domowych, gdzie możemy
          zaufać urządzeniom i użytkownikom.</li>
        <li><strong>Enterprise</strong> - uwierzytelnienia za pomocą
          polecenia serwera uwierzytelniania znanego z protokołu 802.1X,
          takiego jak <strong>RADIUS</strong>, gdzie wówczas punkt dostępu
          jest wystawcą uwierzytelniania. Klient natomiast do połączania się
          do takiej sieci, będzie musiał podać swój indywidualny login oraz
          hasło ustalane przez administratora. Dodatkowo punkt dostępowy
          będzie musiał się uwierzytelnić sam przed serwerem RADIUS, aby móc
          uwierzytelniać pracowników, przy użyciu klucza zapisanego w
          konfiguracji.</li>
      </ul>
      <p>
        Po wybraniu techniki uwierzytelniania, pozostanie nam wybór metody
        szyfrowania. Do wyboru będziemy mieć dwie opcje:
      </p>
      <ul>
        <li><strong>Temporal Key Intergration Protocol (TKIP)</strong> -
          metoda używana przez WPA, zapewnia obsługę starszego sprzetu,
          wykorzystując do tego WEP, ale eliminującego jego pierwotne wady.</li>
        <li><strong>Advanced Encryption Standard (AES)/CCMP</strong> - metoda 
          wykorzystywana przez WPA2, jest
          preferowana, ze względu na znacznie silniejsze metody szyfrowania,
          wykorzystuje metodę CCMP, dlatego też czasem jest tak nazywany.</li>
      </ul>
      <p>
        Konfiguracja technik uwierzytelniania w klasie <em>Enterprise</em>
        wymaga podania metody szyfrowania, adresu IP serwera RADIUS, portu 
        serwera - zazwyczaj: UDP/1812, UDP/1645 oraz wspólnego klucza. Dzięki
        niemu punkt dostępowy uwierzytelni się na serwerze RADIUS.
      </p>
      <p>
        WPA3 jest nowy standardem bezpieczeństwa w sieciach bezprzewodowych.
        Standard WPA2 nie może już zostać uznany za bezpieczny. Tryb
        personalnego WPA3 udaremnia ataki siłowe, dla trybu Enterprise
        eliminuje mieszanie protokołów bezpieczeństwa z poprzednich standardów
        802.11. WPA3 pozwala na szyfrowane sieci otwartych, w których nie
        podaje się żadnych haseł, a przesłanie danych między klietem a AP nadal
        jest bezpieczne. WPA3 poprawia uwierzytelnianie wśród składników
        internetu rzeczy, eliminując potrzebę działania niebezpiecznego
        mechanizmu WPS.
      </p>
      <h2 id="2.12.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy z działaniem sieci bezprzewodowych
        poznaliśmy ich rodzaje, które występują wokół nas, ich topologie, z
        których korzystamy na co dzień w domu, w szkole czy w pracy.
        Dowiedziliśmy się w jaki sposób sieci bezprzewodowe, wykorzystują
        przekazaną im częstotliwość radiową. Na koniec poznaliśmy zagrożenia
        na jakie możemy się natknąć podczas konfiguracji, administracji czy
        też korzystania z takich sieci, jednak dowiedziliśmy się jak można się
        przed nimi uchronić, jakie metody uwierzytelniania wybrać oraz
        jakie je skonfigurować.
      </p>
      <h1 id="2.13.wlanconfiguration">2.13. Konfiguracja siec WLAN</h1>
      <p>
        Bezprzewodowe punkty mogą dzielić się na dwie kategorię. Pierwszą z
        nich są autonomiczne punkty dostepowe, które podłącza się do prądu,
        do sieci i konfiguruje. Jeśli ma być więcej niż jeden to trzeba te
        czynności wykonać, dla każdego urządzenia z osobna. Taka konfiguracja
        jest przewidziana średniej wielkości firmy. W przypadku domu lub
        małego biura raczej wystarczy <strong>router bezprzewodowy</strong>.
      </p>
      <p>
        Ze względu, że zakres materiału obejmuje konfiguracje sieci
        bezprzewodowej, to skupimy się na podstawowej konfiguracji takiego
        urządzenia.
      </p>
      <p>
        Na początek musimy zalogować na routerze do panelu pozwalającego na
        konfigurację. Większość urządzeń domowych pozwala na dostęp do panelu
        administracyjnego z poziomu przeglądarki internetowej. Dane dostępowe
        mogą znajdować, albo na spodzie urządzenia na naklejce lub w instrukcji
        do niego dołączonej.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh1.png" />
      </p>
      <p>
        Następną czynnością jest zmiana domyślnego hasła administratora
        urządzenia. Tym przypadku klikamy zakładkę
        <code class="code-inline">Administration</code>, następnie w sekcji
        <code class="code-inline">Router Access</code> podajemy nowe hasło dwa
        razy w celu potwierdzenia. Zapisujemy ustawienia przy użyciu
        przycisku <code class="code-inline">Save Settings</code>. Urządzenie
        wyloguje nas i poprosi o zalogowanie się nowym hasłem.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh2.png" />
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh3.png" />
      </p>
      <p>
        Po wykonaniu tej czynności, wypadało by ustawić jakiś adres IP dla
        naszej sieci LAN. Przy czym tutaj należy pamiętać o tym, aby również
        zaktualizować adresy IP w konfiguracji serwera DHCP. W zakładce
        <code class="code-inline">Setup</code>, w sekcji
        <code class="code-inline">Router IP</code> ustawiamy adres dla naszej
        sieci oraz wybieramy maskę. W sekcji
        <code class="code-inline">DHCP Server Settings</code> początęk puli
        w opcji <code class="code-inline">Start IP Address</code> oraz jej
        koniec <code class="code-inline">Maximum number of Users</code>.
        Na końcu zapisujemy ustawienia. Router prawdopodobnie uruchomi się
        ponownie, po chwili uzyskamy adres IP z nowej sieci i będziemy mogli
        ponownie się na niego zalogować.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh4.png" />
      </p>
      <p>
        Po zmianie tych podstawowych ustawień możemy przjeść do konfiguracji
        sieci bezprzewodowej. Ustawienia sieci bezprzewodowej znajdują się
        zakładce <code class="code-inline">Wireless</code>. Na początku
        w opcji <code class="code-inline">Network Mode:</code> możemy wybrać
        tryb sieci. Jeśli taka sieć miała by obsługiwać stare urządzeń to
        wypadałoby wybrać opcję <em>Legacy</em>, ale tryb mieszany
        (<em>Auto</em>), jest również poprawnym ustawieniem.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh5.png" />
      </p>
      <p>
        Następną konfigurajcą jest zmiana SSID, na taki jaki odpowiada naszym
        preferencjom, SSID powinień pozwolić nam rozpoznać sieć. SSID
        konfigurujemy w opcji <code class="code-inline">Network Name (SSID):</code>
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh6.png" />
      </p>
      <p>
        Następnie wybieramy dla naszej sieci kanał, warto wspomnieć, że w
        przypadku częstotliwości 2,4 GHz mamy do wyboru tylko 3 kanały.
        W celu sprawdzenia kanałów na których działają sieci w naszym
        otoczeniu, mozemy wykorzystać specjalne oprogramowanie na dystrybucje
        Linuksa, w tym Kali Linux lub na smartfon z systemem Android.
      </p>
      <p>
        Kanał ustawiamy za pomocą opcji
        <code class="code-inline">Standard Channel</code>.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh7.png" />
      </p>
      <p>
        Pod zakładką <code class="code-inline">Wireless</code> znajdują się
        podzakładki. Jedną z nich jest <code class="code-inline">Wireless
        Security</code>, w niej będziemy ustawiać opcje bezpieczeństwa sieci
        bezprzewodowej. Na początku musimy przestawić opcje
        <code class="code-inline">Security Mode</code> z <em>Disabled</em> na
        <em>WPA2 Personal</em>.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh8.png" />
      </p>
      <p>
        Po zmianie trybu, ukaże na się więcej opcji takich jak wybór metody
        szyfrowania czy pole gdzie możemy zdefiniować hasło klucza
        współdzielonego.
        Metoda szyfrowania, jest akurat domyślnie ustawiona dobra, więc jej
        zmieniać nie trzeba, ale hasło klucza należy ustawić. W polu
        <code class="code-inline">Passphrase:</code>
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh9.png" />
      </p>
      <p>
        W ten sposób skonfigurowaliśmy router bezprzewodowy do działania na
        nie wielkim obszarze. No właśnie, zasięg takiego urządzenia może wachać
        się od 5 do 10 metrów w obszarze silnie zabudowanym. Dlatego też aby
        wzmocnić sygnał można zastosować punkty dostępowe, które bedą działać
        w trybie kratowym. Na podobnej zasadzie działają również wzmaczniacze
        sygnału.
      </p>
      <p>
        Routery domowe aby zapenić dostęp do Internetu hostom sieci lokalnej,
        realizują funkcję <strong>NAT</strong>-u. Translację adresów źródłowych
        w pakietach
        wychodzących i adresów docelowych w pakietach przychodzących. Funkcja
        NAT-u realizowana jest przez <em>firewall</em>. <em>Firewall</em> jest
        też odpowiedzialny za inną funkcjonalność, taką jak jest
        <strong>przekierowanie portów</strong>. Ma ona na celu zapewnienie
        dostępu do hostów w sieci wewnętrzne (np. serwerów i ich usług) z
        zewnątrz. Do poprawnego działania taka funkcjonalość wymaga
        przydzielenia od usługodawcy stałego adresu IP, co może być dostępne
        wyłącznie dla klientów biznesowych. Ta funkcja działa na takiej
        zasadzie, że wewnętrzny port usługi wraz z IP hostującego komputera
        przypisuje się do zewnętrznego adresu IP do wybranego portu. Porty
        mogą być powiązane 1:1, tj. port wewnętrzny może mieć taką samą
        wartość jak port zewnętrzny.
      </p>
      <h3 id="2.13.pka">Zadanie praktyczne - Packer Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.1.10-packet-tracer---configure-a-wireless-network_pl-PL.pdf">Konfiguracja sieci bezprzewodowej - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.1.10-packet-tracer---configure-a-wireless-network_pl-PL.pka">Konfiguracja sieci bezprzewodowej - zadanie</a>
      </p>
      <h3 id="2.13.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/13.1.11-lab---configure-a-wireless-network_pl-PL.pka">Konfiguracja sieci bezprzewodowej</a> 
      </p>
      <h2 id="2.13.1.wlcbasics">2.13.1. Konfiguracja podstawowej sieci WLAN w sieci WLC</h2>
      <p>
        Po omówieniu autonomicznych punktów dostępowych przyszedł czas 
        na WLC. Dostęp do kontrolera otrzymuje w takim sam sposób jak do
        routera bezprzewodowego. Przyczym kontrolery mogą mieć domyślnie
        ustawiony adres IP, a nawet skonfigurowany serwer DHCP. Dlatego też
        na początku warto podłączyć go do swojego komputera. Po wpisaniu
        adresu naszym oczom ukaże się taka o to strona. Na której musimy
        zdefiniować domyślnego użytkownika oraz nadać mu odpowiednie hasło.
        Hasło musi składać z min. 6 znaków, z jednej wielkiej litery i jednej
        cyfry.
      </p>
       <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh10.png" />
      </p>
      <p>
        Następnie urządzenie przeprowadzi nas przez wstępną konfigurację.
        W niej ustawimy nazwę systemową, kraj, datę i godzinę, strefę czasową,
        opcjonalnie serwer NTP. W drugiej części ustawimy konfigurację IP
        interfejsu zarządzania.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh11.png" />
      </p>
      <p>
        W drugiej części konfiguracji musimy zdefiniować chociaż jedną z sieci,
        a więc podajemy <code class="code-inline">Network Name</code> (SSID),
        wybieramy tryb uwierzytelniania (zostawiamy domyślnie, jest dobry),
        następnie hasło. Ustawienie zaawansowane może zostawić domyślnie.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh12.png" />
      </p>
      <p>
        W następnym oknie zostanie nam wyświetlone podsumowanie konfiguracji i
        musimy je potwierdzić za pomocą przycisku
        <code class="code-inline">Apply</code>
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh13.png" />
      </p>
      <p>
        Po zapisaniu ustawień urządzenie zostanie uruchomione ponownie. Po
        pewnym czasie może nic się nie dziać, należy wówczas zamknąc
        przeglądarkę i wpisać adres ponownie. Zapewne uzyskamy odpowiedź
        <em>Server Reset Connection</em>, wówczas trzeba zmienić w adres z
        <em>http</em> na <em>https</em>. Naszym oczom ukaże się taka o strona.
      </p>
      <p style="width: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh14.png" style="width: 100%;"/>
      </p>
      <p>
        Klikamy zielony przycisk <code class="code-inline">Login</code>, pojawi
        się okienko do logowania. Wpisujemy login oraz hasło, następnie klikamy
        <code class="code-inline">Login</code>. Po zalogowaniu ukaże na się
        taka o to strona.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh16.png" style="width: 100%;"/>
      </p>
      <p>
        Domyślną stroną startową jest podsumowanie, zawiera ona informacje
        zbiorcze na temat samego kontrolera, punktów dostępowych, klientów,
        wykrytych
        fałszywych elementów takich jak punkty dostępowe czy klienci. To
        podsumowanie zawiera również informacje o najczęściej wykorzystywanych
        sieciach WLAN oraz kilka dodatkowych informacji.
      </p>
      <p>
        Chcąc skonfigurować sieć bezprzewodową należy kliknąć, zakładkę WLANs,
        następnie, po prawej stronie znajduje się lista rozwijalna w niej 
        jeden element <code class="code-inline">Create New</code>, klikamy
        przycisk <code class="code-inline">Go</code>.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh17.png" style="width: 100%;"/>
      </p>
      <p>
        Podajemy nazwę profilu oraz SSID i klikamy przycisk
        <code class="code-inline">Apply</code>.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh18.png" style="width: 100%;"/>
      </p>
      <p>
        Po zatwierdzeniu zostanie przeniesieni w tryb edycji. W zakładce
        <code class="code-inline">General</code> zaznaczamy w
        <code class="code-inline">Status</code>,
        <code class="code-inline">Enabled</code>.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh19.png" style="width: 100%;"/>
      </p>
      <p>
        Następnie w zakładce <code class="code-inline">Security</code>, z listy
        <code class="code-inline">Layer 2 Security</code>, wybieramy
        <code class="code-inline">WPA+WPA2</code>, po wybraniu tego trybu
        zostaną nam wyświetlone dodatkowe opcje. W sekcji
        <code class="code-inline">WPA+WPA2 Parameters</code>, zaznaczamy
        <code class="code-inline">WPA2 Policy</code>, automatycznie zostanie
        wybrane <code class="code-inline">WPA2 Encryption</code> z domyślnie
        zaznaczonym <code class="code-inline">AES</code>. W sekcji
        <code class="code-inline">Authentication Key Management</code>
        zaznaczamy <code class="code-inline">PSK</code> i w polu
        <code class="code-inline">PSK Format</code> hasło klucza
        współdzielonego, zapisujemy konfigurację wpisując przycisk
        <code class="code-inline">Apply</code>
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh20.png" style="width: 100%;"/>
      </p>
      <p>
        Jak możemy zobaczyć na zrzucie poniżej, punkt dostępu podłączony do
        przełącznika zaczyna rozsyłać tą sieć skonfigurowaną na kontrolerze.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh21.png" style="width: 100%;"/>
      </p>
      <p>
        Niestety w przypadku PT, aplikacja PC Wireless działa tylko dla
        starszej karty. A laptop musi mieć kartę AC aby móc się z tą siecią
        połączyć.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh22.png" style="width: 100%;"/>
      </p>
      <h2 id="2.13.2.wlcinenterprise">2.13.2. Konfiguracja sieci WLAN WPA2 Enterprise w sieci WLC</h2>
      <p>
        Chcąc stosować bezprzewodowe punkty dostępowe na firmie wypadało by
        rozszerzyć funkcjonalność takiej sieci o uwierzytelniania korporacyjne
        oparte na serwerze RADIUS oraz protokoł monitorowania sieci SNMP.
      </p>
      <p>
        Konfiguracja SNMP na kontrolerze będzie przekazywać komunikaty 
        diagostyczne, zwane <strong>traps</strong> do serwera SNMP. Wskazanie
        adresu serwera SNMP na WLC ma miejsce w zakładce
        <code class="code-inline">Management</code>, następnie z menu po lewej
        stronie rozwijamy <code class="code-inline">SNMP</code> i wybieramy
        opcję <code class="code-inline">Trap Receivers</code>, następnie
        klikamy przycisk <code class="code-inline">New...</code>.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh23.png" style="width: 100%;"/>
      </p>
      <p>
        Dodając odbiornik komunikatów diagnostycznych (serwer SNMP), podajemy
        jego nazwę (<code class="code-inline">Community Name</code>) oraz
        adres IP. Zatwierdzamy zamiany,
        przyciskiem <code class="code-inline">Apply</code>
        Tak jak na poniższym zrzucie.
      </p> 
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh24.png" style="width: 100%;"/>
      </p>
      <p>
        Konfigurację uwierzytelniania na bazie serwera RADIUS rozpoczynamy od 
        dodania serwera do konfiguracji WLC. W zakładce
        <code class="code-inline">Security</code>, z menu po lewej stronie
        wybieramy kolejno: <code class="code-inline">AAA</code>,
        <code class="code-inline">RADIUS</code> oraz
        <code class="code-inline">Authentication</code>. Nowy serwer dodajemy
        poprzez kliknięcie przycisku <code class="code-inline">New...</code>.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh25.png" style="width: 100%;"/>
      </p>
      <p>
        Chcąc dodać serwer RADIUS do konfiguracji WLC, podajemy adres IP
        serwera następnie klucz współdzielony, którym WLC będzie uwierzytelniać
        się wobec serwera RADIUS. Jeśli nasz serwer RADIUS działa na innym
        porcie, to go również należy ustawić.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh26.png" style="width: 100%;"/>
      </p>
      <p>
        Teraz pozostaje nam tylko utworzyć nową sieć WLAN, i zakładce
        <code class="code-inline">Security</code>,
        <code class="code-inline">Layer 2</code>, w sekcji
        <code class="code-inline">Authentication Key Management</code> zamiast
        <code class="code-inline">PSK</code> zaznaczamy
        <code class="code-inline">802.1X</code>. Następnie w zakładce
        <code class="code-inline">AAA Servers</code>, w sekcji
        <code class="code-inline">Radius Servers</code>, w kolumnie
        <code class="code-inline">Authentication Servers</code>, przy
        <code class="code-inline">Server 1</code> wybieramy zdefiniowany
        wcześniej przez nas serwer RADIUS. Tak skonfigurowaną sieć możemy
        włączyć i spróbować się z nią połączyć.
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh27.png" style="width: 100%;"/>
      </p>
      <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh28.png" style="width: 100%;"/>
      </p>
      <p>
        W taki sposób wygląda bowiem podłączenie do sieci WLAN z
        uwierzytelnianiem <em>Enterprise</em>.
      </p>
       <p style="widht: 100%;">
        <img src="https://ftp.morketsmerke.org/img/srwe_13_confwlan_sh29.png" style="width: 100%;"/>
      </p>
      <h3 id="2.13.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.2.7-packet-tracer---configure-a-basic-wlan-on-the-wlc_pl-PL.pdf">Konfiguracja podstawowej sieci WLAN w WLC - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.2.7-packet-tracer---configure-a-basic-wlan-on-the-wlc_pl-PL.pka">Konfiguracja podstawowej sieci WLAN w WLC - zadanie</a>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.3.12-packet-tracer---configure-a-wpa2-enterprise-wlan-on-the-wlc_pl-PL.pdf">Konfiguracja sieci WLAN WPA2 Enterprise na WLC - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.3.12-packet-tracer---configure-a-wpa2-enterprise-wlan-on-the-wlc_pl-PL.pka">Konfiguracja sieci WLAN WPA2 Enterprise na WLC - zadanie</a>
      </p>
      <h2 id="2.13.3.wlantroubleshooting">2.13.3. Rozwiązaywanie problemów z siecią WLAN</h2>
      <p>
        Podczas administracji siecią WLAN, możemy spotkać się z problemem
        związanym ze skojarzeniem klienta z punktem dostępowym. Przyczyną
        takiego działania może być słaby zasięg, ale również ingerencja w
        ustawienia karty przez użytkownika. Warto również sprawdzić czy
        pomiędzy klientem a punktem nie ma żadnych źródeł zakłóceń. Często też
        przyczyną tego problemu jest źle wpisane hasło.
      </p>
      <p>
        Jeśli nasza sieć ma słabą wydajność to wówczas można pomyśleć nad
        wymianą urządzęń sieciowych na wyższy standard oraz o podzieleniu
        i priorytetyzacji ruchu. Można wówczas wykorzystać sieci 5GHz do
        ruchu, który naprawdę wymaga przepustowości, taki jak
        <em>streaming</em> wideo. Resztę ruchu można pozostać na częstotliwości
        2,4GHz.
      </p>
      <p>
        Ważne są również aktualizacje oprogramowania układowego punktów
        dostępowych czy kontrolera. Mogą one rozszerzać funkcjonalność tych
        urządzeń ale
        wprowadzać poprawki zarówno dla wydajności jak i bezpieczeństwa samych
        urządzeń oraz transmisji między nimi a klientami. 
      </p>
      <h3 id="2.13.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.3.12-packet-tracer---configure-a-wpa2-enterprise-wlan-on-the-wlc_pl-PL.pdf">Rozwiązywanie problemów z siecią WLAN - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/13.3.12-packet-tracer---configure-a-wpa2-enterprise-wlan-on-the-wlc_pl-PL.pka">Rozwiązywanie problemów z siecią WLAN - zadanie</a>
      </p>
      <h2 id="2.13.summary">Podsumowanie</h2>
      <p>
        W tym rodziałe dowiedzieliśmy się w jaki sposób skonfigurować sieci
        WLAN, oparte zarówno na autonomicznych punktach dostępowych jak tych
        opartych o kontroler WLC. Konfigurowaliśmy również sieci dla
        standard korporacyjny uwierzytelniania, na koniec poznaliśmy kilka 
        metod rozwiązywania problemów związanych z siecia WLAN i połączeniem
        się z nimi. 
      </p>
      <!--<h2 id="2.13.partialexam">Egzamin cząstkowy - Rozdziały: 10 - 13</h2>
      <p>
        <a href="Cisco_-_CCNA_-_SRWE_-_egzamin_czastkowy_roz_10_-_13.html">Egzamin z bezpieczeńswa warstwy 2 i sieci WLAN</a>
      </p>
      -->
      <h1 id="2.14.routingconcepts">2.14. Koncepcje routingu</h1>
      <p>
        Routery z założenia nie są wcale skomplikowanymi urządzeniami. Dla
        użytkowników małych firmy lub użytkowników domowych przygotowano
        specjalne urządzenia zwane routerem bezprzewodowym, który unifikuje
        w sobie kilka urządzeń sieciowych, takich jak: router, switch,
        firewall oraz punkt dostępowy. Jednak zastosowanie takich urządzeń jest
        mało skalowalne, dlatego też w przypadku zastosowań firmowych będziemy
        raczej spotykać się z osobnymi urządzeniami. 
      </p>
      <p>
        Routery mają dwa zadania:
      </p>
      <ol>
        <li><strong>Określenie nalepszej scieżki do punktu docelowego dla
          pakietu</strong></li>
        <li><strong>Przekazanie pakietu w stronę celu</strong></li>
      </ol>
      <p>
        Routery przechowują informacje o tym gdzie wysłać pakiet aby trafił
        on do celu w <strong>tablicy routingu</strong>. Elementami, które
        zawierają wpisy są
        między innymi adres sieci docelowej, jej maska - zapisana w notacji
        CIDR lub przy użyciu wartości dziesiętnej adresu IP, oraz adres
        kolejnego skoku - interfejsu następnego routera na ścieżce prowadzącej
        do sieci docelowej. Router chcąc określić trasę dla pakietu,
        przypasowuje adres docelowy do informacji zapisanych we wpisach tabeli,
        dokonuje tego po przez porównanie binarnych reprezentacji adresów IP
        ropoczynając jest od lewej strony. Jako przykład weźmy adres
        172.16.0.100, w tablicy występuje wpis 
        172.16.0.0/24 <em>via</em> 172.16.0.254, więc:
      </p>
<pre class="code-inline">
/24 = 255.255.255.0

172.16.0.100
255.255.255.0
172.16.0.0

10101100.00010000.00000000.01100100
11111111.11111111.11111111.00000000
10101100.00010000.00000000.00000000
</pre>
      <p>
        Określenie najlepszej trasy jest jednocześnie najdłuższym dopasowaniem.
        Oznacza to, że router dokona wyboru trasy na podstawie długości maski
        sieci docelowej, więc jeśli będziemy mieć adres docelowy pasujący do
        wielu ścieżek, to ostatecznie zostanie wybrana ta o
        <strong>najdłuższej masce</strong>. 
      </p>
<pre class="code-block">
Adres docelowy = 172.16.0.100

Wpis1 = 172.16.0.0/12
Wpis2 = 172.16.0.0/16
Wpis3 = 172.16.0.0/24

Jako trasę docelową router wybierze Wpis3.
</pre>
      <p>
        Podobnie jest w przypadku IPv6, tutaj również zostanie wybrana sieć
        z najdłuższym prefiksem. 
      </p>
      <h2 id="2.14.1.forwardingpackets">2.14.1. Przekazywanie pakietów</h2>
      <p>
        Przekazywanie pakietów może odbyć się na trzy różne sposoby.
      </p>
      <ul>
        <li>Pierwszym z nich jest <strong>przekazanie pakietu do sieci
          bezpośrednio
          podłączonej do routera</strong>, jeśli trasa wskazuje na interfejs
          wyjściowy
          routera. Router musi uzyskać adres hosta docelowego, dokonuje tego
          za pomocą protokołu ARP lub komunikatu NS
          (<em>Neighbor Solicitation</em>) w przypadku protokołu IPv6.</li>
        <li>Drugim sposobem jest
          <strong>przekazanie pakietu do następnego skoku</strong>
          (pierwsze routera na trasie docelowej pakietu). Jeśli routery łączy
          ze sobą <em>Ethernet</em>, to ustalanie adresu warstwy drugiej
          wygląda identycznie jak w przypadku pierwszego sposobu.</li>
        <li>Ostatnim sposobem na przekazanie pakietu jest jego 
          <strong>brak</strong>. Jeśli
          nie zostanie o dopasowany wpisów w tablicy routingu oraz w tablicy
          nie została zdefiniowana trasa domyśna (będzie o niej poźniej), to 
          taki pakiet zostaje usunięty z pamięci routera.</li>
      </p>
      <p>
        Mamy również dostępne trzy różne mechanizmy na zrealizowanie powyższych
        celów:
      </p>
      <ul>
        <li><strong>Przełączanie procesorowe</strong> - w tym przypadku każde
          nadejscie pakietu na intefejsie wejściowym jest przetwarzane przez
          procesor. Nie jest to wydajne rozwiązanie, ponieważ pakiety są
          przesyłane w postaci strumieni, w tym przypadku każdy pakiet
          musi zostać przez procesor przetworzony. Ten mechanizm jest nadal
          dostępny dla routerów Cisco.
        </li>
        <li><strong>Szybkie przełączanie</strong> - ta metoda jest
          usprawnieniem przełączania procesorowego. Działa na takiej zasadzie,
          że pierwszy pakiet ze strumienia jest przetwarzany przez procesor,
          w celu znalezienia informacji o następnym skoku, jeśli nie zostanie 
          znaleziony odpowiedni wpis w 
          <strong>pamięci szybkiego przełączania</strong>. Pakiet zostaje
          skierowany do odpowiedniego interfejsu ustalonego przez procesor,
          następnie w pamięci szybkiego przełączania zostaje zapisana
          informacja o następnym skoku - jest ona stosowana dla pozostałych
          pakietów w strumieniu.</li>
        <li><strong>Cisco Express Forwarding</strong> - najnowsza metoda
          stosowana domyślnie w routerach i przełącznikach wielowarstwowych
          firmy Cisco. Mechanizm CEF, tworzy tablicę routingu (FIB) oraz
          tablicę sąsiectwa. Wpisy z tej tablicy są wywoływane przez zmianę
          topologii, a nie w przypadku nadejscia pakietów. Po zakończeniu w 
          sieci
          procesów konwergencji, pakiety są niemal natychmiast przesyłane
          z interfejsu wejściowego na wyjściowy.</li>
      </ul>
      <h2 id="2.14.2.basicrouterconfig">2.14.2. Podstawowa konfiguracja routera</h2>
      <p>
        Aby móc definiować trasy na routerach, musimy na początku dokonać
        bezpieczenej i podstawowej konfiguracji. Zatem musimy wykonać takie
        czynności jak
      </p>
      <ol>
        <li>Skonfigurowania odpowiedniej nazwy hosta:
<pre class="code-block">
Router(config)#hostname R2
R2(config)#
</pre>
        </li>
        <li>Ochrona trybu uprzywilejowanego EXEC przy użyciu hasła:
<pre class="code-block">
R2(config)#enable secret class
</pre>
        </li>
        <li>Zabezpieczenie dostępu przez konsole:
<pre class="code-block">
R1(config)#line console 0
R1(config-line)#logging synchronous
R1(config-line)#password cisco
R1(config-line)#login
R1(config-line)#exit
</pre>
        <li>Umożliwienie zdalnego dostępu przez konsole:
<pre class="code-block">
R1(config)#line vty 0 4
R1(config-line)#password cisco
R1(config-line)#login
R1(config-line)#transport input ssh
R1(config-line)#exit
</pre>
        <li>Ustawienie szyfrowania haseł:
<pre class="code-block">
R1(config)#service password-encryption
</pre>
        </li>
        <li>Ustawienie wiadomości powitalnej/ostrzeżenia:
<pre class="code-block">
R1(config)#banner motd #
Enter TEXT message.  End with the character '#'.
WARNING: Unauthorized access is prohibited!
#
</pre>
        </li>
        <li>Włączenie routingu IPv6:
<pre class="code-block">
R1(config)#ipv6 unicast-routing
</pre>
        </li>
        <li>Konfiguracja interfejsów:
<pre class="code-block">
R1(config)#int gig0/0
R1(config-if)#desc Link to S1
R1(config-if)#ip addr 192.168.0.1 255.255.255.0
R1(config-if)#ipv6 addr 2001:db8:acad:0::1/64
R1(config-if)#ipv6 addr fe80::0:1 link-local
R1(config-if)#no shutdown
</pre>
        </li>
        <li>Zapis konfiguracji bierzącej do konfiguracji startowej:
<pre class="code-inline">
R1#copy running-config startup-config
Destination filename [startup-config]? 
Building configuration...
[OK]
</pre>
        </li>
      </ol>
      <p>
        W ten sposób wygląda najprostsza konfiguracja routera, jaką należało by
        przeprowadzić, oczywiście konfigurację interfejsów powtarzamy dla
        wszystkich uwzględnionych w topologii. Taką konfigurację możemy
        weryfikować przy pomocy poleceń <em>show</em>.
      </p>
      <ul>
        <li><code class="code-inline">show ip interface brief</code>:
<pre class="code-block">
R1#show ip int br
Interface              IP-Address      OK? Method Status                Protocol 
GigabitEthernet0/0     192.168.0.1     YES manual up                    down 
GigabitEthernet0/1     unassigned      YES unset  administratively down down 
Vlan1                  unassigned      YES unset  administratively down down
</pre>
        </li>
        <li><code class="code-inline">show running-config</code>:
<pre class="code-block">
R1#sh running-config 
Building configuration...

Current configuration : 887 bytes
!
version 15.1
no service timestamps log datetime msec
no service timestamps debug datetime msec
service password-encryption
!
hostname R1
...
</pre>
        </li>
        <li><code class="code-inline">show interfaces</code>:
<pre class="code-block">
R1#sh interfaces
GigabitEthernet0/0 is up, line protocol is down (disabled)
  Hardware is CN Gigabit Ethernet, address is 0001.9731.1701 (bia 0001.9731.1701)
  Description: Link to S1
  Internet address is 192.168.0.1/24
  MTU 1500 bytes, BW 1000000 Kbit, DLY 10 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Keepalive set (10 sec)
  Full-duplex, 100Mb/s, media type is RJ45
  output flow-control is unsupported, input flow-control is unsupported
  ARP type: ARPA, ARP Timeout 04:00:00, 
  Last input 00:00:08, output 00:00:05, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/75/0 (size/max/drops); Total output drops: 0
  Queueing strategy: fifo
  Output queue :0/40 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     0 packets input, 0 bytes, 0 no buffer
     Received 0 broadcasts, 0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort
     0 watchdog, 1017 multicast, 0 pause input
...
</pre>
        <li><code class="code-inline">show ip interface</code>:
<pre class="code-inline">
R1#show ip interface
GigabitEthernet0/0 is up, line protocol is down (disabled)
  Internet address is 192.168.0.1/24
  Broadcast address is 255.255.255.255
  Address determined by setup command
  MTU is 1500 bytes
  Helper address is not set
  Directed broadcast forwarding is disabled
  Outgoing access list is not set
  Inbound  access list is not set
  Proxy ARP is enabled
  Security level is default
  Split horizon is enabled
  ICMP redirects are always sent
  ICMP unreachables are always sent
  ICMP mask replies are never sent
  IP fast switching is disabled
  IP fast switching on the same interface is disabled
  IP Flow switching is disabled
  IP Fast switching turbo vector
  IP multicast fast switching is disabled
  IP multicast distributed fast switching is disabled
  Router Discovery is disabled
...
</pre>
        </li>
        <li><code class="code-inline">show ip route</code>:
<pre class="code-block">
R1#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

     192.168.0.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.0.0/24 is directly connected, GigabitEthernet0/0
L       192.168.0.1/32 is directly connected, GigabitEthernet0/0
</pre>
        <li><code class="code-inline">ping</code>:
<pre class="code-block">
R1#ping 192.168.0.100

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.0.100, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 0/8/43 ms
</pre>
      </ul>
      <p>
        Wyjścia poleceń <code class="code-inline">show running-config</code>,
        <code class="code-inline">show interfaces</code> czy
        <code class="code-inline">show ip interfaces</code> można przepuścić
        przez znak potoku (<strong>|</strong>) oraz polecenia filtrujące
        (<em>begin</em>, <em>section</em>, <em>include</em>, <em>exclude</em>).
      </p>
      <h3 id="2.14.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/14.3.5-packet-tracer---basic-router-configuration-review_pl-PL.pdf">Przegląd podstawowej konfiguracji routera - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/14.3.5-packet-tracer---basic-router-configuration-review_pl-PL.pka">Przegląd podstawowej konfiguracji routera - zadanie</a>
      </p>
      <h2 id="2.14.3.routingtable">2.14.3. Tablica routingu</h2>
      <p>
        Tablica routingu jest tabelą w pamięci routera. Na podstawie wpisów
        w tej tabeli urządzenie dokonuje decyzji gdzie przesłać otrzymany
        pakiet. Źródłem tych wpisów mogą być: 
      </p>
      <ul>
        <li>Sieci bezpośrednio podłączone</li>
        <li>Trasy statyczne</li>
        <li>Protokoły routingu dynamicznego</li>
      </ul>
      <p>
        Istnieją trzy zasady związane z tablicami routingu. Zasady te, a
        konkretniej problemy można rozwiązać poprzez stosowanie dynamicznych
        protokołów routingu, czy tras statycznych na wszystkich urządzeniach
        między nadawcą a odbiorcą:
      </p>
      <ol>
        <li>Każdy router podejmuje decyzje samodzielnie na podstawie swojej
          tablicy routingu.</li>
        <li>Informacje w tabeli routingu jednego routera niekoniecznie pasują
          do tabeli routingu innego routera.</li>
        <li>Informacje o routingu ścieżki nie zapewniają informacji o routingu
          zwrotnym.</li>
      </ol>
      <p>
        Same wpisy w tablicy routingu mają określony format, składają się z
        około 7 pól, w przypadku IPv6 tych pól jest 6. Pole numer 3 zawiera
        dwa pola - dystans administracyjcny oraz metrykę.:
      </p>
<pre class="code-block">
#IPv4:
O 10.0.4.0/24 [110/50]  via 10.0.3.2, 00:13:29, Serial0/1/1

#IPv6:
O 2001:DB8:ACAD:4::/64  [110/50] 
  via FE80::2:C,  Serial0/1/1
</pre>
      <ol>
        <li><strong>Źródło trasy</strong> - na podstawie tej kolumny możemy
          określić skąd pochodzi dana trasa. Legenda opisująca poszczególne
          skróty znajduje się na początku wyjścia polecenia
          <code class="code-inline">show ip route</code>. Najczęściej
          zawiera ona informacje o tym czy jest trasa jest statyczna lub
          nauczona przy użyciu protokołu routingu.</li>
        <li><strong>Adres sieci docelowej</strong> - Identyfikuje sieć
          zdalną. Ten adres zawsze podawany jest wraz prefiksem (dla IPv4) lub
          długością prefiksu (dla IPv6).</li>
        <li><strong>Odległość administracyjna</strong> - z góry narzucona
          wartość, możliwa do zmiany. Określa ona wiarygodność danej trasy.
          Im niższy dystans administracyjny tym trasa będzie bardziej
          preferowana przez urządzenia.</li>
        <li><strong>Metryka</strong> - Indywidualna wartość określającą dostęp
          do sieci zdalnej oblicza przez algorytmy protokołów routingu
          dynamicznego.
          Im niższa wartość tym trasa bardziej preferowana przez router.</li>
        <li><strong>Następny przeskok</strong> - Identyfikuje adres IP routera,
          do którego pakiet został by przesłany.</li>
        <li><strong>Znacznik czasu</strong> - nie występuje w IPv6, określa ile
          czasu upłynęło od nauczenia się trasy.</li>
        <li><strong>Interfejs wyjściowy</strong> - określa interfejs przez,
          który osiągalna jest sieć zdalna dla pakietów.</li>
      </ol>
      <p>
        Tablica routingu typowego routera wypełnia się zazwyczaj na początku
        <strong>trasami bezpośrednio podłączonymi</strong>, ponieważ są one
        dodawane zaraz
        po podłączeniu drugiej strony medium o ile włączyliśmy dany interfejs.
        Trasy bezpośrednio podłączonę zawierają literkę <strong>C</strong>
        w pierwszej kolumnie. Tym trasom toważyszą dodatkowe wpisy w postaci
        <strong>tras lokalnych</strong>, trasa lokalna zawiera w adresie sieci,
        adres IP
        interfejsu routera podłączony do tej sieci bezpośredniej, takie trasy
        określa się literą <strong>L</strong>. Trasa tego typu ma za zadanie
        w lepszy sposób rozgraniczać ruch przeznaczony dla routera od tego,
        który ma zostać przezkazny dalej do sieci.
      </p>
      <p>
        Następnie tablica może zostać wypełniona ręcznie przez
        administratora, <strong>trasami statycznymi</strong>, są to jawne
        ścieżki między dwoma urządzeniami. Takie trasy muszą być ręcznie
        zmieniane po każdej zmienie topologii. Zaletą stosowania tras
        statycznych jest zwiększone bezpieczeństwo - to administrator decyduje
        o tym gdzie zostanie skierowany pakiet - oraz zmniejszone zużycie
        zasobów, ze względu na brak zaangażowania urządzenia w wymiane
        informacji o trasach w protokołach dynamicznych. Do zastosowań tras
        statycznych możemy przypisać:
      </p>
      <ul>
        <li>Zapewnia łatwości obsługi tablic routingu w mniejszych sieciach
          w przypadku gdy nieoczekuje się nagłego wzrostu rozmiarów sieci.</li>
        <li>Używa pojedynczej trasy domyślnej do reprezentowania ścieżki do
          dowolnej sieci, która nie ma dopasowania z dokładniejszą trasą w
          tablicy routingu. Trasy domyślne są używane gdy router nie znajduje
          dla danej sieci docelowej pasującej pozycji w tabeli routingu.</li>
        <li>Kieruje z i do sieci pośredniczących.
          <strong>Sieć szczątkowa</strong> to sieć, do której można dotrzeć
          tylko jedną trasą.</li>
      </ul>
      <p>
        Trasy statyczne są definiowane w IOS za pomocą polecenia:
        <code class="code-inline">ip route</code> wydanego w trybie
        konfiguracji globalnej. Dla tras IPv4, dla IPv6 polecenie
        różni się tylko: <code class="code-inline">ipv6 route</code>
      </p>
<pre class="code-inline">
#IPv4:
Router(config)#ip route 10.0.4.0 255.255.255.0 10.0.3.2

#IPv6:
Router(config)# ipv6 route 2001:db8:acad:4::/64 fe80::2:c
</pre>
      <p>
        Protokoły routingu dynamicznego są używane przez routery do
        automatycznego udostępania informacji na temat stanu oraz osiągalności
        zdalnych sieci. Protokoły routingu wykonują wiele zadań związanych
        z wykrywaniem sieci oraz utrzymywaniem tablic routingu. Ważnymi
        zaletami protokołów routingu dynamicznego jest możliwość wyboru
        najlepszej ścieżki oraz odkrycia nowej najlepszej ścieżki w momencie
        zmiany topologii. Te mechanizmy opierają się na tym, że routery same
        mogą rozgłaszać informacje o znanych sobie sieciach dla innych urządzeń
        wykorzystujących ten sam protokół.
      </p>
      <p>
        W tablicy routingu trasę dynamiczną poznamy po tym, że jej źródłem 
        będzie jeden z protokołów dynamicznych, dystans administracyjny będzie
        inny większy niż 1 oraz metryka większą niż 0. W przypadku IPv4,
        wświetlany będzie również dodatkowo znacznik czasu, który określe ile
        czasu upłyneło od nauczenia się trasy.
      </p>
      <p>
        Ostatnim rodzajem trasy jest <strong>trasa domyślna</strong>, jest ona
        podobna do bramy. Określa ona adres routera następnego skoku dla
        pakietów, których adres docelowy nie może zostać przypasowany do
        żadnej trasy zapisanej w tablicy. Trasa do tej sieci może nieistnieć w
        tabeli. Trasy domyślne ma zapisany adres sieci docelowe w postaci:
        <strong>0.0.0.0/0</strong> - dla IPv4 oraz <strong>::/0</strong> - dla
        IPv6. Adres następnego skoku w przypadku trasy domyślnej najczęściej
        będzie wskazywać adres bramy naszego usługodawcy internetowego.
      </p>
      <p>
        Jeśli przyjrzelibyśmy się tablicy routingu, która posiada jakieś
        zdefiniowane trasy zarówno bezpośrednio podłączone, statyczne jak i
        dynamiczne, to możemy zauważyć pewnego rodzaju wcięcia. Te wpisy 
        z wcięciami oznaczają <strong>trasy podrzędne</strong>, a te
        bez żadnych odstępów <strong>trasy nadrzędne</strong>, wynika to
        podziału sieci na mniejsze framenty - na podsieci. Oczywiście jak
        pamiętamy router dokounuje <strong>najdłuższego dopasowania</strong>.
        Ten podział ma jedynie funkcję organizacyjną w tablicy routingu. W
        przypadku IPv6 ten podział w ogóle nie występuje, gdyż nie wystęują
        w adresacji tego typu klasy.
      </p>
      <p>
        Trzecim polem wpisu w tablicy routingu jest dystans administracyjny.
        Jest to domyślnie przypisana wartość wiarygodności tras zapisywanych
        w tabeli routingu. Te wartości są zapisane w systemie operacyjnym
        routera. Użycie odległości administracyjne było podyktowane, tym że
        tablice routingu mogą być wypełniane na różny sposób przez różne
        protokoły - tak, możliwe jest uruchomienie kilku protokołów routingu
        dynamicznego jednocześnie na jednym urządzeniu, choć nie koniecznie
        jest dobre rozwiązanie. Zatem może spotkać się z takimi wartościami AD
        (<em>Administrative Distance</em>) dla poszególnych źródeł tras
        routingu.
      </p>
      <ul>
        <li>Bezpośrednio podłączona - <strong>0</strong>.</li>
        <li>Trasa statyczna - <strong>1</strong>.</li>
        <li>Sumaryczna trasa EIGRP - <strong>5</strong>.</li>
        <li>Zewnętrzna trasa BGP - <strong>20</strong>.</li>
        <li>Wewnętrzna trasa EIGRP - <strong>90</strong>.</li>
        <li>OSPF - <strong>110</strong>.</li>
        <li>IS-IS - <strong>115</strong>.</li>
        <li>RIP - <strong>120</strong>.</li>
        <li>Zewnętrzna trasa EIGRP - <strong>170</strong>.</li>
        <li>Wewnętrzna trasa BGP - <strong>200</strong>.</li>
      </ul>
      <p>
        Te wartości mogą być przez nas zmieniane. Przy czym wartość AD 0 może
        mieć jedynie sieć <strong>bezpośrednio podłączona</strong>.
      </p>
      <h2 id="2.14.4.staticordynamic">2.14.4. Statyczny czy dynamiczny?</h2>
      <p>
        Routing statyczny i dynamiczne protokoły routingu nie wykluczają
        siebie nawzajem. Najczęście spotykaną konfiguracją jest użycie jednego
        z protokółów routingu dynamicznego (OSPF lub EIGRP) oraz uzupełnienie
        tablicy o trasy statyczne. Trasy statyczne sprawdzą się takich
        przypadkach jak:
      </p>
      <ul>
        <li>Domyślna trasa przekazywania pakietów do usługodawcy.</li>
        <li>W przypadku tras poza domeną routingu i niewykonywanych przez
          protokoły dynamiczne.</li>
        <li>Gdy chcemy jawnie zdefiniować trasę do określonej sieci.</li>
        <li>Do routingu między sieciami szczątkowymi.</li>
      </ul>
      <p>
        Natomiast protokoły dynamiczne sprawdzą się takich scenariuszach jak:
      </p>
      <ul>
        <li>W sieciach składających się z więcej niż kilku routerów.</li>
        <li>Gdy zmiana topologii wymaga od sieci automatycznego określania
          innej ścieżki.</li>
        <li>Dla skalowalności. Wraz z rozwojem sieci dynamiczny protokół
          routingu automatycznie uczy się o wszelkich nowych sieciach.</li>
      </ul>
      <p>
        Obecne protokoły routingu dynamicznego, dostosowywały się do
        zmieniających się trendów oraz standardów sieciowych, jednak od
        dłuższego czasu na tym polu nie wiele się dzieje. Obecnie
        wykorzystujemy metody i technologie opracowane ponad 25 lat temu.
        Rowiązania te są na tyle dobre i upowszechnione, że nie wiadomo czy
        jeszcze coś się zmienii na tej płaszczyźnie.
      </p>
      <p>
        Same protokoły dzielą się na dwie grupy <strong>IGP</strong> - bramy
        wewnętrznej, w której znajduję się większość protokołów oraz
        <strong>EGP</strong> - bramy zewnętrznej, w której znajduje się tylko
        protokół BGP.
      </p>
      <p>
        Celem protokołów routingu dynamicznego jest dynamiczne określenie
        najlepszej trasy dla pakietów przy zmieniającej się topologii sieci.
        Głównymi składnikami takich protokołów jest struktura danych
        zawierająca informacje o sieciach, zestawy komunikatów protokołu, aby
        urządzenia mogły informować siebie na wzajem o podłączonych do nich
        sieciach oraz o zmieniającej się topologii sieci. Ostatnim składnikiem
        jest algorytm protokołu pozwalających na określenie najlepszej
        ścieżki.
      </p>
      <p>
        Zanim ścieżka zostanie zapisana do tablicy routingu musi zostać
        ustalona poprzez algorytmy jakie stosują dynamiczne protokoły. Wynik
        działania tych algorytmów zapisywany jest w postaci
        <strong>metryki</strong> we wpisie w tabeli. Poniżej wymieniono
        ważniejsze protokoły IGP, oraz ich metody na określenie metryki.
      </p>
      <ul>
        <li><strong>Protokół RIP (Routing Information Protocol)</strong> -
          Metryka to liczba <em>przeskoków</em> - kolejnych routerów na trasie.
          Maksymalnie może ich być 15.</li>
        <li><strong>Protokół OSPF (Open Shortest Path First)</strong> -
          Metryką jest "koszt" skumulowanej przepustowści od źródła do celu.
          Szybszym łączom przypisuje się niższe koszta w porównaniu
          wolnieszymi (droższymi) łączami.</li>
        <li><strong>EIGRP (Enchanced Interior Gateway Protocol)</strong> - 
          Oblicza metrykę na podstawie najwolniejszej przepustowości oraz
          wartości opóźnienia, ale może również uwzględniać obiążenie i
          niezawodność.</li>
      </ul>
      <p>
        Dużą zaletą protokołu EIGRP jest równoważenie obciążenia, jeśli trasy
        mają identyczną metrykę, to protokół może zdecydować aby część
        strumienia pakietów puscić jedną trasą, a część drugą. Do celu 
        dotrą w tym samym czasie. Tak mówi o tym teoria. 
      </p>
      <h2 id="2.14.summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy się sposobami trasowania pakietów z
        jednej sieci do drugiej. Poznaliśmy jakie funkcje ma router oraz na
        jakie podstawie dokonuje on wyboru trasy. Dowiedzieliśmy się w jaki
        sposób router przekazuje pakiety. Przypomnieliśmy sobie podstawową
        konfigurację routera. Zapoznaliśmy się z trasami statycznymi, trasą
        domyślną oraz dynamicznymi protokołami routingu. Na koniec
        dowiedzieliśmy się jak wygląda trasowanie w praktyce oraz krótko
        opisaliśmy sobie wewnętrzne protokoły routingu - w jaki sposób
        wybierają trasę.
      </p>
      <h1 id="2.15.staticiprouting">2.15. Statyczny routing IP</h1>
      <p>
        W poprzednim rodziale poznaliśmy polecenie za pomocą, które możemy
        dodać trasy statyczne IP do tablicy routingu, ale to nie jest wszystko.
        Samych tras statyczny mogą być cztery rodzaje:
      </p>
      <ul>
        <li>Standardowa trasa statyczna</li>
        <li>Domyślna trasa statyczna</li>
        <li>Pływająca trasa statyczna</li>
        <li>Sumaryczna trasa statyczna</li>
      </ul>
      <p>
        W trasach statycznych jednym z parametrów potrzebnych do jej utworzenia
        jest podanie następnego skoku i to w jaki sposób podamy ten parametr,
        a możemy na trzy sposoby definiujej kolejne typy tras statycznych.
      </p>
      <ul>
        <li><strong>Trasa następnego przeskoku</strong> - określono tylko
          adres IP następnego skoku.</li>
        <li><strong>Bezpośrednio podłączona trasa statyczna</strong> -
          określono tylko interfejs wyjściowy routera.</li>
        <li><strong>W pełni określona trasa statyczna</strong> - podano
          adres IP następnego skoku oraz interfejs wyjściowy.</li>
      </ul>
      <p>
        Polecenie <code class="code-inline">ip route</code>, odpowiedzialne za
        dodawanie tras statycznych do tablicy routingu w raz argumentami
        wygląda następująco:
      </p>
<pre class="code-block">
Router(config)#ip route network-address subnet-mask { ip-address | exit-intf [ip-address] } [distance]
</pre>
      <ul>
        <li><code class="code-inline">network-address</code> - adres IP sieci
          docelowej.</li>
        <li><code class="code-inline">subnet-mask</code> - maska podsieci sieci
          docelowej. Maskę można modyfikować aby podsumować grupę sieci i
          utworzyć sumaryczną tras statyczną.</li>
        <li><code class="code-inline">ip-address</code> - adres IP następnego
          na trasie routera, następnego skoku. Pozwala utworzyć rekurencyjną
          trasę statyczną, w której router dokonuje jeszcze jednego
          wyszukiwania w celu znalezienia interfejsu wyjściowego.</li>
        <li><code class="code-inline">exit-intf</code> - interfejs wyjściowy,
          tworzy bezpośrednio podłączoną trasę statyczną.</li>
        <li><code class="code-inline">exit-intf ip-address</code> - interfejs
          wyściowy wraz z adresem kolejnego skoku. Użycie tych dwóch argumentów
          powoduje utworzenie w pełni określonej trasy statycznej.</li>
        <li><code class="code-inline">distance</code> - Opcjonalny argument
          może przyjmować wartości od 1 do 255. Wykorzystywany przy pływających
          trasach statycznych do ustawienia odległości administracyjnej
          większej niż przy trasach dodanych przez protokoły dynamiczne.</li>
      </ul>
      <p>
        Dla IPv6 wyżej wymienione polecenie wygląda następująco:
      </p>
<pre class="code-block">
Router(config)#ipv6 route prefix/prefix-length { ipv6-address | exit-intf [ipv6-address] } [distance]
</pre>
       <ul>
        <li><code class="code-inline">prefix</code> - identyfikuje docelowy
          adres sieciowy IPv6.</li>
        <li><code class="code-inline">prefix-length</code> - określa długość
          prefiksu sieci zdalnej.</li>
        <li><code class="code-inline">ip-address</code> - adres IP następnego
          na trasie routera, następnego skoku. Pozwala utworzyć rekurencyjną
          trasę statyczną, w której router dokonuje jeszcze jednego
          wyszukiwania w celu znalezienia interfejsu wyjściowego.</li>
        <li><code class="code-inline">exit-intf</code> - interfejs wyjściowy,
          tworzy bezpośrednio podłączoną trase statyczną.</li>
        <li><code class="code-inline">exit-intf ip-address</code> - interfejs
          wyściowy wraz z adresem kolejnego skoku. Użycie tych dwóch argumentów
          powoduje utworzenie w pełni określonej trasy statycznej.</li>
        <li><code class="code-inline">distance</code> - Opcjonalny argument
          może przyjmować wartości od 1 do 255. Wykorzystywany przy pływających
          trasach statycznych do ustawienia odległości administracyjnej
          większej niż przy trasach dodanych przez protokoły dynamiczne.</li>
      </ul>
      <p>
        W celu dalszego omawiania konfiguracji sieci statycznych, stworzyłem
        w Packet Tracerze taką o to topologię.
      </p>
      <p style="width:100%;">
       <img src="https://ftp.morketsmerke.org/img/srwe_15_staticrconf_sh1.png" />
      </p>
      <p>
        Po skonfigurowaniu adresów w tablicy routingu nie ma żadnych wpisów
        poza trasami bezpośrednio podłączonymi oraz lokalnymi. Poniżej znajduje
        się zrzut tablicy z routera R2.
      </p>
<pre class="code-block">
R2#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

     172.16.0.0/16 is variably subnetted, 4 subnets, 2 masks
C       172.16.1.0/24 is directly connected, Vlan1
L       172.16.1.1/32 is directly connected, Vlan1
C       172.16.2.0/24 is directly connected, GigabitEthernet0/0
L       172.16.2.2/32 is directly connected, GigabitEthernet0/0
     192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.1.0/24 is directly connected, GigabitEthernet0/1
L       192.168.1.2/32 is directly connected, GigabitEthernet0/1
R2#show ipv6 route
IPv6 Routing Table - 7 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
C   2001:DB8:ACAD:1::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:1::1/128 [0/0]
     via Vlan1, receive
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::2/128 [0/0]
     via GigabitEthernet0/0, receive
C   2001:DB8:CAFE:1::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:CAFE:1::2/128 [0/0]
     via GigabitEthernet0/1, receive
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        W celu powtórzenia poleceń z poprzedniego rozdziału możemy sobie
        sprawdzić zarówno tablice routingu poszczególnych routerów jak i
        spróbować spingować komputery między sobą. Pamiętajmy aby nadać adresy
        IP komputerom przed wydaniem polecenia <em>ping</em>.
      </p>
      <h2 id="2.15.1.configurestaticiproutes">2.15.1. Konfigurowanie tras statycznych IP</h2>
      <p>
        Jeśli wykonaliśmy sprawdzenie łączności między komputerami to wiemy
        się one niepowiodły, aby mógł zajść routing między tymi sieciami
        musimy w najgorszym przypadku skonfigurować trasy statyczne na każdym
        z routerów wskazując pokolei adresy następnego skoku przez, które
        osiągalne są następujące sieci. Tak wyglądają polecenia wpisane
        na poszczególnych routerach.
      </p>
<pre class="code-inline">
#R1:
R1(config)#ip route 172.16.1.0 255.255.255.0 172.16.2.2
R1(config)#ip route 192.168.2.0 255.255.255.0 172.16.2.2
R1(config)#ipv6 route 2001:db8:acad:1::/64 2001:db8:acad:2::2
R1(config)#ipv6 route 2001:db8:cafe:2::/64 2001:db8:acad:2::2

#R2:
R2(config)#ip route 172.16.3.0 255.255.255.0 172.16.2.1
R2(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.1
R2(config)#ipv6 route 2001:db8:acad:3::/64 2001:db8:acad:2::1
R2(config)#ipv6 route 2001:db8:cafe:2::/64 2001:db8:cafe:1::1

#R3:
R3(config)#ip route 172.16.1.0 255.255.255.0 192.168.1.2
R3(config)#ip route 172.16.3.0 255.255.255.0 192.168.1.2
R3(config)#ipv6 route 2001:db8:acad:1::/64 2001:db8:cafe:1::2
R3(config)#ipv6 route 2001:db8:acad:3::/64 2001:db8:cafe:1::2
</pre>
      <p>
        Teraz polecenie <em>ping</em> pomiędzy wszystkimi komputerami powinno
        się udać. Warto zwrócić uwagę na to, że R1 nie musi mieć trasy do sieci
        między R2 a R3 i vice versa. R3 nie musi mieć trasy do sieci między
        R2 a R1, żeby komputery mogły się ze sobą komunikować. 
        W ten sposób stworzyliśmy trasy następnego skoku. Tablice routingu
        routera R2 prezentują się w następujący sposób:
      </p>
<pre class="code-block">
R2#show ip route | begin Gateway
Gateway of last resort is not set

     172.16.0.0/16 is variably subnetted, 5 subnets, 2 masks
C       172.16.1.0/24 is directly connected, Vlan1
L       172.16.1.1/32 is directly connected, Vlan1
C       172.16.2.0/24 is directly connected, GigabitEthernet0/0
L       172.16.2.2/32 is directly connected, GigabitEthernet0/0
S       172.16.3.0/24 [1/0] via 172.16.2.1
     192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.1.0/24 is directly connected, GigabitEthernet0/1
L       192.168.1.2/32 is directly connected, GigabitEthernet0/1
S    192.168.2.0/24 [1/0] via 192.168.1.1
	
R2#show ipv6 route
IPv6 Routing Table - 9 entries
...
C   2001:DB8:ACAD:1::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:1::1/128 [0/0]
     via Vlan1, receive
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::2/128 [0/0]
     via GigabitEthernet0/0, receive
S   2001:DB8:ACAD:3::/64 [1/0]
     via 2001:DB8:ACAD:2::1
C   2001:DB8:CAFE:1::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:CAFE:1::2/128 [0/0]
     via GigabitEthernet0/1, receive
S   2001:DB8:CAFE:2::/64 [1/0]
     via 2001:DB8:CAFE:1::1
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        Następnym rodzajem tras statycznych są trasy bezpośrednio podłączone.
        Konfigurując naszą topologię, zamiast adresu następnego skoku, podajemy
        interfejs wyjściowy, w moim przypadku będzie <em>Gig0/0</em> oraz
        <em>Gig0/1</em> (w przypadku R2).
      </p>
<pre class="code-block">
#R1:
R1(config)#ip route 172.16.1.0 255.255.255.0 gig0/0
%Default route without gateway, if not a point-to-point interface, may impact performance
R1(config)#ip route 192.168.2.0 255.255.255.0 gig0/0
%Default route without gateway, if not a point-to-point interface, may impact performance
R1(config)#ipv6 route 2001:db8:acad:1::/64 gig0/0
R1(config)#ipv6 route 2001:db8:cafe:2::/64 gig0/0

#R2: 
R2(config)#ip route 172.16.3.0 255.255.255.0 gig0/0
%Default route without gateway, if not a point-to-point interface, may impact performance
R2(config)#ip route 192.168.2.0 255.255.255.0 gig0/1
%Default route without gateway, if not a point-to-point interface, may impact performance
R2(config)#ipv6 route 2001:db8:acad:3::/64 gig0/0
R2(config)#ipv6 route 2001:db8:cafe:2::/64 gig0/1

#R3:
R3(config)#ip route 172.16.1.0 255.255.255.0 gig0/0
%Default route without gateway, if not a point-to-point interface, may impact performance
R3(config)#ip route 172.16.3.0 255.255.255.0 gig0/0
%Default route without gateway, if not a point-to-point interface, may impact performance
R3(config)#ipv6 route 2001:db8:acad:1::/64 gig0/0
R3(config)#ipv6 route 2001:db8:acad:3::/64 gig0/0

R2#show ip route | begin Gateway
Gateway of last resort is not set

     172.16.0.0/16 is variably subnetted, 5 subnets, 2 masks
C       172.16.1.0/24 is directly connected, Vlan1
L       172.16.1.1/32 is directly connected, Vlan1
C       172.16.2.0/24 is directly connected, GigabitEthernet0/0
L       172.16.2.2/32 is directly connected, GigabitEthernet0/0
S       172.16.3.0/24 is directly connected, GigabitEthernet0/0
     192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.1.0/24 is directly connected, GigabitEthernet0/1
L       192.168.1.2/32 is directly connected, GigabitEthernet0/1
S    192.168.2.0/24 is directly connected, GigabitEthernet0/1

R2#show ipv6 route
IPv6 Routing Table - 9 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
C   2001:DB8:ACAD:1::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:1::1/128 [0/0]
     via Vlan1, receive
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::2/128 [0/0]
     via GigabitEthernet0/0, receive
S   2001:DB8:ACAD:3::/64 [1/0]
     via GigabitEthernet0/0, directly connected
C   2001:DB8:CAFE:1::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:CAFE:1::2/128 [0/0]
     via GigabitEthernet0/1, receive
S   2001:DB8:CAFE:2::/64 [1/0]
     via GigabitEthernet0/1, directly connected
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        Tego rodzaju trasy są przeznaczone dla połączeń szeregowych punkt-punkt
        o czym informuje nas IOS podczas dodawania takiej trasy IPv4.
        Trasy IPv4 działają, i komunikacja z dość widocznym opoźnieniem
        dochodzi do skutku, natomiast w przypadku IPv6 próby pingowania się
        komputerów nawzajem nie dochodzi do skutku. Teraz mimo że dwie trasy
        zostały dodane statyczne, to wyświetlane jest tablicy
        <code class="code-inline">directly connected</code>.
      </p>
      <p>
        W pełni określona trasa statyczna wymaga podania zarówno interfejsu
        wyjściowego jak i adresu IP następnego skoku. Ta forma trasy statycznej
        jest stosowana w interfejsie wielodostępowym, takim jak np. Ethernet.
        W połączeniach punkt-punkt, na drugim końcu łącza może znajdować się
        tylko router, w przypadku łączy wielodostępowych między jednym a
        drugim routerem może znaleźć się wiele urządzeń.
        Interfejs następnego przeskoku musi być podłączony bezpośrednio do
        konkretnego. 
      </p>
      <p>
        W przypadku oprogramowania Packet Tracer nie jest możliwe
        skonfigurowanie w pełni określonych tras statycznych dla IPv4, program
        pozwala użyć w poleceniu <code class="code-inline">ip route</code>
        albo nazwy interfejsu tworząc trasę bezpośrednio podłączoną, albo adres
        IP następnego przeskoku. Jednak w przypadku IPv6 można już dodać
        trasę w pełni określoną. Aby było to możliwe do zrealizowania
        uzupełniłem konfigurację routerów o adresy IPv6 <em>link-local</em>.
      </p>
      <p style="width:100%;">
       <img src="https://ftp.morketsmerke.org/img/srwe_15_staticrconf_sh2.png" />
      </p>
<pre class="code-inline">
#R1:
R1(config)#ipv6 route 2001:db8:acad:1::/64 gig0/0 fe80::1:2
R1(config)#ipv6 route 2001:db8:cafe:2::/64 gig0/0 fe80::1:2

#R2:
R2(config)#ipv6 route 2001:db8:acad:3::/64 gig0/0 fe80::1:1
R2(config)#ipv6 route 2001:db8:cafe:2::/64 gig0/1 fe80::2:1

#R3:
R3(config)#ipv6 route 2001:db8:acad:1::/64 gig0/0 fe80::2:2
R3(config)#ipv6 route 2001:db8:acad:3::/64 gig0/0 fe80::2:2

R2#show ipv6 route
IPv6 Routing Table - 9 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
C   2001:DB8:ACAD:1::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:1::1/128 [0/0]
     via Vlan1, receive
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::2/128 [0/0]
     via GigabitEthernet0/0, receive
S   2001:DB8:ACAD:3::/64 [1/0]
     via FE80::1:1, GigabitEthernet0/0
C   2001:DB8:CAFE:1::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:CAFE:1::2/128 [0/0]
     via GigabitEthernet0/1, receive
S   2001:DB8:CAFE:2::/64 [1/0]
     via FE80::2:1, GigabitEthernet0/1
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        Po dodaniu wszystkich tras, możliwa jest komunikacja między komputerami
        w różnych sieciach. Dodane trasy statyczne możemy weryfikować za
        pomocą poleceń:
      </p>
      <ul>
        <li><code class="code-inline">show ip route</code> i
          <code class="code-inline">show ipv6 route</code>:
<pre class="code-block">
R2#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

     172.16.0.0/16 is variably subnetted, 4 subnets, 2 masks
C       172.16.1.0/24 is directly connected, Vlan1
L       172.16.1.1/32 is directly connected, Vlan1
C       172.16.2.0/24 is directly connected, GigabitEthernet0/0
L       172.16.2.2/32 is directly connected, GigabitEthernet0/0
     192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.1.0/24 is directly connected, GigabitEthernet0/1
L       192.168.1.2/32 is directly connected, GigabitEthernet0/1
R2#show ipv6 route
IPv6 Routing Table - 9 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
C   2001:DB8:ACAD:1::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:1::1/128 [0/0]
     via Vlan1, receive
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::2/128 [0/0]
     via GigabitEthernet0/0, receive
S   2001:DB8:ACAD:3::/64 [1/0]
     via FE80::1:1, GigabitEthernet0/0
C   2001:DB8:CAFE:1::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:CAFE:1::2/128 [0/0]
     via GigabitEthernet0/1, receive
S   2001:DB8:CAFE:2::/64 [1/0]
     via FE80::2:1, GigabitEthernet0/1
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
        </li>
        <li><code class="code-inline">show ip route static</code>:
<pre class="code-block">
R2#show ip route static
     172.16.0.0/16 is variably subnetted, 5 subnets, 2 masks
S       172.16.3.0/24 [1/0] via 172.16.2.1
S    192.168.2.0/24 [1/0] via 192.168.1.1
</pre>
        </li>
        <li><code class="code-inline">show ip route sieć</code> i
          <code class="code-inline">show ipv6 route sieć</code>:
<pre class="code-block">
R2#show ip route 192.168.2.0
Routing entry for 192.168.2.0/24
Known via "static", distance 1, metric 0
  Routing Descriptor Blocks:
  * 192.168.1.1
      Route metric is 0, traffic share count is 1
R2#show ipv6 route 2001:DB8:ACAD:3::
Routing entry for 2001:DB8:ACAD:3::/64
  Known via "static", distance 1, metric 0
  Route count is 1/1, share count 0
  Routing paths:
  Routing paths:FE80::1:1
      Last update FE80::1:1 on GigabitEthernet0/0, 00:00:00 ago
</pre>
        </li>
        <li><code class="code-inline">show running-config | section route</code>:
<pre class="code-block">
ip route 172.16.3.0 255.255.255.0 172.16.2.1 
ip route 192.168.2.0 255.255.255.0 192.168.1.1 
ipv6 route 2001:DB8:ACAD:3::/64 GigabitEthernet0/0 FE80::1:1
ipv6 route 2001:DB8:CAFE:2::/64 GigabitEthernet0/1 FE80::2:1
</pre>
          Kombinacje:
            <code class="code-inline">show running-config | section ip route</code>,
            <code class="code-inline">show running-config | section ipv6 route</code>,
        </li>
      </ul>
      <h2 id="2.15.2.defaultroute">2.15.2. Konfigurowanie trasy domyślnej</h2>
      <p>
        Trasa domyślna jest wybierana w momencie gdy dla przesyłanego pakietu
        nie można dopasować żadnego wpisu z tablicy. Oczywiście o ile taką
        trasę skonfigurowano. W codziennym zastosowaniu trasy domyślne
        stosowane są w routerach domowych w celu przekazywania pakietów do
        usługodawcy internetowego, zapewniając tym samym dostęp do Internetu.
        Trasa domyślna stosowana jest w sieciach szczątkowych, gdzie do routera
        takiej sieci podłączony jest tylko jeden router wysyłający.
      </p>
      <p>
        W naszej topologii takimi sieciami są: 172.16.3.0/24 oraz
        192.168.2.0/24, i tak też je skonfigurujemy przy czym R2 będzie
        posiadać trasy statyczne następnego przeskoku do jednej jak i drugiej
        sieci. Poniżej znajdują się polecenia konfigurujące trasę domyślną
        w sieciach szczątkowych, oraz konfigurujące routing routera R2.
        Wyświetlono również tablicę routingu, routera sieci szczątkowej 1.
      </p>
      <p style="width:100%;">
       <img src="https://ftp.morketsmerke.org/img/srwe_15_staticrconf_sh3.png" />
      </p>
<pre class="code-block">
#R1:
R1(config)#ip route 0.0.0.0 0.0.0.0 172.16.2.2
R1(config)#ipv6 route ::/0 2001:db8:acad:2::2

#R3:
R3(config)#ip route 0.0.0.0 0.0.0.0 192.168.1.2
R3(config)#ipv6 route ::/0 2001:db8:cafe:1::2

#R2:
R2(config)#ip route 172.16.3.0 255.255.255.0 172.16.2.1
R2(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.1
R2(config)#ipv6 route 2001:db8:acad:3::/64 2001:db8:acad:2::1
R2(config)#ipv6 route 2001:db8:cafe:2::/64 2001:db8:cafe:1::1

#R1:
R1#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is 172.16.2.2 to network 0.0.0.0

     172.16.0.0/16 is variably subnetted, 4 subnets, 2 masks
C       172.16.2.0/24 is directly connected, GigabitEthernet0/0
L       172.16.2.1/32 is directly connected, GigabitEthernet0/0
C       172.16.3.0/24 is directly connected, Vlan1
L       172.16.3.1/32 is directly connected, Vlan1
S*   0.0.0.0/0 [1/0] via 172.16.2.2

IPv6 Routing Table - 6 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
S   ::/0 [1/0]
     via 2001:DB8:ACAD:2::2
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::1/128 [0/0]
     via GigabitEthernet0/0, receive
C   2001:DB8:ACAD:3::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:3::1/128 [0/0]
     via Vlan1, receive
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        Po skonfigurowaniu tras domyślnych jak i tras statyczny routera R2,
        PC1 może komunikować z PC2 i PC3 po IPv4 jak i IPv6, pamiętając przy
        tym, że router sieci szczątkowej 1, nie żadnych jawnie zapisanych tras.
        Posiada on trasę domyślną wskazującą na adres następnego skoku w tym
        przypadku interfejs routera R2, w sieci 172.16.2.0 (172.16.2.2).
      </p>
      <h2 id="2.15.3.floatingstaticroutes">2.15.3. Pływające trasy statyczne</h2>
      <p>
        Pływające trasy statyczne są to trasy statyczne używane do zapewnienia
        ścieżki rezerwowej dla głównej trasy lub trasy dynamicznej w przypadku
        awarii łącza. Pływająca trasa statyczna jest używana tylko wtedy gdy
        trasa główna jest niedostępna. Konfiguracja trasy pływającej polega
        na zmianie dystansu administracyjnego trasy zapasowej względem trasy
        głównej. 
      </p>
      <p>
        W tym celu w naszej topologii utworzymy kolejną sieć między
        interfejsami Gig0/1 R1 oraz R3. Interfejsy skonfigurujemy dla IPv4 jak
        i IPv6. Następnie dodam następujące trasy.
      </p>
<pre class="code-block">
#R1:
R1(config)#ip route 0.0.0.0 0.0.0.0 172.16.2.2
R1(config)#ip route 0.0.0.0 0.0.0.0 10.10.10.2 5
R1(config)#ipv6 route ::/0 2001:db8:acad:2::2
R1(config)#ipv6 route ::/0 2001:db8:feed:10::2 5

#R3:
R3(config)#ip route 0.0.0.0 0.0.0.0 192.168.1.2
R3(config)#ip route 0.0.0.0 0.0.0.0 10.10.10.1 5
R3(config)#ipv6 route ::/0 2001:db8:cafe:1::2
R3(config)#ipv6 route ::/0 2001:db8:feed:10::1 5

#R2
R2(config)#ip route 172.16.3.0 255.255.255.0 172.16.2.1
R2(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.1
R2(config)#ipv6 route 2001:db8:acad:3::/64 2001:db8:acad:2::1
R2(config)#ipv6 route 2001:db8:cafe:2::/64 2001:db8:cafe:1::1

R1#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is 172.16.2.2 to network 0.0.0.0

     10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C       10.10.10.0/24 is directly connected, GigabitEthernet0/1
L       10.10.10.1/32 is directly connected, GigabitEthernet0/1
     172.16.0.0/16 is variably subnetted, 4 subnets, 2 masks
C       172.16.2.0/24 is directly connected, GigabitEthernet0/0
L       172.16.2.1/32 is directly connected, GigabitEthernet0/0
C       172.16.3.0/24 is directly connected, Vlan1
L       172.16.3.1/32 is directly connected, Vlan1
S*   0.0.0.0/0 [1/0] via 172.16.2.2

R1#show ip route static
S*   0.0.0.0/0 [1/0] via 172.16.2.2

R1#show ipv6 route
IPv6 Routing Table - 8 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
S   ::/0 [1/0]
     via 2001:DB8:ACAD:2::2
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::1/128 [0/0]
     via GigabitEthernet0/0, receive
C   2001:DB8:ACAD:3::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:3::1/128 [0/0]
     via Vlan1, receive
C   2001:DB8:FEED:10::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:FEED:10::1/128 [0/0]
     via GigabitEthernet0/1, receive
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        W momencie kiedy usuniemy link między R1 i R2 trasa domyślna zostanie
        zmieniona na tę skonfigurowaną z większą wartością AD.
      </p>
<pre class="code-block">
#R1:
R1#show ip route static
S*   0.0.0.0/0 [5/0] via 10.10.10.2

R1#show ipv6 route
IPv6 Routing Table - 6 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
S   ::/0 [5/0]
     via 2001:DB8:FEED:10::2
C   2001:DB8:ACAD:3::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:3::1/128 [0/0]
     via Vlan1, receive
C   2001:DB8:FEED:10::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:FEED:10::1/128 [0/0]
     via GigabitEthernet0/1, receive
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        Pomimmo ustawienia tras pływających, nie ma co liczyć na komunikację
        między komputerami. Routery w ich sieciach również muszą mieć statyczne
        wpisy związane możliwymi trasami zapasowymi. Takie trasy też możemy
        dodać zmieniając na końcu odległość administracyjną.
      </p>
      <h2 id="2.15.4.hoststaticroutes">2.15.4. Trasy statyczne hosta</h2>
      <p>
        Statyczne trasy hosta różnią się od tych tras definiowanych wcześniej
        długością maski lub prefiksu. W poprzednich przykładach wskazywaliśmy
        w tabeli trasy do całej sieci. Ale ustawiając maskę na 32 bity dla
        IPv4 i długość prefiksu na /128 dla IPv6 możemy kierować ruch do
        konkretnych hostów.
      </p>
      <p>
        W topologię skonfigurowałem w taki sam sposób jak w przypadku
        statycznych tras domyślnych. Następnie wymusiłem za pomocą statycznych
        tras hosta aby ruch z PC1 do PC3, przechodził przez te dodatkową sieć
        awaryjną, skonfigurowaną na potrzeby przedstawienia pływających tras
        statycznych.
      </p>
<pre class="code-block">
#R1:
R1(config)#ip route 192.168.2.10 255.255.255.255 10.10.10.2
R1(config)#ipv6 route 2001:db8:cafe:2::a/128 2001:db8:feed:10::2

#R3:
R3(config)#ip route 172.16.3.10 255.255.255.255 10.10.10.1
R3(config)#ipv6 route 2001:db8:acad:3::a/128 2001:db8:feed:10::1

#Polecenie tracert wykonane z PC1 do PC3 przed zastosowanie powyższych tras:
C:\&gt;tracert 192.168.2.10

Tracing route to 192.168.2.10 over a maximum of 30 hops: 

  1   0 ms      0 ms      0 ms      172.16.3.1
  2   0 ms      0 ms      0 ms      172.16.2.2
  3   0 ms      0 ms      0 ms      192.168.1.1
  4   1 ms      10 ms     10 ms     192.168.2.10

Trace complete.

#Polecenie tracer wykonane z PC1 do PC3 po zastosowaniu powyższych tras:
C:\&gt;tracert 192.168.2.10

Tracing route to 192.168.2.10 over a maximum of 30 hops: 

  1   0 ms      0 ms      0 ms      172.16.3.1
  2   *         0 ms      0 ms      10.10.10.2
  3   0 ms      0 ms      0 ms      192.168.2.10

Trace complete.

R1#show ip route static
     192.168.2.0/32 is subnetted, 1 subnets
S       192.168.2.10 [1/0] via 10.10.10.2
S*   0.0.0.0/0 [1/0] via 172.16.2.2

R1#show ipv6 route
IPv6 Routing Table - 9 entries
...
S   ::/0 [1/0]
     via 2001:DB8:ACAD:2::2
C   2001:DB8:ACAD:2::/64 [0/0]
     via GigabitEthernet0/0, directly connected
L   2001:DB8:ACAD:2::1/128 [0/0]
     via GigabitEthernet0/0, receive
C   2001:DB8:ACAD:3::/64 [0/0]
     via Vlan1, directly connected
L   2001:DB8:ACAD:3::1/128 [0/0]
     via Vlan1, receive
S   2001:DB8:CAFE:2::A/128 [1/0]
     via 2001:DB8:FEED:10::2
C   2001:DB8:FEED:10::/64 [0/0]
     via GigabitEthernet0/1, directly connected
L   2001:DB8:FEED:10::1/128 [0/0]
     via GigabitEthernet0/1, receive
L   FF00::/8 [0/0]
     via Null0, receive
</pre>
      <p>
        Po zastosowaniu trasy liczba przeskoków dla ruch z PC1 do PC3 spadła o
        jeden przeskok. Zwróćmy uwagę na to, że IOS przestawia trasę hosta
        jako trasę podrzędną dla trasy nadrzędnej z maską 32-bitową.
      </p>
      <h3 id="2.15.5.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/15.6.1-packet-tracer---configure-ipv4-and-ipv6-static-and-default-routes_pl-PL.pdf">Skonfiguruj statyczne i domyślne trasy IPv4 i IPv6 - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/15.6.1-packet-tracer---configure-ipv4-and-ipv6-static-and-default-routes_pl-PL.pka">Skonfiguruj statyczne i domyślne trasy IPv4 i IPv6 - zadanie</a>
      </p>
      <h3 id="2.15.5.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/15.6.2-lab---configure-ipv4-and-ipv6-static-and-default-routes_pl-PL.pdf">Konfiguracja statycznych i domyślnych tras IPv4 i IPv6</a>
      </p>
      <h2 id="2.15.summary">Podsumowanie</h2>
      <p>
        W tym rodziale poznaliśmy rodzaje tras statycznych i przy użyciu
        topologii <em>dual-stack</em> nauczyliśmy się konfigurować poszczególne
        ich typy. Dowiedzieliśmy się również jakie możemy napotkać problemy
        związane z konfiguracją tras statycznych.  
      </p>
      <h1 id="2.16.staticanddefaultroutestroubleshooting">2.16. Rozwiązywanie problemów związanych z trasami statycznymi oraz z trasami domyślnymi.</h1>
      <p>
        Czasmi może zdarzyć się taka sytuacja, że pomimo skonfigurowania
        trasy statycznej, komunikacja między hostami nie dochodzi do skutku.
        W przypadku tras statycznych nie wiele jest możliwości, w których
        można namieszczać w konfiguracji aby komunikacja faktycznie
        nie zachodziła. Takie sytuacje najczęsciej wynikają z błedów
        popełnionych podczas dodawania takich tras do tablicy. Warto pamietać
        o tym, że w przypadku tras statycznych, <strong>musimy dodać trasy w
        obie strony</strong>. Poniżej znajduje się kilka zasad, jakie warto
        sobie przyswoić, aby mieć w głowie pewien schemat działania, który
        pozwoli rozwiązać problemy związane z trasami statycznymi.
      </p>
      <ul>
        <li>Sprawdź adresację interfejsów, biorących udział w trasowaniu.</li>
        <li>Sprawdź tablicę routingu, zarówno dla IPv4 jak i IPv6.</li>
        <li>Zapinguj wewnętrzny interfejs sieci LAN z routera.</li>
        <li>Sprawdź adresacje hostów oraz ich fizyczne możliwości połączenia
          się z siecią.</li>
      </ul>
      <p>
        W realizacji tych zadań mogą pomóc nam poniższe polecenia:
      </p>
      <ul>
        <li><code class="code-inline">show ip/ipv6 interface brief</code></li>
        <li><code class="code-inline">show ip/ipv6 route</code></li>
        <li><code class="code-inline">show running | section route</code></li>
        <li><code class="code-inline">ping</code></li>
        <li><code class="code-inline">tracert</code></li>
        <li><code class="code-inline">ipconfig /all | ip a</code></li>
        <li><code class="code-inline">shop cdp neighbors detail</code></li>
      </ul>
      <p>
        Poza poleceniami <code class="code-inline">ipconfig /all</code> a
        <code class="code-inline">ip a</code>,
        <code class="code-inline">ping</code>,
        <code class="code-inline">tracert</code>,
        to w większości tyczą się systemu Cisco IOS. Polecenia <em>ping</em>
        oraz <em>tracert</em> (<em>traceroute</em>), również są dostępne na 
        routerach. IOS często
        pozwala na rozszerzenie składni, względem ich implementacji w innych
        systemach. Dla przykładu polecenie <em>ping</em> pozwala na określenie
        interfejsu wyjściowego, za pomocą opcji <strong>source</strong>.
      </p>
      <p>
        Jeśli stwierdzimy że jedna z tras w tablicy jest niepoprawna i
        chcielibyśmy ją usunąć, to najlepszym rozwiązaniem jest znalezienie
        polecenia odpowiedzialnego za te trasę w konfiguracji bierzącej i
        poprzedzenie go przedrostkiem <strong>no</strong>.   
      </p>
      <h2 id="2.16.summary">Podsumowanie</h2>
      <p>
        W tym jakże krótkim rozdziale, zapoznaliśmy się z metodami oraz
        poleceniami pozwalającymi nam naprawę problemów związanych z trasami
        statycznymi i domyślnymi. Ten rodział jednocześnie kończy materiał
        przeznaczony dla drugiego modułu kursu CCNA. Poniżej znajdują się
        opisy egzaminów oraz zadań przygotowawczych do nich.
      </p>
      <h3 id="2.16.pka">Zadanie praktycznie - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/16.3.1-packet-tracer---troubleshoot-static-and-default-routes_pl-PL.pdf">Rozwiązywanie problemów z trasami statycznymi i domyślnymi - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/pt/16.3.1-packet-tracer---troubleshoot-static-and-default-routes_pl-PL.pka">Rozwiązywanie problemów z trasami statycznymi i domyślnymi - zadanie</a><br />
      </p>
      <h3 id="2.16.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_2/laby/16.3.2-lab---troubleshoot-ipv4-and-ipv6-static-and-default-routes_pl-PL.pdf">Rozwiązywanie problemów ze statycznymi i domyślnymi routerami IPv4 i IPv6</a>
      </p>
      <!--<h2 id="2.16.partialexam">Egzamin cząstkowy - Rozdziały: 14 - 16</h2>
      <p>
        <a href="Cisco_-_CCNA_-_SRWE_-_egzamin_czastkowy_roz_14_-_16.html">Egzamin z koncepcji routingu i konfiguracji</a>
      </p>-->
      <h2 id="2.mockexam">2. Egzamin próbny - SRWE</h2>
      <p>
        <!--<a href="Cisco_-_CCNA_-_SRWE_-_egzamin_probny.html">Egzamin próbny</a>-->
        W przypadku drugiego semestru, egzamin próbny nie zmienił się zmienił
        zmienił się jedynie zakres materiału. 55 pytań nie podlegających ocenie
        od tak, aby się przetestować przed finalem. Ukończenie tego egzaminu,
        ale nie koniecznie jego zdanie, jest wymagane do ukończenia modułu. 
      </p>
      <h2 id="2.ptsa">2. Przygotowanie do egzaminu praktycznego - SRWE</h2>
      <p>
        Podchodząc do tego egzaminu, załem sobie sprawę, że zostaliśmy nieco
        wprowadzeni w błąd przez prowadzącego 1 moduł. Otóż jako egzamin
        praktyczny otrzymaliśmy zadanie, które w <em>netacad</em> widnieje jako
        <strong>przygotowanie do egzaminu praktycznego</strong>. Prawdziwy
        <em>Final practise</em> dla ITN jest krótszy. Zawiera elementy z
        próbnego ale rzeczy do zrobienia jest mniej. Tutaj również wymagane
        jest faktycznych połaczeń między urządzeniami, np. konfigurując
        router musimy podłączyć się do niego kablem konsolowym, a nie wybrać
        zakładkę CLI. Tyle podobieństw względem modułu pierwszego. W module
        drugim próbny praktyczny podzielony jest na <strong>dwie części</strong>
        pierwsza część zawiera: podstawową konfigurację urządzeń, konfigurację
        VLAN i routingu między nimi w dwóch wariantach, wykorzystania z
        protokołu DTP, konfiguracji EtherChannel oraz ustawienia domyślnych
        bram na hostach. Zabrakło konfigurjacji FHRP. W drugiej części do
        zrobienia jest routing statyczny w tym trasy do hosta, trasy domyślne i
        pływające dla IPv4 i IPv6; konfiguracja DHCP, konfiguracja
        bezpieczeństwa portów oraz dodatkowych mechanizmów ochrony: DHCP
        <em>snooping</em>, DAI oraz zabezpieczenia STP 
        (<em>PortFast</em> oraz <em>BPDU guard</em>), na koniec WLAN z
        uwierzytelnianiem klasy <em>enterprise</em>.
      </p>
      <h1 id="2.finalexam">2. Egzamin końcowy - SRWE</h1>
      <p>
        <!--<a href="Cisco_-_CCNA_-_SRWE_-_egzamin_koncowy.html">Egzamin końcowy</a>-->
        Egzamin końcowy wygląda identycznie jak egzamin próbny, jednak w tym
        przypadku pytań jest o 5 więcej. Tutaj warto wpomnieć o tym, że pytania
        mogą się powtórzyć z próbnego czy cząstkowych, więc warto robić sobie
        zrzuty ekranów, tych egzaminów. Egzamin probny daje nam obraz tego
        czego możemy się spodziewać na <em>finalu</em>.
      </p>
      <h1 id="2.finalpractice">2. Egzamin praktyczy - SRWE</h1>
      <p>
        W przypadku egzaminu praktycznego możemy dowiedzieć się, jakie
        uprawnienia ma akademia względem kursu CCNA. Instruktor jest w stanie
        stowrzyć swój własny egzamin - zadanie praktyczne w Packet Tracerze.
        Samo zadanie nie jest nigdzie przesyłane. Prowadzący wpisuje tylko
        do <em>netacad</em> ilości procentowe uzyskane przez kursantów. W
        przypadku mojego egzaminu do zrobienia były: VLAN-y oraz EtherChannel z
        wykorzystaniem LACP, ustawienie
        <strong>priorytetów STP</strong> oraz konfigurcja IP przełącznika z
        bramą domyślną. Następnie należy skonfigurować statycznie wszystkie
        hosty, ustawić routing między <em>vlan</em>-ami z wykorzystaniem
        routera, ustawić trasy statyczne następnego skoku, aby uzyskać pełną
        osiągalność wszystkich podsieci. Następnie skonfigurować bezpieczne
        zdalne połączenie po SSH oraz ustawić hasło dla trybu uprzywilejowanego.
      </p>
      <h1>Koniec części 2</h1>
      <h1 id="3.module3">3. Moduł 3: Sieci korporacyjne, bezpieczeństwo i automatyzacja</h1>
      <p>
        Ostatni moduł kursu CCNA firmy Cisco. Obejmuje on takie tematy jak
        Jeden protokół routingu dynamicznego w podstawowym zakresie - 
        jednoobszarowy OSPF, podstawowe omówienie zagrożeń bezpieczeństwa, 
        listy dostępowe, funkcję NAT realizowaną przez urządzenia z systemem 
        IOS,
        koncepcje sieci WAN, VPN, QoS, zarzadzanie siecią, w tym aktualizacje
        IOS na urządzeniach. Moduł kończą takie tematy jak zasady projektowania
        sieci, rozwiązywania problemów występujących z nimi, wirtualizacja w
        tym pojęcie SDN oraz automatyzacja.
      </p>
      <h1 id="3.1.oneareaospfconcepts">3.1 Koncepcje jednoobszarowego OSPFv2</h1>
      <p>
        Drugi moduł kończył się wprowadzeniem do koncepcji routingu oraz
        routingiem statycznym. Wadą routingu statycznego był fakt, że musielśmy
        dodawać wszystkie trasy ręcznie do każdego z urządzeń oraz wymagane
        było utworzenie tras powrotnych. Oczywiście ma to swoje zalety i w
        małych sieciach nikt nie będzie uruchamiał dynamicznych protokołów
        dla kilku tras. Jednak sieci rosną, mogą urosnąć i wówczas wpisywanie
        tych tras na wielu routerach może stać się irytujące. Dlatego też
        warto zapoznać się prostym, a zarazem dobrym protokołem routingu
        dynamicznego. Takim jak <strong>OSPF</strong> w wersji 2.
      </p>
      <p>
        OSPF jest protokołem stanu łącza (na podstawie jego możliwości,
        decyduje o trasie). Został obmyślony jako następca protokołu RIP,
        którego metoda wyboru najlepszej trasy nie skaluje się zbyt dobrze.
        Działanie RIP można przyrównać do działania systemu GPS, wybierającego
        najkrótszą trasę, bez znaczenia, że musimy przejechać przez kilka
        miejscowości, przez co podróż trochę nam zajmie. OSPF natomiast
        preferuje autostrady, gdzie dystans może być większy, ale zostanie on
        wyrównany na prędkości z jaką możemy się poruszać.
      </p>
      <p>
        W tytule rozdziału zostało wspomniane o <em>jednoobszarowym OSPFv2</em>.
        OSPF wprowdza koncepcję obszaru - podziału domeny routingu - przez co
        możemy kontrolować aktualizację informacji na temat dostępnych tras.
        Oznacza to, że możemy skonfigurować protokół w ten sposób aby
        nie wszystkie sieci były ze sobą połączone. 
      </p>
      <p>
        Jak już wcześnie zostało wspomaniane OSPF wybiera trasę na podstawie
        możliwości łącza - to protokół stanu łącza. Informacje jakie routery
        w tym samy obszarze wymieniają na temat łączy są nazwane
        <strong>link-state</strong> i zawierają takie informacje jak:
        prefiks sieciowy (adres sieci), długość prefiksu (maskę podsieci) oraz
        koszt (obliczoną wartość, określającą przepustowość łącza).
      </p>
      <p>
        Większość protokołów routingu składa się z tych samych elementów,
        takich jak:
      </p>
      <ul>
        <li>Komunikaty protokołu</li>
        <li>Struktury danych</li>
        <li>Algorytm</li>
      </ul>
      <p>
        Komunikatami wymienianymi przez OSPF, są między innymi pakiety:
      </p>
      <ul>
        <li><em>Hello</em></li>
        <li>Opisu bazy danych (<em>Database Description - DBD</em>)</li>
        <li>Żądania stanu łącza (<em>Link-State Request - LSR</em>)</li>
        <li>Aktualizacji stanu łącza (<em>Link-State Update - LSU</em>)</li>
        <li>Potwierdzenia stanu łącza
          (<em>Link-state acknowledgment - LSAck</em>)</li>
      </ul>
      <p>
        Informacje przesyłane przez pakiety wykorzystywane są do wykrywania
        sąsiedzkich urządzeń, utrzymwania informacji o obecnie wykorzystywanych
        trasach i jak ich aktualizacji.
      </p>
      <p>
        OSPF wykorzystuje takie struktury danych jak:
      </p>
      <ul>
        <li><strong>Baza przyległości (<em>Adjacency database</em>)</strong>
          - Tworzy tablice sąsiadów.</li>
        <li><strong>Bazę stanu łącza (<em>Link-state database - LSDB</em>)</strong>
          - Tworzy tablicę topologii.</li>
        <li><strong>Bazę przekazywania (<em>Forwarding database</em>)</strong>
          - Tworzy tablicę routingu.</li>
      </ul>
      <p>
        Te tablice zawierają listę sąsiednich urządzeń w celu wymiany
        informacji o routingu. Są one przechowywane w pamięci RAM.
        Możemy do nich uzyskać dostęp poprzez odpowiednie polecenia IOS:
      </p>
      <ul>
        <li><strong>Baza przyległości</strong> - 
          <code class="code-inline">show ip ospf neighbor</code></li>
        <li><strong>Baza stanu łącza</strong> -
          <code class="code-inline">show ip ospf database</code></li>
        <li><strong>Baza przekazywania</strong> - 
          <code class="code-inline">show ip route</code></li>
      </ul>
      <p>
        OSPF buduje tablice topologii przy użyciu wyników obliczeń opartych
        na algorytmie Edsgera Dijkstry - pierwszej najkrótszej ściezki - SPF.
        Podstawą na której opiera się działanie algorytmu SPF, jest łączny
        koszt dotarcia do celu.
      </p>
      <p>
        Proces wyboru najlepszej trasy składa się z 5 czynności:
      </p>
      <ol>
        <li>Ustawnowienie przyległości sąsiadów.</li>
        <li>Wymiana komunikatów o stanie łącza (LSA).</li>
        <li>Tworzenie bazy stanów łączy.</li>
        <li>Wykonanie algorymu SPF.</li>
        <li>Wybór najlepszej trasy.</li>
      </ol>
      <p>
        Routery wykorzystujące OSPF muszą się rozpoznawać za nim, rozpoczną 
        wymianę informacji o stanie łączy. W tym celu router wysyła pakiet
        <em>Hello</em> aby wykryć czy na tym łączu znajdują się inne routery
        z włączonym OSPF, jeśli tak to urządzenie spróbuje utworzyć relacje
        sąsiedztwa - określaną mianem <strong>przyległości</strong>.
      </p>
      <p>
        Po ustanowieniu przygległości routery zaczynają wymieniać między sobą
        informacje na temat stanu bezpośrednio podłączonych łączy. Ten
        informacje wysłane są w dużych ilość - powodując zalanie sąsiada
        pakietami LSA. Każdy router po odebraniu takich informacji przekazuje
        do następnego sąsiada, do momentu aż każdy z routerów odbierze LSA od
        każdego z sąsiadów w obszarze.
      </p>
      <p>
        Po odebraniu LSA, router tworzy bazę danych LSDB. Zawiera ona
        informacje o całej topologii.
      </p>
      <p>
        Po zebraniu informacji w LSDB, routery uruchamiają algorytm SPF,
        wynikiem działania tej czynności jest drzewo SPF.
      </p>
      <p>
        Na podstawie drzewa SPF, nalepsze ścieżki są proponowane do tablicy
        routingu urządzenia. Mogą one zostać w niej zapisane, chyba że do
        danej sieci istnieje trasa o niższej odległości administracyjnej,
        wówczas taka trasa dynamiczna nie zostanie zapisana w tablicy routera.
      </p>
      <p>
        OSPF wprowadza strukturę hierarchiczną na podstawie obszarów. Obszar
        OSPF to grupa routerów wspódzieląca w bazie LSDB te same informacje na
        temat stanów łącz. W tym przypadku protokół OSPF możemy wykorzystać na
        na dwa sposóby:
      </p>
      <ul>
        <li><strong>Jednoobszarowy OSPF</strong> - wszystkie routery znajdują
          się w jednej grupie. Zalecanym numerem obszaru jest
          <strong>0</strong>.</li>
        <li><strong>Wieloobszarowy OSPF</strong> - routery znajdują się w
          poszczególnych grupach, zawsze połączonych z obszarem 0
          (obszar rdzenia). Routery łączące ze sobą obszary noszą miano
          routerów międzyobszarowych (ABR - <em>Area Border Router</em>).</li>
      </ul>
      <p>
        Użycie wieloobszarowego OSPF pozwala nam zmniejszenie domeny routingu,
        co pozwala nieco odciążyć urządzenia, które muszą przetwarzać 
        komunikaty LSA tylko dla swojego obszaru. Po mimo to routing będzie
        dalej działać, dzięki ABR. W przypadku gdy dochodzi do zmiany topologi
        routery w innych obszarach nie uruchamiają algorytmu SPF, tylko
        aktualizują tablicę routingu. Korzyści płynące z podziału jednego
        dużego obszaru na mniejsze są następujące:
      </p>
      <ul>
        <li><strong>Mniejsze tablice routingu</strong></li>
        <li><strong>Zmiejszony narzut aktualizacji stanu łącza.</strong></li>
        <li><strong>Zmniejszona częstotliwość obliczeń SPF.</strong></li>
      </ul>
      <p>
        OSPF w wersji 3, służy do wymiany prefiksów sieci IPv6. Wymienia one
        informacje na temat routingu, aby wypełnić tablicę routingu IPv6
        prefiksami sieci zdalnych. Dzięki funkcji rodzin adresów, OSPFv3 może
        obsługiwać zarówno IPv6 jak i IPv4. Protokół ten posiada te same
        funkcje co OSPF w wersji 2, natomiast OSPFv3 uruchamia osobne procesy
        dla IPv4 i IPv6.
      </p>
      <p>
        Rodziny adresów wykraczają po za zakres kursu CCNA.
      </p>
      <h2 id="3.1.1.ospfpackets">3.1.1. Pakiety OSPF</h2>
      <p>
        Omawiając OSPF poznaliśmy rodzaje pakietów jakie urządzenia wysyłają
        między sobą. Pakiety te mają przypisane określone wartości liczbowe,
        który jest typem pakietów LSP (<em>Link-State Packets</em>).
      </p>
      <ul>
        <li><strong>Typ 1: Hello</strong> - jest używany do ustanawiania i
          utrzymywania relacji przyległości między innymi routerami OSPF.</li>
        <li><strong>Typ 2: Pakiet opisu bazy danych (DBD)</strong> - zawiera
          skróconą listę LSDB i jest wykorzystywana przez inne routery
          odbierające do porównania z lokalną bazą LSDB. Baza musi być na
          wszystkich routerach w danym obszarze identyczna, aby móc zbudować
          drzewo SPF.</li>
        <li><strong>Typ 3: Pakiet żądania stanu łącza (LSR)</strong> - Routery
          odbierające mogą zarządać dodatkowym informacji o dowolnym wpisie
          w DBD wysyłając LSR.</li>
        <li><strong>Typ 4: Pakiet aktualizacji stanu łącza (LSU)</strong> - 
          służy do odpowiadnia na LSR i ogłaszania nowych informacji.
          Komunikaty LSU zawierają kilka różnych typów LSA.</li>
        <li><strong>Typ 5: Pakiet potwierdzenia stanu łącza (LSAck)</strong> -
          Po otrzymaniu LSU router wysyła LSAck w celu potwierdzenia. Pole
          danych pakietu tego typu jest puste.</li>
      </ul>
      <p>
        Początkowo urządzenia wymieniają między sobą pakiety DBD.
        Jeśli potrzebne są dodatkowe informacje na temat wpisów w bazie,
        routery mogą wysłać LSR, wówczas inne routery odpowiedzą za pomocą
        pakietu LSU. Pakiet LSU może zawierać 11 typów LSA dla OSPFv2. 
        Różnica w terminologii między LSU a LSA może być mylącą, ponieważ te
        określenia stosowane są zamiennie, jednak należy pamiętać, że LSU
        może zwierać jeden lub więcej komunikatów LSA. Rodzaje komunikatów
        LSA są następujące:
      </p>
      <ol>
        <li>LSA Routera.</li>
        <li>Służy do synchronizacji bazy danych topologii pomiędzy routerami.</li>
        <li>Podsumowanie LSA.</li>
        <li>Podsumowanie LSA.</li>
        <li>LSA zewnętrznego systemu autonomicznego.</li>
        <li>LSA transmisji <em>multicast</em> OSFP.</li>
        <li>Zdefiniowane dla obszarów NSSA (Not-So-Stubby-Areas).</li>
        <li>Atrybuty zewnętrzne LSA dla protokołu BGP (Border Gateway Protocol).</li>
      </ol>
      <p>
        Pakiety <em>Hello</em>, posiadają kilka dodatkowych czynności
        wykonywanych na rzecz protokołu OSPF, do jego zadań należy między
        innymi:
      </p>
      <ul>
        <li>Wykrywają sąsiadów OSPF i tworzą z nimi przyległości.</li>
        <li>Ogłaszają parametry, które dwa routery muszą uzgodnić, aby
          zostać sąsiadami.</li>
        <li>Wybierają router desygnowany i zapasowy router desygnowany w
          sieciach wielodostępowych, takich jak Ethernet. Łącza typu
          punkt-punkt nie potrzebują DR ani BDR.</li>
      </ul>
      <p>
        Natomiast sam pakiet <em>Hello</em>, składa się z nagłówka OSPF oraz
        jego własnych danych. Części te zawierają następujące pola:
      </p>
      <p>
        Nagłówek pakietu OSPF:
      </p>
      <ul>
        <li><strong>Typ</strong> - pole określające rodzaj informacji zawartych
          w polu danych pakietów OSPF.</li>
        <li><strong>Identyfikator routera</strong> - Identyfikator pozwalający
          na jednoznaczne określenie routera źródłowego. Identyfikator ten
          ma postać identyczną z adresem IP.</li>
        <li><strong>Identyfikator obszaru</strong> - numer obszaru, z którego
          pochodzi ten pakiet.</li>
      </ul>
      <p>
        Dane pakietu <em>Hello</em>:
      </p>
      <ul>
        <li><strong>Maska podsieci</strong> - skojarzona z interfejsem
          wysyłającym.</li>
        <li><strong>Interwał <em>Hello</em></strong> - określa częstotliwość 
          wysłania
          pakietów <em>Hello</em>. Domyślnie jest 10 sekund. Ważne jest aby
          routery miały ustawioną taką samą tę wartość, inaczej nie dojdzie
          do relacji przylegania.</li>
        <li><strong>Priorytet routera</strong> - wartość wykorzystywana w 
          wyborze DR/BDR. Domyślną wartością dla wszyskich routerów jest 1.
          Jednak może przyjmować wartości od 0 do 255. Im wieksza wartość, tym
          większe prawdopodobieństwo, że router zostanie wybrany desygnowanym
          na łączu.</li>
        <li><strong>Interwał <em>Dead</em></strong> - określona ilość czasu,
          przez którą czeka router na sygnał od sąsiada, za nim ogłosi że on
          nie działa. Domyślnie ta wartość wynosi czterokrotność wartości
          <em>Hello</em>. Czas ten musi być na wszystkich routerach takich
          sam, inaczej nie dojdzie do relacji przyleania.</li>
        <li><strong>Router desygnowany (DR)</strong> - identyfikator routera
          desygnowanego (DR).</li>
        <li><strong>Zapasowy router desygnowany (BDR)</strong> - identyfikator
          zapasowego routera desygnowanego.</li>
        <li><strong>Lista sąsiadów</strong> - lista zawierająca identyfikatory
          wszystkich sąsiadujących routerów.</li>
      </ul>
      <h2 id="3.1.2.howospfworks">3.1.2. Działanie OSPF</h2>
      <p>
        Podczas osiągania zbierzności w sieci protokół OSPF będzie znajdować
        się kolejno w następujących stanach:
      </p>
      <ol>
        <li><strong>Stan Down</strong> -<br />
          <ul>
            <li>Brak odebranych pakietów <em>Hello</em> = <em>Down</em>.</li>
            <li>Router wysła pakiety <em>Hello</em>.</li>
            <li>Przejście do stanu <em>init</em>.</li>
          </ul>
        </li>
        <li><strong>Stan Init</strong> -<br />
          <ul>
            <li>Pakiety <em>Hello</em>, są odbierane od sąsiada.</li>
            <li>Zawiera identyfikator routera wysyłającego.</li>
            <li>Przejście do stanu <em>Two-Way</em>.</li>
          </ul>
        </li>
        <li><strong>Stan Two-Way</strong> -<br />
          <ul>
            <li>W tym stanie komunikacja między dwoma routerami jest
              dwukierkowa.</li>
            <li>Na łączach wielodostępowych routery wybierają DR i BDR.</li>
            <li>Przejście do stanu <em>ExStart</em>.</li>
          </ul>
        </li>
        <li><strong>Stan ExStart</strong> -<br />
          <ul>
            <li>W sieciach punkt-punkt, oba routery decydują, który router
              zainicjuje wymianę pakietów DBD oraz ustalają początkowy numer
              sekwencji pakietów DBD.
          </ul>
        </li>
        <li><strong>Stan Exchange</strong> -<br />
          <ul>
            <li>Routery wymieniają pakiety DBD.</li>
            <li>Jeśli wymagane są dodatkowe informacje, to następuje przejście
              do stanu <em>Loading</em>, jeśli nie to do stanu <em>Full</em>.
          </ul>
        </li>
        <li><strong>Stan Loading</strong> -<br />
          <ul>
            <li>W celu uzyskania dodatkowych informacji o trasach
              wykorzystywane są komunikaty LSU i LSR.</li>
            <li>Trasy są przetwarzane z użyciem algorytmu SPF.</li>
            <li>Przjeście do stanu <em>Full</em>.</li>
          </ul>
        </li>
        <li><strong>Stan Full</strong> - Baza danych łącza stanu router jest
          w pełni z synchronizowana.
        </li>
      </ol>
      <p>
        W celu ustalenia relacji przyległości, router w momencie uruchomienia
        OSPF na określonych interfejsach wysyła przez nie pakiet <em>Hello</em>
        na adres multicastowy - <strong>224.0.0.5</strong>. W ten sposób
        protokół na tym urządzeniu przechodzi ze stanu <em>Down</em> do stanu
        <em>Init</em>. W momecie gdy drugi router obierze pakiet <em>Hello</em>
        dodaje identyfikator (OSFP) nadawcy do swojej listy sąsiadów następnie
        odpowiada nadawcy pakietem <em>Hello</em>, ze swoim identyfikatorem
        oraz listą sąsiadów. Nadawca odbiera <em>Hello</em> i dodaje ID
        drugiego routera do swojej listy sąsiadów. W momencie odebrania listy
        sąsiadów ze swoim ID protokoł przechodzi w stan <em>Two-Way</em>.
        Ten stan może wykonać dwie czynności w zależności od tego jakiego
        rodzaju łącze znajduje się na tym interfejsie jeśli:
      </p>
      <ul>
        <li>Jest to połączenie punkt-punkt (połączenia szeregowe) to protokół
          przechodzi natychmast w stan <em>ExStart</em>.</li>
        <li>Jeśli jest to łącze wielodostępowe, np. <em>Ethernet</em>, to 
          zachodzi potrzeba wybrania routera desygnowanego oraz zapasowego
          routera desygnowanego.
      </ul>
      <p>
        Podczas wyboru DR oraz BDR, cały czas pomiędzy urządzeniami wysłane są
        pakiety <em>Hello</em>. Pierwszy router - R1 - ma priorytet równy
        1 i drugi najwyższy ID routera. Drugi router - R2 - ma również 
        priorytet
        równy jeden, ale ma wyższe ID routera. Zatem R1 zostanie wybrany jako
        BDR, a R2 jako DR.
      </p>
      <p>
        Po osiągnieciu stanu <em>Two-Way</em> przez protokół OSFP, następną
        czynnością jest synchronizacja baz danych. Do ustalania relacji
        przyległości wykorzystywaliśmy komunikaty <em>Hello</em>. Natomiast do
        synchronizacji baz wykorzystamy pakiety DBD oraz LSR.
      </p>
      <p>
        W stanie <em>ExStart</em> routery decydują o tym, który z nich wyśle
        DBD jako pierwszy. Router z najwyższym ID wyśle swoje DBD jako pierwszy
        podczas stanu <em>Exchange</em>.
      </p>
      <p>
        W stanie <em>Exchange</em> routery wymieniają się pakietami DBD,
        potwierdzając każdorazowo odbiór takiego pakietu, pakietem LSAck.
        Pakiet DBD zawiera informacje na temat wpisu nagłówka LSA, który
        występuje w bazie LSDB nadawcy. Wpisy mogą dotyczyć wybranego łączą lub
        sieci. Nagłówek każdego LSA zawiera: typ pakiet stanu łącza, adres
        routera rozgłaszającego, koszt danego łącza oraz numer sekwencyjny.
        Numer ten jest używany do ustalenia czy informacje zawarte w pakiecie
        są nadal aktualne.
      </p>
      <p>
        Oczywiście może zdarzyć się sytuacja, że informacje zawarte DBD będą
        bardziej aktualne, wówczas protokół przechodzi do
        stanu <em>Loading</em>.
        Na podstawie informacji zawartych w DBD, router może zarządać od 
        drugiego routera
        dodatkowych informacji na temat jednego ze wpisów. W tym celu wysyła
        do drugiego urządzenia komunikat LSR. Druga strona odpowiada mu
        komunikatem LSU, zawierającym dodatkowe informacje. Nadawca LSR
        odpowiada na LSU, komunikatem LSAck. 
      </p>
      <p>
        Natomiast jeśli otrzyma i przetworzy wszystkie
        żądania, wówczas można uznać go za w pełni zsynchonizowanego i
        protokół przechodzi w stan <em>Full</em>.
      </p>
      <p>
        OSFP nie jest rozwiązaniem bez wad. W przypadku łączy wielodostępowych
        takich jak <em>Ethernet</em>, jeden z routerów będzie mieć relacje
        sąsiedztwa ze wszystkimi routerami w sieci, nawet tymi odległymi.
        Zwróćmy uwagę na to, że w sieci może być (jesli liczba routerów to
        <strong>n</strong>): n(n-1)/2 relacji przlegania. To całkiem dużo
        informacji do przetworzenia podczas uzyskiwania zbieżności OSPF.
        W przypadku 5 routerów relacji przyległości będzie tylko 10, ale w
        przypadku 20 już 190.
        Kolejną wadą jest zalewanie sieci przez pakiety LSA. Dlatego też do
        OSPF wprowadzono koncept <strong>routera desygnowanego</strong> (DR)
        oraz <strong>zapasowego routera desygnowanego.</strong>. 
      </p>
      <p>
        Router desygnowany (DR) jest punkt zbierania oraz dystrybucji pakietów
        LSA, na wypadek jego awarii wybierany jest zapasowy router desygnowany
        (BDR). Pozostałe routery oznaczane są jako DROTHER, nie są one ani
        DR, ani BDR. Pozostałe routery tworzą relację przyległości z DR i BDR
        oraz DR z BDR. Wówczas LSA przesyłane jest tylko do tych dwóch urządzeń
        natomiast one przekazują te informacje dalej.
      </p>
      <h2 id="3.1.summary">Podsumowanie</h2>
      <p>
        W pierwszym rodziale 3 modułu, zapoznaliśmy się z jedynym w tym
        kursie protokółem routingu - OSPF. Poznaliśmy jego elementy składowe,
        omówiliśmy komunikaty jakim się posługuje, aby wymienia informacje z
        innymi urządzeniami. Na koniec dowiedzieliśmy się w jaki sposób
        dokonuj on zbieżonści - poznaliśmy jego działanie.
      </p>
      <h1 id="3.2.oneareaospfconfiguration">3.2. Konfiguracja jednoobszarowego OSPFv2</h1>
      <p>
        W poprzednim rodziale zapoznaliśmy się z działaniem dynamicznego
        protokołu routingu, jakim jest OSPF w wersji 2. W tym rozdziale dowiemy
        się w jaki sposób uruchomić instację OSPF na urządzeniach z systemem
        IOS. Dla celów szkolenionych przyda nam się topologia utworzona w
        Packet Tracerze. Topologia powinna składać się z kilku routerów. Za
        pomocą interfejsów <em>loopback</em>, będziemy symulować obecność sieci
        lokalnej oraz Internetu. Topologia może wyglądać następująco:
      </p>
      <p style="width: 100%">
        <img src="https://ftp.morketsmerke.org/img/ensa_ch_2_sh1.png" />
      </p>
      <p>
        Uruchomienie OSPF w IOS jest czymś w rodzaju uruchomienia odrębnego
        programu. Ponieważ musimy zdefiniować ID procesu. Jest to wartość
        lokalna, ustawiana przez administratora. Pozwala ona urządzeniu
        rozróżnić procesy (na routerach Cisco, można uruchomić wiele instancji
        OSPF). ID procesu może przyjąć wartość od 1 do 65535. Rozbierzność w
        identyfikatorach procesu nie wpływa na ustawienie przylegania. Sam
        proces uruchomiamy w konfiguracji globalnej wydając poniższe polecenie:
      </p>
<pre class="code-block">
R2(config)#router ospf 1
R2(config-router)#?
  area                   OSPF area parameters
  auto-cost              Calculate OSPF interface cost according to bandwidth
  default-information    Control distribution of default information
  distance               Define an administrative distance
  exit                   Exit from routing protocol configuration mode
  log-adjacency-changes  Log changes in adjacency state
  neighbor               Specify a neighbor router
  network                Enable routing on an IP network
  no                     Negate a command or set its defaults
  passive-interface      Suppress routing updates on an interface
  redistribute           Redistribute information from another routing protocol
  router-id              router-id for this OSPF process
</pre>
      <p>
        Po uruchomieniu procesu, przechodzimy do konfiguracji protokołu. Za
        pomocą znaku zapytania (<strong>?</strong>) możemy wyświetlić wszystkie
        dostępne polecenia w trybie konfiguracji OSPF.
      </p>
      <p>
        Jak pamiętamy z poprzedniego rozdziału ID routera w OSPF korzysta
        formatu adresu IP. Nawet lepiej, wykorzystuje adresy które są
        zdefiniowane na urządzeniu, w przypadku automatycznej konfiguracji - 
        nie podania
        ID. Nie mniej jednak, należy pamiętać, że to nie są adres IP i
        nie biorą one udziału w komunikacji. Identyfikator jest potrzebny w
        stanie <em>Exchange</em> do ustalenia, który router jako pierwszy
        wyśle komunikat DBD oraz do określania roli (DR/BDR) routera w
        przypadku łączy wielodostępowych.
      </p>
      <p>
        Algorytm wyboru identyfikatora przezentuje się w następujący sposób:
      </p>
      <ol>
        <li>Jeśli identyfikator został jawnie skonfigurowany to wybierz
            go jako identyfikator routera. Jeśli nie to patrz krok 2.</li>
        <li>Jeśli skonfigurowano interfejs <em>loopback</em>, to użyj jego
            adresu IPv4 jako identyfikatora routera. Jeśli nie to patrz krok 3.</li>
        <li>Użyj najwyższego skonfigurowanego adresu IPv4 jako ID routera.</li>
      </ol>
      <p>
        W przypadku jeśli skonfigurowano więcej niż jeden <em>loopback</em>, to
        wówczas algorytm zachowuje się identycznie jak w kroku 3, tylko wobec
        adresów interfejsów pętli.
      </p>
      <p>
        W systemach produkcyjnych, możemy skonfigurować sobie interfejs pętli,
        aby jego adres został użyty jako ID routera w OSPF. W wykorzystywanej
        tutaj topologii, interfejsy <em>loopback</em> są wykorzystywane więc
        po uruchomieniu procesu OSPF na R2, przyjął on o taki oto identyfikator:
      </p>
<pre class="code-block">
R2#show ip protocols 

Routing Protocol is "ospf 1"
  Outgoing update filter list for all interfaces is not set 
  Incoming update filter list for all interfaces is not set 
  Router ID 64.100.0.1
  Number of areas in this router is 0. 0 normal 0 stub 0 nssa
  Maximum path: 4
  Routing for Networks:
  Routing Information Sources:  
    Gateway         Distance      Last Update 
  Distance: (default is 110)
</pre>
      <p>
        Chcąc jawnie zmienić ID routera, musimy przjeść do konfiguracji
        procesu OSPF, następnie użyć polecenia
        <code class="code-inline">router-id</code> i jako argument podać ID.
      </p>
<pre class="code-block">
R2(config)#router ospf 1
R2(config-router)#router-id 2.2.2.2
R2(config-router)#exit
R2(config)#do show ip proto

Routing Protocol is "ospf 1"
  Outgoing update filter list for all interfaces is not set 
  Incoming update filter list for all interfaces is not set 
  Router ID 2.2.2.2
  Number of areas in this router is 0. 0 normal 0 stub 0 nssa
  Maximum path: 4
  Routing for Networks:
  Routing Information Sources:  
    Gateway         Distance      Last Update 
  Distance: (default is 110)
</pre>
      <p>
        W przypadku, gdy router bedzie mieć już jakieś relacje przygłości
        ID nie zostatnie zmienione. Aby nasze zmiany miały skutek, musimy
        z restartować proces OSPF. Dokonamy tego w trybie 
        <strong>uprzywilejowanym EXEC</strong>, wydając poniższe polecenie:
      </p>
<pre class="code-block">
R2#clear ip ospf process 
Reset ALL OSPF processes? [no]: yes
</pre>
      <p>
        Po wydaniu tego polecenia system zapyta się czy zrestartować wszyskie
        procesy. Pyta dlatego, że nie podaliśmy ID procesu, nie mniej jednak 
        w Packet Tracerze jest nie zostało to zaimplementowane.
      </p>
      <p>
        Starsze wersje IOS, nie posiadają polecenia 
        <code class="code-inline">router-id</code>. Zatem najlepszym sposobem
        na ustawienie ID routera jest skonfigurowanie interfejsu <em>loopback</em>.
      </p>
      <h2 id="3.2.1.networksinospf">3.2.1. Sieci w OSPF</h2>
      <p>
        Sieci w OSPF możemy konfigurować na dwa sposoby pierwszy z nich jest
        jest przypisanie sieci do procesu OSPF przy użyciu polecenia
        <strong>network</strong>, trybu konfiguracji protokołu. Poniżej
        znajduje się ogólna składania tego polecenia.
      </p>
<pre class="code-block">
R2(config-router)# network adres-sieci maska-blankietowa area id-obszaru
</pre>
      <p>
        Kombinacja adres sieci, maska blankietowa służy uruchomieniu OSPF na
        interfejsach. Natomiast id-obszaru wskazuje numer obszaru, w którym
        dana sieć ma być rozgłaszana. W przypadku konfiguracji
        jednoobszarowej, na wszystkich routerach powinien być ustawiony ten sam
        identyfikator obszaru. Dobrą praktyką jest ustawienie obszaru o 
        ID 0.
      </p>
      <p>
        Maska blankietowa (<em>wildcard mask</em>) jest odwrotnością, 
        klasycznej maski podsieci. Jak
        w przypadku klasycznej maski, wartości binarnej 1 na masce oznaczały
        dopasowanie bitu adresu, a binarne 0 jego brak, tak w przypadku maski
        blankietowej: binarne 0 oznaczają dopasowanie odpowiedniej wartości
        bitu w adresie, a jeden zignorowanie wartości tego bitu w adresie.
        Maskę blankietową najlepiej utworzyć porzez odjęcie od pełnej maski
        32-bitowej - 255.255.255.255, maski naszej sieci. Na przykład:
      </p>
<pre class="code-block">
  255.255.255.255
- 255.255.255.252
-----------------
    0.  0.  0.  3
</pre>
      <p>
        Maską blankietową dla maski podsieci /30 jest 0.0.0.3.
      </p>
      <p>
        Teraz znając wszysktie części składni polecenia <em>network</em> możemy
        przejść do jego konfiguracji.
      </p>
<pre class="code-block">
R1(config)#router ospf 1
R1(config-router)#network 10.1.1.4 0.0.0.3 area 0
R1(config-router)#network 10.1.1.12 0.0.0.3 area 0
R1(config-router)#network 10.10.1.0 0.0.0.255 area 0
</pre>
      <p>
        Inną metodą na wykorzystanie polecenia jest <em>network</em> jest
        podanie zamiast adresu sieci, adresu interfejsu oraz maski 0.0.0.0.
        Uruchomi to proces na tym interfejsach i zacznie rozgłaszać sieci, 
        które są dostępne na tych interfejsach.
      </p>
<pre class="code-block">
R1(config)#router ospf 1
R1(config-router)#network 10.1.1.5 0.0.0.0 area 0
R1(config-router)#network 10.1.1.14 0.0.0.0 area 0
R1(config-router)#network 10.10.1.1 0.0.0.0 area 0
</pre>
      <p>
        Drugim sposobem na rozgłaszanie sieci przez OSPF jest skonfigurowanie
        tego bezpośrednio na interfejsie. Zanim do tego przejedziemy musimy,
        wycofać uprzednio wprowadzone polecenia
        <code class="code-inline">network</code>.
      </p>
<pre class="code-block">
R1(config)#router ospf 1
R1(config-router)#no network 10.1.1.4 0.0.0.3 area 0
R1(config-router)#no network 10.1.1.12 0.0.0.3 area 0
R1(config-router)#no network 10.1.1.12 0.0.0.3 area 0
R1(config-router)#exit
R1(config)#int g0/0
R1(config-if)# ip ospf 1 area 0
R1(config-if)#int g0/1
R1(config-if)# ip ospf 1 area 0
R1(config-if)#int lo0
R1(config-if)# ip ospf 1 area 0
</pre>
      <p>
        Komunikty OSPF powinny być wysyłane wyłącznie na interfejsach, do
        których podłączone są inne routery z włączonym OSPF. Domyślnie jednak
        są one wysyłane przez wszystkie interfejsy, na których został
        uruchomiony ten protokół, w tym i sieci LAN, tutaj symulowanej za
        pomocą <em>loopback</em>-a. Takie działanie nie jest za bardzo
        pożądane, z kilku powodów:
      </p>
      <ul>
        <li><strong>Nieefektywne wykorzystanie pasa</strong> - poprzez
          przesyłanie nie potrzebnych komunikatów.</li>
        <li><strong>Nieefektywny wykorzystanie zasobów</strong> - każdy z
          hostów w sieci obiera część tych komunikatów, następnie musi je
          przetworzyć, a następnie odrzucić.</li>
        <li><strong>Zwiększone ryzko bezpieczeństwa</strong> - ruch OSPF bez
          dodatkowych mechanizmów można przechwycić za pomocą takich narzędzi
          jak <em>Wireshark</em> i następnie wysłać fałszywą aktualizację
          ruchu i kierować go gdzie to tylko możliwe.</li>
      </ul>
      <p>
        Zapobieganiu tego rodzaju niedogodnościom służy mechanizm interfejsu
        pasywnego. Jest to rodzaj konfiguracji, w której wskazujemy interfejs
        pasywny i ograniczamy wysyłanie komunikatów OSPF przez niego, przyczym
        pozostaje on częścią obszaru, tj. komunikaty na temat jego sieci dalej
        będą wysyłane do innych routerów. Konfiguracja pasywnego interfejsu
        znajduje się poniżej.
      </p>
<pre class="code-block">
R1(config)#router ospf 1
R1(config-router)#passive-interface lo0
R1(config-router)#exit
</pre>
      <p>
        Po uzyskaniu zbierzności OSPF, jeśli przyjrzymy się tablicy routingu
        to trasy do sieci reprezentowanych przez interfejsy <em>loopback</em>.
        Sa trasami hostów, a nie trasami do sieci. Jest domyślne działanie.
        Jeśli miały by być one trasami sieci, to na interfejsie pętli należy
        wydać poniższe polecenie.
      </p>
<pre class="code-block">
R1(config-if)# interface Loopback 0
R1(config-if)# ip ospf network point-to-point
</pre>
      <p>
        Wówczas ten interfejs będzie traktowany jako połączenie punkt-punkt.
        I teraz będzie rozgłaszana trasa to sieci interfejsu pętli.
      </p>
      <h3 id="3.2.1.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.2.13-packet-tracer---point-to-point-single-area-ospfv2-configuration_pl-PL.pdf">Konfiguracja OSPFv2 punkt-punkt - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.2.13-packet-tracer---point-to-point-single-area-ospfv2-configuration_pl-PL.pka">Konfiguracja OSPFv2 punkt-punkt - zadanie</a>
      </p>
      <h2 id="3.2.2.multiaccessospfnetworks">3.2.2. Wielodostępowe sieci OSPF</h2>
      <p>
        Jak pamiętamy, jeśli skonfigurujemy OSPF na łączu wielodostępowym
        to wówczas routery ustalają między sobą rolę, aby zapewnić jak
        najmniejszy narzut OSPF na urządzenia. 
      </p>
      <p>
        Aby sprawdzić rolę routera możemy odpytać bazę relacji przyległości:
      </p>
<pre class="code-block">
R1#sh ip ospf neigh


Neighbor ID     Pri   State           Dead Time   Address         Interface
3.3.3.3           1   FULL/DR         00:00:31    10.1.1.13       GigabitEthernet0/1
2.2.2.2           1   FULL/DR         00:00:34    10.1.1.6        GigabitEthernet0/0
</pre>
    
        <p>
          Na podstawie kolumn <code class="code-inline">State</code> możemy
          stwierdzić, że <code class="code-inline">R1</code> jest w pełnej
          zbieżności OSPF <code class="code-inline">FULL</code> oraz jest
          zapasowym routerem desygnowanym jeśli role obu sąsiadów to
          <code class="code-inline">DR</code>. Innym stanem jaki możemy
          spotkać jest <em>2-WAY/DROTHER</em>, oznacza on, że routery są
          w stanie uzyskiwania zbieżności i jeszcze nie mają określonych ról.
        </p>
        <p>
          Oczywiście możliwy jest wpływ na określanie ról routerów przy łączach
          wielodostępowych. Możemy swobodnie manipulować priorytetem OSPF.
          Dzięki czemy możemy jasno określić jakie urządzenie ma pełnić jaką
          rolę. Aby zmienić priorytet w konfiguracji interfejsu wydajemy
          poniższe polecenie:
        </p>
<pre class="code-block">
R1(config)#int g0/0
R1(config-if)#ip ospf priority 200
</pre>
        <p>
          Po zmianie priorytetu musimy zresetować proces OSPF.
        </p>
        <h3 id="3.2.2.pka">Zadanie praktycznie - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.3.11-packet-tracer---determine-the-dr-and-bdr_pl-PL.pdf">Określanie DR i BDR - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.3.11-packet-tracer---determine-the-dr-and-bdr_pl-PL.pka">Określanie DR i BDR - cenariusz</a>
        </p>
        <h2 id="3.2.2.modifyingoneareaospfv2">3.2.2. Modyfikowanie jednoobszarowego OSPFv2</h2>
        <p>
          Routery na podstawie metryki zapisanej w trasie, w tablicy routingu
          dokonują wybory najlepszej ścieżki. W przypadku OSPF tą metryką jest
          <strong>koszt</strong> obliczony poprzez iloraz
          <strong>referencyjne szerokości pasma</strong> przez
          <strong>szerokość pasma interfejsu</strong>. Te wartości wyrażone
          są w bitach na sekundę. Domyślną referencyjną szerokością pasma
          jest 100,000,000 b/s. To jeśli przeskalujemy sobie tę wartość na
          Mb. To wówczas wynik będzie = 100Mb/s, ze zwględu na to, że jest
          iloraz - metryka dla łączy 100Mb/s będzie równa 1. Dodatkowo te
          obliczenia są całkowite, więc łącza gigabitowe oraz 10-cio gigabitowe
          będą mieć tę samą metrykę co 100Mb. Więc ze względu na rozwijające 
          się umożliwiono zmianę referencyjnej szerokości pasma.
        </p>
        <p>
          Aby zmienić wartość refencyjną szerokości pasma,
          <strong>na wszystkich</strong> routerach w trybie konfiguracji
          protokołu OSPF wydajemy następujące polecenie
        </p>
<pre class="code-block">
Router(config-router)# auto-cost reference-bandwidth Mbps
</pre>
        <p>
          Zamiast <code class="code-inline">Mbps</code> podajemy wartość
          referencyjną w Mb. W zależności od naszej infrastruktury, myślę że
          można spokojnie ustawić 10Gb, tj. 10000Mb.
        </p>
        <p>
          Inna wartością jaką możemy manipulować, aby wpłynąć na wybór
          najlepszej trasy przez OSPF jest sam koszt ścieżki. Dokonać tego
          możemy za pomocą poniższego polecenia wydane w konfiguracji
          interfejsu. <strong>Uwaga, należy pamiętać, aby ustawić również taki
          sam koszt po drugiej stronie ścieżki.</strong>
        </p>
<pre class="code-block">
R1(config)# interface g0/1
R1(config-if)# ip ospf cost 30
R1(config-if)# interface lo0
R1(config-if)# ip ospf cost 10
R1(config-if)# end
</pre>
        <p>
          Częstotliwość wysyłania pakietów <em>Hello</em> oraz czas oczekiwania
          na nie <em>Dead</em>, są kolejnymi cechami protokołu OSPF, na który
          my jako administratorzy możemy wpłynąć. Za pomocą polecenia:
        </p>
<pre class="code-block">
R2#show ip ospf int g0/0
...
  Timer intervals configured, Hello 10, Dead 40, Wait 40, Retransmit 5
</pre>
        <p>
          Możemy sprawdzić jak została ustawiona częstotliwość pakietów
          <em>Hello</em> oraz ustawiony czas oczekiwania <em>Dead</em>.
          Dodatkowo czas oczekiwania <em>Dead</em> występuje w innym poleceniu
        </p>
<pre class="code-block">
R2#show ip ospf neigh


Neighbor ID     Pri   State           Dead Time   Address         Interface
1.1.1.1           1   FULL/BDR        00:00:30    10.1.1.5        GigabitEthernet0/0
3.3.3.3           1   FULL/BDR        00:00:30    10.1.1.10       GigabitEthernet0/1
R2#show ip ospf neigh


Neighbor ID     Pri   State           Dead Time   Address         Interface
1.1.1.1           1   FULL/BDR        00:00:39    10.1.1.5        GigabitEthernet0/0
3.3.3.3           1   FULL/BDR        00:00:39    10.1.1.10       GigabitEthernet0/1
</pre>
        <p>
          Tutaj czas oczekiwania został przedstawiony w kolumnie
          <code class="code-inline">Dead Time</code> w postaci licznika, który
          odlicza w dół do 0,
          każdorazowe nadejście pakietu <em>Hello</em> go restartuje.
        </p>
        <p>
          Modyfikacji wyżej wymienionych wartości możemy dokonać w konfiguracji
          interfejsu. <strong>Na obu routerach te wartości muszą być takie same
          inaczej nie dojdzie do relacji przyległości.</strong>.
        </p>
<pre class="code-block">
R1(config-if)# ip ospf hello-interval S
R1(config-if)# ip ospf dead-interval S
</pre>
        <p>
          Gdzie <code class="code-inline">S</code>, to liczba sekund. Te
          wartości domyślnie są oparte o dobre praktyki. Nie ma potrzeby ich
          zmieniać nie mniej jednak istnieje taka możliwość i została ona tutaj
          przedstawiona.
        </p>
        <h3 id="3.2.3.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.4.11-packet-tracer---modify-single-area-ospfv2_pl-PL.pdf">Modyfikowanie jednoobszarowego OSPFv2 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.4.11-packet-tracer---modify-single-area-ospfv2_pl-PL.pka">Modyfikowanie jednoobszarowego OSPFv2 - zadanie</a>
        </p>
        <h2 id="3.2.4.propagatedefaultrouteinospf">3.2.4. Propagowanie tras domyślnych w OSPF.</h2>
        <p>
          Protokół OSPF daje nam możliwość możliwość rozpropagowania tras 
          domyślnych z jednego routera na pozostałe w danym obszarze. Służy
          do tego poniższe polecenie wydane w konfiguracji protokołu OSPF.
        </p>
<pre class="code-block">
R2(config)#ip route 0.0.0.0 0.0.0.0 lo1
%Default route without gateway, if not a point-to-point interface, may impact performance
R2(config)#
R2(config)#route ospf 1
R2(config-router)#default-information originate
</pre>
        <p>
          Aby sprawdzić czy nasza trasa się rozpropagowała, należy wyświetlić
          tablicę routingu innego routera:
        </p>
<pre class="code-block">
R1#show ip route
...
Gateway of last resort is 10.1.1.6 to network 0.0.0.0
...
O*E2 0.0.0.0/0 [110/1] via 10.1.1.6, 00:04:14, GigabitEthernet0/0
</pre>
        <p>
          Tak przekazaną trasę IOS traktuje jako zewnętrzną trasę OSPF typu 2.
        </p>
        <h3 id="3.2.4.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.5.3-packet-tracer---propagate-a-default-route-in-ospfv2_pl-PL.pdf">Propagowanie trasy domyślnej w OSPFv2 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.5.3-packet-tracer---propagate-a-default-route-in-ospfv2_pl-PL.pka">Propagowanie trasy domyślnej w OSPFv2 - zadanie</a><br />
        </p>
        <h2 id="3.2.5.verifyingoneareaospfv2">3.2.5. Weryfikowanie jednoobszarowego OSPFv2</h2>
        <p>
          W celu zweryfikowania konfiguracji OSPFv2 na naszych urządzeniach
          możemy posłużyć się następującymi poleceniami:
        </p>
        <ul>
          <li><code class="code-inline">show ip ospf neighbor</code> -
            weryfikacja sąsiadów OSPF.</li>
          <li><code class="code-inline">show ip protocols</code> - 
            weryfikacja ustawień protokołu OSPF.</li>
          <li><code class="code-inline">show ip ospf</code> - weryfikacja
            procesu OSPF.</li>
          <li><code class="code-inline">show ip ospf interface</code> - 
            weryfikacja ustawień interfejsu OSPF.</li>
        </ul>
        <p>
          Powyższe polecenia mogą pomóc nam również w rozwiązywaniu problemów
          konfiguracją OSPF.
        </p>
        <h3 id="3.2.5.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.6.6-packet-tracer---verify-single-area-ospfv2_pl-PL.pdf">Weryfikowanie jednoobszarowego OSPFv2 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.6.6-packet-tracer---verify-single-area-ospfv2_pl-PL.pka">Weryfikowanie jednoobszarowego OSPFv2 - zadanie</a>
        </p>
        <h3 id="3.2.6.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.7.1-packet-tracer---single-area-ospfv2-configuration_pl-PL.pdf">Konfiguracja jednoobszarowego OSPFv2 punkt-punkt - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/2.7.1-packet-tracer---single-area-ospfv2-configuration_pl-PL.pka">Konfiguracja jednoobszarowego OSPFv2 punkt-punkt - zadanie</a>
        </p>
        <h3 id="3.2.6.lab">Laboratorium</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/lab/2.7.2-lab---configure-single-area-ospfv2_pl-PL.pdf">Konfiguracja jednoobszarowego OSPFv2</a>
        </p>
        <h2 id="3.2.summary">Podsumowanie</h2>
        <p>
          W tym rozdziale przekonaliśmy się jak pomocne mogą być dynamiczne
          protokoły routingu. Poznaliśmy metody konfiguracji protokołu,
          konfiguracji jego funkcji, dzięki czemu dowiedzieliśmy się, że możemy
          dostoswać część jego aspektów, następnie zapoznaliśmy się z
          propagacją tras domyślnych, a na koniec poznaliśmy serię poleceń,
          która pozwoli nam zweryfikować działanie OSPF i rozwiązać ewentualne
          problemy.
        </p>
        <h1 id="3.3.networksecurityconcepts">3.3. Koncepcje bezpieczeństwa sieci</h1>
        <p>
          W pierwszym module poruszaliśmy podstawowe zagadnienia bezpieczeństwa
          sieci. Teraz możemy omówić sobie te zagadnienia w szerszym spektrum,
          nieco bardziej skupiając się na ich poszczególnych aspektach.
        </p>
        <h2 id="3.3.1.currentstateofcybersecurity">3.3.1. Obecny stan cyberbezpieczeństwa</h2>
        <p>
          Obecnie cały czas trwa wyścig zbrojeń, cyberprzestęcy są w zasięgu
          jeszcze większej ilość wiedzy technicznej oraz coraz bardziej
          zawansowanych narzędzi pozwalających na łamanie zabeczpieczeń firm,
          osób prywatnych czy nawet infrastruktury krytycznej państw. Na
          wysokim poziomie stoi również rozwój wszelakiej maści złośliwego
          oprogramowania.
        </p>
        <p>
          Specjaliści stojący po drugiej stronie barykady muszą aktywnie
          przyglądać się rozwojowi zagrożeń oraz metod ich wykorzystywania, aby
          móc przygotować opowiednie środki zaradcze lub też z minimalizować
          skutek naruszenia naszych zabezpieczeń.
        </p>
        <p>
          Chcąc zrozumieć opisane tutaj tematy musimy na początku poznać kilka
          pojęć:
        </p>
        <ul>
          <li><strong>Zasoby</strong> - Zasobem możemy określić wszystko co dla
            organizacji, może mieć jakąś wartość. Od ludzi, przez sprzęt po
            dane w różnej postaci.</li>
          <li><strong>Podatność</strong> - to słabość w systemie lub jego
            konstrukcji może być wykorzystana przez żagrożenie.</li>
          <li><strong>Zagrożenie</strong> - potencjalne niebezpieczeństwo dla
            zasobów firmy.</li>
          <li><strong>Exploit</strong> - mechanizm wykorzystania podatności.</li>
          <li><strong>Ograniczenie</strong> - zmniejszenie prawdopodobniestwa
            lub dokliwości zagrożenia bądź ryzka.</li>
          <li><strong>Ryzko</strong> - prawdopodobieństwo wykorzystania
            przez zagrożnie podatności zasobów mające negatywny wpływ na
            organizację. Jest ono mierzone przy użyciu prawdopobieństwa jego
            wystąpienia oraz jego potencjalnych skutków.</li> 
        </ul>
        <p>
          Spośród obecnie przeprowadznych ataków sieciowych możemy wytypować
          dwa typowe wektory ataków. Pierwszym z nich jest zewnętrzny wektor,
          oznacza on, że zagrożenie występuje poza naszą siecią wówczas ryzkiem
          liczyć się muszą urządzenia brzegowe, takie jak router czy zapory
          sieciowe, ale także aplikacje wystawione do sieci zewnętrznych w celu
          udostępnienia, niektórych zasobów firmy. Drugim wektorem jest
          wektor wewnętrzny gdzie zagrożenie stanowią pracownicy tej samej
          organizacji. Ten wektor jest szczególnie niebezpieczny, ponieważ
          pracownicy często znają infrastrukturę i często część metod
          uwierzytelnia i autoryzacji, ale co najważniejsze pracownicy 
          posiadają
          pewien poziom uprawnień do zasobów firmy. 
        </p>
        <p>
          Jednym z dość szczególnych wektorów zagrożenia, które nie muszą być
          powiązane z atakami jest <strong>utrata danych</strong>. Dane są
          bardzo często najbardziej wartościowymi zasobami w firmie, ich utrata,
          bądź ich upublicznienie (jak w przypadku danych wrażliwych - np.
          wyniki badan czy dane osobowe pracowników) może być rownoznacza z 
          zakończeniem jej działalności lub nieprzyjemnymi konsekwencjami
          prawnymi.
        </p>
        <h2 id="3.3.2.threatactor">3.3.2. Podmioty zagrożenia</h2>
        <p>
          Dawniej <strong>hakerzy</strong> byli uznawani za żartownisiów,
          wykonujących przenajróżniejsze dowcipy. Poźniej termin ten ewoluował
          i by przypisywany wybitnym programistom, którzy dzieli się efektami
          swoich prac, gdzieś tam pojawili się pierwsi ludzie którzy łamali
          zabezpieczenia stawiane przez hakerów, którzy działali na zlecenie
          osób trzecich. Ich z kolei zaczęto nazwywać krakerami. Krakerzy
          dokonywali swojej działalności, z różnych pobudek, nie zawsze były
          to motywy finansowe, często było to sprawdzenie swoich umiejętności
          lub też uwolnienie informacji, która powinnać być dostępna dla
          opinii publicznej. Obecnie można spotkać się ze stwierdzeniem, że
          w Internecie panuje trzecia wojna światowa. Co jest poniekąd prawdą
          obecnie mało kto bawi się w łamanie zabezpieczeń dla zabawy. Jedni
          robią to z pobudek czysto finansowych i takowe osoby można uznać, za
          <strong>cyberprzestępców</strong>, innym rodzajem tego typu ludzi
          są <strong>hakerzy sponsorowani przez państwo</strong>, takie
          cyberarmie, które dokonują ataków na cele często będą infrastrukturą
          innych państw, motywy ich działania są znane tylko dowócom takich
          jednostek. Na szczególne omówienie zasługują tutaj
          <strong>haktywiści</strong>, dokonujący różnych naruszeń
          bezpieczeństwa sieci, chcąc zwrócić uwagę na jakiś problem społeczny
          oraz wywrzeć presję na politykę, aby rząd za przestał potencjalnego
          działania na szkodę obywateli - takie działanie miało miejsce 2012
          przy próbie wprowadzenia ustawy ACTA.
        </p>
        <p>
          Ostatecznie hakerów można podzielić na podstawie motywów ich
          działania, przypisując im odpowiedni kolor kapelusza. Tak więc
          <strong>białe kapelusze</strong> - to wszelkiego rodzaju programiści -
          członkowie
          społeczności otwartoźródłowych, ale również specjaliści do spraw
          bezpieczeństwa sieci, konsultanci oraz wszyscy dbający o
          bezpieczeństwo, nie tylko sieci za które są odpowiedzialni. Działają
          tylko w legalny sposób.
          <strong>Szare kapelusze</strong> - są to można by powiedzieć tzw.
          białe kapelusze, wykonujące nie które ze swoich zadań bez legalizacji.
          W celach rozrywkowych, poszerzenie swojej wiedzy czy również w celach
          prostestu (haktywiści). Ostatnią katergorią są
          <strong>czarne kapelusze</strong> - działają oni nielegalnie, 
          dokonują
          włamań oraz zakłóceń w działaniu sieci. Hakerzy tego rodzaju to 
          cyberprzestępcy oraz hakerz sponsorowani przez państwo.
        </p>
        <h2 id="3.3.3.threadactortoolkits">3.3.3. Narzędzia podmiotów zagrożeń</h2>
        <p>
          Takim podstawowym narzędziem, każdego kapelusza jest system
          operacyjny, z możliwością dostosowanie każdego swojego apektu
          działania. Bowiem hakerzy nie wykorzystują tylko laptopów czy
          komputerów klasy PC. Wykorzystają całą masę innej elektroniki i
          czasami ona musi zostać zaprogramowana. Aby umożliwić dostosowanie
          systemu operacyjnego przez użytkownika musimy mieć możliwość wglądu
          w jego kod źródłowy, więc takimi systemami są wszystkie
          otwartoźródłowe systemy uniksopodobne. Od dystrybucji Linuksa po
          systemy BSD, ich biegła znajomość jest wymagana zarówno przez
          białe jak i czarne kapelusze. 
        </p>
        <p>
          Oczywiście same systemy, wiosny nie czynią. Potrzebne jest do tego
          specjalistyczne oprogramowanie. Kiedy jeszcze temat bezpieczeństwa
          nie był tak powszechny, haker musiał samodzielnie napisać eksploit,
          jak i program go obsługujący. Hakerzy musieli wyróżniać się wysoką
          wiedzą techniczną, a mimo to ich narzędzia były często ukierunkowane
          na jedną podatność. W momencie upowszechnienia się
          <em>etycznego hakingu</em>, narzędzia stały się bardziej 
          wszechstronne i raczej skupiające się na pewnej funkcji, a niżeli
          na jednej podatności. Wśród nich możemy wyróżnić takie rodzaje
          oprogramowania jak:
        </p>
        <ul>
          <li><strong>Narzędzia do łamania haseł</strong> - John The Ripper,
            Ophcrack, L0pthCrack, THC Hydra, RainbowCrack, Medusa.</li>
          <li><strong>Narzędzia do sieci bezprzewodowych</strong> - Aircrack-ng,
            Kismet, InSSIDer, KisMac, Firesheep, NetStumbler.</li>
          <li><strong>Narzędzia do skanowania sieciowego</strong> - Nmap,
            SuperScan, Angry IP Scanner i NetScan.</li>
          <li><strong>Narzędzia do tworzenia pakietów</strong> - Hping, Scapy,
            Socat, Yersinia, Netcat, Nping i Nemezis.</li>
          <li><strong>Snifery Pakietów</strong> - Wireshark, TCPdump, Ettercap,
            Dsniff, Etherape, Paros, Fidler, Ratproxy, SSLStrip.</li>
          <li><strong>Detektory rootkitów</strong> - AIDE, NetFilter i PF
            (Filtr pakietów OpenBSD).</li>
          <li><strong>Fuzzery do wyszukiwania podatności</strong> - Skipfish,
            Wapiti, W3af.</li>
          <li><strong>Narzędzia kryminalistyczne</strong> - Sleuth Kit, Helix,
            Maltego i Encase.</li>
          <li><strong>Debugery</strong> - GDB, WinDbg, IDA Pro i Immunity
            Debuger.</li>
          <li><strong>Systemy operacyjne do hackingu</strong> - Kali Linux,
            Knopix, BackBox Linux.</li>
          <li><strong>Narzędzia szyfrujące</strong> - VeraCrypt, CipherShed,
            OpenSSH, OpenSSL, Tor, OpenVPN, Stunel.</li>
          <li><strong>Narzędzia eksploracji podatności</strong> - Metasploit,
            Core Impact, Sqlmap, Social Engineer Toolkit i Netsparker.</li>
          <li><strong>Skanery podatności</strong> - Nipper, Secunia PSI,
            Core Impact, Nessus v6, SAINT i Open VAS.</li>
        </ul>
        <p>
          Natomiast do rodzajów ataków możemy zaliczyć kolejno:
        </p>
        <ul>
          <li><strong>Atak podsłuchiwania</strong> - ma miejsce gdy podmiot 
            zagrożeń
            przechwytuje ruch sieciowy. Określane jako <em>sniffing</em> lub
            <em>snooping</em>.</li>
          <li><strong>Atak modyfikacji adresów</strong> - zmiana danych w
            pakiety bez wiedzy stron tej komunikacji.</li>
          <li><strong>Ataki z wykorzystaniem haseł</strong> - zalogowanie się
            na aktywne konto, w celach dalszej eskploracji sieci.</li>
          <li><strong>Ataki odmowy usługi</strong> - atak symujący duży ruch
            przeciążając tym samym serwer. Staje się on niedostępne dla
            innych użytkowników.</li>
          <li><strong>Ataki typu <em>man-in-the-middle</em></strong> - 
            wpięcie się pomiędzy nadawcą a odbiorcą zapewniając tym samym
            transparentną pełną kontrolę nad tą transmisją.</li>
          <li><strong>Ataki za pomocą zagrożonego klucza</strong> - Podmiot
            zagrożenia uzyskuje klucz do szyfrowanej transmisji, wówczas
            w taki przesył informacji można ingrerować.</li>
          <li><strong>Atak z użyciem sniffera</strong> - Użycie aplikacji
            pozwalającej na monitorowanie i przechwytwanie danych w sieci
            i odczytwanie pakietów.</li>
        </ul>
        <h2 id="3.3.4.malware">3.3.4. Złośliwe oprogramowanie</h2>
        <p>
          Na początku rozdziału wspomniano, że obecnie bardzo prężnie działa
          rozwój złośliwego oprogramowania. Gdzieś tam kiedy, każdemu udało 
          się zawirusować swój komputer, najczęściej odbywało się to poprzez
          pobranie jakiegoś szemranego pliku z Internetu. Najczęściej bywały
          to konie trojańskie, ale też słyszało się o wirusach, czy
          innych bardziej niechcianych programach. Najczęstszymi czynnościami
          wykonywanymi przez złośliwe oprogramowanie są:
        </p>
        <ul>
          <li>Różnego rodzaju modyfikacje plików, wraz z ich usunięciem.</li>
          <li>Zaburzenie uruchamiania systemu operacyjnego lub uszkodzenie
            aplikacji.</li>
          <li>Przekazywanie poufnych informacji do podmiotów zagrożeń.</li>
          <li>Uzyskanie dostępu do poczty elektronicznej i wykorzystanie jej
            do rozprzestrzeniania sie.</li>
          <li>Oczekiwać na sygnały od podmiotów zagrożenia.</li>
        </ul>
        <p>
          Wirusy do rozprzestrzeniania się wymagają działalności człowieka, my
          natomiast możemy określić kilka ich rodzajów:
        </p>
        <ul>
          <li><strong>Wirus sektora rozruchowego</strong> - wirus atakujący
            sektor rozruchowy, tablicę partycji lub system plików.</li>
          <li><strong>Wirus oprogramowania układowego</strong> - wirus atakuje
            oprogramowanie układowe urządzenia.</li>
          <li><strong>Wirus makr</strong> - wirusy złośliwe wykorzystujące
            funkcję makr w MS Office czy w innych aplikacja.</li>
          <li><strong>Wirus programu</strong> - wirus wstawia się w inny
            program wykonywalny.</li>
          <li><strong>Wirus skryptu</strong> - wirus atakuje interpreter
            poleceń systemu operacyjnego, wykorzystywany do wykonywania
            skryptów.</li>
        </ul>
        <p>
          Innym ciekawym rodzaje złośliwego oprogramowania, wspominanego już
          w tym temacie, jest <strong>koń trojański</strong>, przypomina on
          przydatny program, jednak jego funkcje są rozszerzone o potencjalnie
          niebezpieczne dla nas działanie, takie jak np.: umożliwienie zdalnego
          dostępu, przekazywanie danych, destrukcję plików, uruchomienie
          <em>proxy</em> (przekaźnika) - pozwalającego na wykorzystanie
          połączenia komputera do innych celów; uruchomienie serwera FTP - w
          celu kradzieży plików, dezaktywacja oprogramowania antywirusowego -
          w celu przeprowadzenia dalszej mniej wyrafinowanej infekcji;
          przeprowadzanie z naszego komputera ataków odmowy usług - DoS oraz
          zbieranie i przesyłanie uderzeń w klawiaturę - keylogging.
        </p>
        <p>
          Innymi rodzajami złośliwego oprogramowania są:
        </p>
        <ul>
          <li><strong>Adware</strong> - oprogramowanie wyświetlające na często
            nachalne reklamy, najczęscięj treści tylko dla dorosłych.</li>
          <li><strong>Ransomware</strong> - złośliwe oprogramowanie szyfrujące
            dyski i żądające okupu za wydanie klucza deszfrującego.</li>
          <li><strong>Rootkit</strong> - oprogramowanie stosowane przez
            podmioty zagrożeń w celu uzyskania dostępu do konta administratora
            systemu.</li>
          <li><strong>Spyware</strong> - oprogramowanie szpiegowskie,
            wykorzystywane w celu uzyskania osobistych informacji o
            użytkowniku.</li>
          <li><strong>Robak</strong> - samoreplikujący się program 
            wykorzystujący przy tym podatności. Najcześciej wykorzystuje on
            sieć do wyszukiwania systemów z tą samą podatnościa.</strong>.
        </ul>
        <h2 id="3.3.5.networkattacks">3.3.5. Ataki sieciowe</h2>
        <p>
          Ataki sieciowe, które mają stricte nie wiele wspólnego z siecią
          poza tym sieć jest medium przesyły informacji, mniej jednak możemy
          wróżnić takie ataki jak: ataki rozpoznania, ataki dostępu, czy ataki
          DoS.
        </p>
        <p>
          Ataki rozpoznania zwykle polegają na poszukiwaniu hostów w sieci z
          wybraną przez nas podatnością, lub przeskanowaniem hostów w sieci 
          pod kątem występowania podatności w ogóle i w zależności od tego
          co zostanie znalezione, to może to zostać wykorzystane. Tego typu
          atak możemy podzielić na:
        </p>
        <ol>
          <li><strong>zapytanie informacyjne dotyczące celu</strong> -
            popularnym narzędziem na tym etapie są wyszukiwarki czy baza
            WHOIS (zawierająca informacje o domenie, czy przypisanej
            adresacji IP)</li>
          <li><strong>wykrywanie aktywnych/osiągalnych hostów w sieci</strong>
            - w tej fazie czasami może wystarczyć zwykłe polecenie
            <em>ping</em>, szczególności jeśli działamy z sieci wewnętrznej.</li>
          <li><strong>skanowanie portów osiąglanych hostów</strong> - kiedy
            już wiemy co możemy atakować, to wówczas musimy dowiedzieć się co 
            jest na tych hostach uruchomione. Do tego mogą posłużyć nam skanery
            portów takie jak np. Nmap. Chciaż część skanerów podatności posiada
            również funkcję skanowania portów.</li>
          <li><strong>skanowanie podatności</strong> - następną częścią jest
            wykrycie dziur w oprogramowaniu, z którym możemy się polączyć.
            Takim skanerem podatności jest np. Nessus.</li>
          <li><strong>wykorzystanie podatności</strong> - po znalezieniu
            podatności pozostaje nam dobrać dla niej odpowiedni
            <em>exploit</em>, aby uzyskać zdalny dostęp do systemu. Takim
            narzędziem jest <strong>Metasploit</strong>.</li>
        </ul>
        <p>
          Ataki dostępu służą wykorzystaniu podatności w funkcjach 
          uwierzytelniania w celu uzyskania dostępu do kont czy to na portalach
          internetowych czy to do zasobów plikowych. Jednym z najcześciej
          stosowanych ataków jest <strong>atak na hasło</strong> stosowany
          w celu poznania krytycznych dla systemów haseł, tego rodzaju ataków
          dokonuje się poprzez programy do łamania haseł. Innym rodzajem
          ataków dostępu są ataki fałszowania, przeprowadzane w celu
          podszycia pod inne urządzenie i pozostania jak najdłużej
          niezauważonym, do tego rodzaju ataków możemy przypisać dobrze znane
          nam <em>man-in-the-middle</em>, wykorzystanie zaufania,
          przekierowanie portów czy przepełnienie bufora.
        </p>
        <p>
          Przeprowadzenie ataków na hasła jest czaschonne i często nie
          przynosi skutków. Obecnie często nie ma sensu się tym zajmować
          przejmować ponieważ to często użytkownicy podają swoje dane logowania
          jak na tacy. Atakujący zazawyczaj posługują się wówczas
          <strong>socjotechnikami</strong> - są techniki manipulacyjne
          pozwalające na wprowadzenie, kogoś w błąd, aby móc wyłudzić od niego
          poufne informacje.
        </p>
        <p>
          Jednym z takich metod jest <strong>phising</strong> - najprościej
          rzecz ujmując próba wyłudzenia informacji, po przez podanie
          fałszywego linku, z identyczną stroną logowania do jednego z
          serwisów. Strona tego typu różni się drobnymi szczególami, na które
          na codzień nie zwracamy uwagi, np. literówką w adresie strony. Ta
          strona moze kolekcjonować wpisane dane i przekazać je podmiotowi
          zagrożenia. Dlatego trzeb mieć się na baczności i zastanowić się
          dwa razy klikając w link dodany do dziwnej wiadomości e-mail.
          Ciekawym narzędziem w tym przypadu jest SET
          <em>Social-Engineering Toolkit</em>, pozwalający na przygotowanie
          ataków <em>phishingowych</em> w celu przetestowania własnych
          użytkowników.
        </p>
        <p>
          Ataki <strong>DoS</strong>, inaczej ataki odmowy usługi polegają one
          na zalaniu
          serwera żądaniami dostępu do zasobu o bardzo dużej częstotliwości.
          Ten atak ma na celu pozbawienie dostępu do usługi prawowitym
          użytkownikom. Takie ataki są dość trudne w zapobieganiu, ponieważ
          w jaki sposób oddzielić taki atak od wzmożonej aktywności 
          użytkowników?
          Tego typu ataki są często wykorzystywane przez haktywistów,
          manifestując tym samym społeczne nieposłuszeństwo. Takie ataki są
          rownież banalne do przeprowadzenia, ponieważ sposób ich
          przeprowadzania nie skupia się na jakości a na ilości, najcześciej
          standardowych żądań. Jeśli taki atak pochodzi z jednego adresu IP,
          to wówczas mamy doczynienia z atakiem DoS, ale jeśli zapytania
          przychodzą z różnych hostów to mówimy o wersji rozproszonej -
          <strong>DDoS</strong>.
        </p>
        <h2 id="3.3.6.vulnerabiltiesandthreadsofip">3.3.6. Podatności i zagrożenia IP</h2>
        <p>
          Obecnie stosowane protokoły sieciowe nie były konstruowane z myślą
          o bezpieczeństwie, ponieważ wówczas bardziej kładziono nacisk na
          swobodę komunikacji. Dlatego też w protokołach IP możemy dowolnie
          manipulować polami nagłówków pakietów. Do najbardziej powszechnych
          ataków związanych z adresami IP możemy wymienić:
        </p>
        <ul>
          <li><strong>Ataki ICMP</strong> - podmiot zagrożeń może wykorzystać
            komunikaty protokołu ICMP, takie jak <em>echo</em> do odkrywania
            hostów, ataków DoS, czy innych komunikatów np. do wpływania na
            routing hostów.</li>
          <li><strong>Ataki wzmacniania i odbijania</strong> - rodzaj ataku
            DoS, polegający na wysłaniu żądań echa z tym samym adresem
            źródłowym do wielu hostów. Wówczas zapytane hosty odpowiedzą
            atakowanemu hostowi zalewając go odpowiedziami echo.</li>
          <li><strong>Ataki fałszowania</strong> - ataki pozwlajace fałszować
            informacje zawarte w nagłówkach przez co podmiot zagrożeń może
            podawać się za uprawnionego użytkownika. Nieślepe ataki fałszowania
            pozwalają ustalenia stanu zapory sieciowej oraz ustalenie 
            numerów skewencyjnych przez co możliwe jest przechwycenie sesji.</li>
          <li><strong>Ataki typu man-in-the-middle</strong> - Podmiot
            zagrożeń może umieścić się w komunikacji między źródłem a celem i 
            transparentnie monitorować, przechwytywać i kontrolować 
            komunikację. Może on sprawdzać pakiety, zmieniać ich zwartość i
            przekazywać dalej do celu.</li>
          <li><strong>Przechwytywanie sesji</strong> - Podmiot zagrożenia
            uzyskuje dostęp do sieci fizycznej, następnie dokonuje ataku
            <em>man-in-the-middle</em> w celu przechwycenia sesji.</li>
        </ul>
        <h2 id="3.3.7.tcpanudpvulnerabilities">3.3.7. Podatności TCP i UDP</h2>
        <p>
          Podaności protokołów warstwy czwartej polegają na daniu możliwości
          zalania wybranego serwera - w przypadku protokołu TCP pakietami
          z ustawionym bitem kontrolnym SYN, lub datagramami w przypadku
          protokołu UDP. Wówczas jest taki komputer nie jest wstanie
          przetwarzać żądań uprawnionych do korzystania z niego, użytkowników.
          W przypadku protokołu TCP, dość kłopotliwe mogą być inne flagi czy 
          też bity kontrolne, za pomocą pakietu z ustawionym bitem kontrolnym
          <em>Fin</em> oraz sfałszowanym adresem źródłowym możemy zresetować
          lub zakończyć połaczenie TCP, co może zaburzać zwykłym uzytkownikom
          korzystanie z usług. Innym rodzajem ataku opartego na TCP jest
          przjęcie sesji TCP, poprzez zdobycie pakietu źródłowego oraz
          odgadnięcie numeru sekewencji. UDP można wykorzystać podbnie jak
          TCP do zalewania hostów. Ze w zględu, że UDP nie ustala żadnego
          połączenia, serwer może podejść do sprawy w dwojaki sposób albo
          zignorować albo wysłać odpowiedź o nieosiągalnym porcie przez
          protokoł ICMP.
        </p>
        <h2 id="3.3.8.ipservices">3.3.8. Usługi IP</h2>
        <p>
          Pierwszą usługą, która jest związana z IP i może powodować przykre
          skutki, jeśli zostanie wykorzystana w niecnym celu jest
          protokół <strong>ARP</strong>. Dzięki zatruwaniu ARP, podmiot 
          zagrożenia może fałszować odwzrowania adresów IP na adresy MAC,
          co pozwoli na przkierowanie ruchu np. przez swój komputer, co daje
          nam <em>man-in-the-middle</em>. Co najciekawsze, protokół ARP
          przewiduje tzw. <strong>pakiet gratisowy</strong>, który wręcz
          wymusza aktualizację wpisu pamięci podręcznej ARP hosta.
          Do narzędzi pozwalających na tego typu ataki możemy zaliczyć takie
          programy jak <em>dsnif</em>, <em>Cain&Abel</em> czy <em>ettercap</em>.
        </p>
        <p>
          System DNS pozwala nam na posługiwanie się w Internecie przyjaznymi
          nazwami, dzięki czemu wpisujemy <em>morketsmerke.org</em> a nie
          adresy IP. System DNS jest bardzo ważną częścią obecnych sieci, a
          bywa zaniedbany jeśli chodzi o funkcje bezpieczeństwa. Ataki na DNS,
          lub te z jego wykryciem, możemy podzielić na kilka kategorii.
        </p>
        <ul>
          <li><strong>Ataki na DNS typu open resolver</strong> - są w głównej
            mierze ataki DoS, takie jak: atak wzmacniania i odbijania lub
            atak wykorzystania zasobów DNS. Innym rodzajem ataku bo atakiem
            fałszowania jest atak zatrucia pamięci podręcznej, po którego
            nazwie możemy wywnioskować co robi i jaki będzie jego skutek.</li>
          <li><strong>Ataki z ukrycia DNS</strong> - te ataki polegają 
            szybkim manipulowaniu adresami IP DNS, aby ukryć strony
            wyłudzające informacje oraz roznoszące złośliwie oprogramowanie
            takimi atakami jest <em>FastFlux</em> oraz
            <em>Double FastFlux</em>. Działającym na innej zasadzie atakiem
            tego typu jest algorytm generowania domen, które potem stają
            się domem dla hostów kontrolujacyh botnety.</li>
          <li><strong>Cieniowanie domeny DNS</strong> - jest technika 
            polegającą uzyskaniu dostępu do konfiguracji domeny i utworzenie
            wielu subdomen, które mogą posłużyć poźniej do ataku.</li>
          <li><strong>Tunelowanie DNS</strong> - technika pozwalająca na 
            zawarcie jednego ruchu DNS wewnątrz drugiego, pozwala to na
            kradzież informacji lub komunikację z hostami botnetu wewnątrz
            chronionej sieci.</li> 
        </ul>
        <p>
          Ostatnim rodzajem usług IP jakie mogą być podatne na ataki jest
          serwer DHCP. Są to albo ataki DoS w postaci 
          <strong>zagłodzenia</strong>, lub <strong>fałszowania</strong>, gdzie
          do manipulacji wykorzystuje się takie parametry jak sam adres IP,
          żeby pozbawić użytkownika dostępu do sieci lub
          adres bramy oraz adresy serwerów DNS, aby przekierować ruch.
        </p>
        <h3 id="3.3.8.lab">Laboratorium</h3>
        <p>
          <a href="">Eksploracja ruchu DNS</a>
        </p>
        <h2 id="3.3.9.bestpracticeofnetworksec">3.3.9. Najlepsze praktyki bezpieczeństwa sieci</h2>
        <p>
          Chcąc dobrze zabezpieczyć naszą sieć musimy poznać nie tyle techniki
          jak się bronić prze konkretnymi atakami, ale musimy wypracować w nas
          czy użytkownikach naszej sieci pewne schematy działania, aby zapobiec
          powstawaniu głupich błędów. Trzeba sobie również uświadomić jedną
          rzeczy, że przed nie którymi atakami nie będzie możliwa ochrona, 
          u innych
          uda nam się zminimalizować skutek wykorzystania podaności, a przed nie
          którymi nie uda nam się zabezpieczyć w ogóle. Ten temat jest
          poświęcony zapoznaniu się dobrymi przedsięwzięciami w celu ochrony
          naszej sieci. 
        </p>
        <p>
          W wielu organiazacjach stosuje się takie podejście do bezpieczeństwa
          jaką jest <strong>triada PID</strong> lub <em>trójkąt CIA</em>. Ta
          koncepcja składa się z trzech pojęć:
        </p>
        <ul>
          <li><strong>Poufności</strong> - tylko upoważniony personel oraz
            procesy może mieć dostęp do poufnych informacji. Może być tutaj
            wymagane stosowanie silnego szyfrowania.</li>
          <li><strong>Integralność</strong> - jest ochrona danych przed
            nieautoryzowanymi zmianami. Do tego wykorzystuje się różne 
            kryptograficzne funkcje skrótu.</li>
          <li><strong>Dostępność</strong> - jest zapewnienie nie przerwanego
            dostępu do ważnych zasobów przez uprzywilejowany personel. W tym
            celu będą potrzebne np. łącza, bramy oraz usługi nadmiarowe.</li>
        </ul>
        <p>
          Inną praktyką jest <strong>dogłebne podejście do ochrony</strong>.
          Polega ono na podziale infrastruktury na warstwy, przy wykorzystaniu
          wielu urządzeń współpracujących między sobą, między innymi: tuneli
          VPN, inteligentych zapór sieciowych, systemów zapobiegania/wykrywania
          włamań, filtrów treści oraz systemów uwierzytelniania. Część z tych
          rozwiązań będzie fizycznymi urządzeniami, a część z nich usługami
          gdzieś na serwerach, należy wówczas pamiętać aby dołożyć wszelkich
          starać aby zabezpieczyć te komponenty, to samo tyczy się transmisji
          danych.
        </p>
        <p>
          <strong>Zapory sieciowy</strong> to podstawowy mechanizm obronny,
          zaporę najczęściej
          ustawia się w punkcie styku sieci. Chroni ona hosty sieci lokalnej
          przed zagrożeniami z zewnątrz. Ważna jest dobra konfiguracja zapory,
          przeciwnym wypadku może być ona jednym wielki punktem awarii.
          Zapora odfiltrowuje na podstawie zestawu reguł nieporządany ruch,
          dopuszczając tylko ten potencjalnie bezpieczny. Jednak nie jest to
          rozwiązanie bez wad. Techniki tunelowania oraz inne metody ukrywające
          potrafią oszukać zaporę.
        </p>
        <p>
          Technologie <strong>IDS/IPS</strong> są wyposażone w sensory, które
          na podstawie wzorców (sygnatur), potrafią wyłapywać typowe ataki
          sieciowe i gromadzić na ich temat informacje, które są potem
          przekazywane do administratora. Sygnaturą może być
          nawet pojedynczy pakiet lub niewieki fragment ich strumienia.
        </p>
        <p>
          <strong>Filtry treści</strong>, możemy podzielić np. na podstawie
          protokółów są filtry zająmujące się samą pocztą elektroniczą i będące
          przekaźnikiem wiadmości i przy okazji skanującym je podkątem
          zagrożenia i ewentualnego odrzucenia. Firma Cisco posiada takie
          rozwiązanie i nazywa się ESA. Innym rodzajem filtru jest filtrowanie
          stron internetowych, ale i nie tylko bo za pomocą rozwiązań tego typu
          możemy decydować do czego użytkownik może mieć dostęp w Internecie w
          czasie pracy. Możemy tworzyć listy stron zablokowanych, filtrować
          ruch aplikacji internetowych, a nawet zaglądać do transmisji
          szyfrowanych, rozwiązaniem tego typu Cisco jest - WSA.
        </p>
        <h2 id="3.3.10.cryptography">3.3.10. Kryptografia</h2>
        <p>
          Wykorzystując standardowe wersje protokołów sieciowych, treść ich
          komunikatów jest przesyłana w sposób <strong>jawny</strong>. Pozwala
          on bezproblemowe odczytanie ich treści. W sieci zaufanej nie stanowi
          to bowiem problemu, gorzej jest w przypadku kiedy trzeba informacje
          poza nią. Dawniej nikt nie przykładał do tego zbytniej uwagi, jednak
          czasy się zmieniły i już na pewno wiemy, że nie możemy ufać nikomu
          po drugiej stronie routera lub zapory i w przypadku komunikacji
          sieciowej możemy skorzystać z bezpiecznych wersji protokołów
          (szyfrowanych) lub z samych elementów kryptografii, zabezpieczejąc
          transmisje protokołu nie posiadającego bezpieczenej wersji przy
          użyciu dodatkowego tunelu.
        </p>
        <p>
          W celu zabezpieczenie komunikacji wymagane są cztery elementy takie
          jak:
        </p>
        <ul>
          <li><strong>Integralność danych</strong> - gwarantuje, że komunikat
            nie został zmieniony, zapewniają to algorytmy skrótów MD5 oraz SHA.
          </li>
          <li><strong>Uwierzytleniania pochodzenia</strong> - gwarantuje, że
            wiadomość pochodzi z zaufanego i legalnego źródła, zapewnia to 
            protokół HMAC.</li>
          <li><strong>Poufność danych</strong> - gwarancja, że przesyłane
            informacje nie zostaną przez nikogo odczytane. Zapewniają to
            algorytmy szyfrowania asymentrycznego i symetrycznego.</li>
          <li><strong>Niezaprzeczalność danych</strong> - gwarancja, że
            nadawca nie będzie mógł odrzucić lub zaprzeczyć wysłanej wiadomosci.
            Nadawca ma unikalne cechy, określające sposób traktowania
            takiej wiadomości.</li>
        </ul>
        <p>
          Sprawdzenie integralności danych, polega obliczeniu tzw. skrótu z
          podanej wiadomości przez obie strony komunikacji. Jeśli skrót jest
          taki sam po obu stronach ozaczna to tyle, że nie doszło do żadnej
          ingerencji z zewnątrz w wiadomość. Do obliczania skrótów używa się
          specjalnych <strong>funkcji skrótu</strong>.
        </p>
        <p>
          Obecnie w kryptografi stosowane są trzy funkcje skrótu:
        </p>
        <ul>
          <li><strong>MD5 z 128-bitowym odciskiem</strong> - jest to funkcja
            jednokierunkowa generująca 128-bitowy komunikat. Obecnie MD5 jest
            wykorzystywane tylko tam gdzie jest to konieczne, ponieważ istnieją
            lepsze alternatywy.</li>
          <li><strong>Algorytm SHA-1</strong> - algorytm ten jest uznawany za
            przestarzały i posiada znane wady. Generuje 160 bitowy komunikat.
            Obecnie jest zastępowany przez generację funkcji sktóru SHA-2.</li>
          <li><strong>SHA-2</strong> - obejmuje kilka algorytmów takich jak
            np. SHA-256 czy SHA-512. Te algorytm to standard i powinny być
            stosowane jeśli tylko są dostępne.</li>
        </ul>
        <p>
          Funkcje skrótu są w stanie ochronić nas przed przypadkowymi zmianami,
          ale nie jeśli zmiany są celowe, wówczas podmiot zagrożeń może
          wygenerować nowy skrót dla zmienionych pakietów i przedstawić go jako
          skrót nadawcy.
        </p>
        <p>
          Wyżej wymieniona wada była dość dużym problemem, z którym poradzono
          sobie dodając uwierzytelnienie do zapewnienia integralności za pomocą
          <strong>protokołu HMAC</strong>. Działanie tego algorytmu opera się
          uzupełenienie
          danych wejściowch do funkcji skrótu, o znanym przez strony tajny
          klucz. Wówczas atakujący nie będzie mógł ingerować w komunikację,
          ponieważ jego skróty generowane funkcję nie bedą posiadać znanego
          klucza i przy sprawdzaniu takie dane zostaną odrzucone.
        </p>
        <p>
          Wyżej wymienione metody zapewniają integralność czy wiarygodność
          przesyłanych komunikatów, ale ich treść jest nadal dostęna dla osób
          postronnych. Kryptografia zapewnia nam dwa rodzaje szyfrowania. 
        </p>
        <p>
          <strong>Szyfrowanie symetryczne</strong> - algorytmy wykorzystujące
          ten sam klucz do szyfrowania i odszyfrowywania informacji, klucze są
          krótkie zazwyczaj mają długość od 40 do 256-bitów. Algorytmy te
          są szybsze od algorytmów szyfrowania asymetrycznego. Szyfrowanie tego
          rodzaju służy do zabezpieczenia masowych danych takich jak tunele
          VPN. Do tego rodzaju szyfrowania możemy przypisać takie algorymy jak:
          <strong>DES, 3DES, AES, SEAL, RC</strong>. 
        </p>
        <p>
          <strong>Szyfrowanie asymetryczne</strong> - algorytmy wykorzystują
          różne klucze do szyfrowania i deszyfrowania wiadomości. Klucze są
          długie od 512 do 4096-bitów. Przez długie klucze wydłuża sie sam
          proces szyfrowania, przez co te algorymy są wolniejsze. Służą do
          zabezpieczenia szybkich pojednycznych transakcji danych, takich jak
          połączenia HTTPS. Do tego rodzaju szyfrowania, możemy przypisać
          takie algorytmy jak: <strong>DH, DSS i DSA, RSA, EiGamal, Techniki
          krzywej eliptycznej</strong>.
        </p>
        <p>
          Techniki szyfrowania są powszechne wśród bezpieczenych protokołów,
          nie które z nich wykorzystują jeden lub drugi rodzaj, nie które
          oba, wykorzystując jednen do jednej czynności drugi do kolejnej.
          Takimi protokołami są: IKE (podstawowy składnik sieci IPSec VPN),
          TLS (standard bezpieczeństwa komunikacji w sieciach), SSH czy PGP
          (zapewniające prywatną i poufną korespodencję elektroniczną z
          wykorzystaniem technik kryptografi).
        </p>
        <p>
          Ciekawym algorymem kryptograficznym jest algorytm 
          <strong>Diffie-Hellman</strong>, którego działanie opiera się na
          wygenerowaniu tego samego tajnego klucza po przez wymianę tak
          szczątkowych informacji, że nie które źródła podają że hosty ze sobą
          w ogóle się nie komunikują. Klucze tego algorytmu stosowane są
          przez IPSec (rodzaj sieci VPN), TLS czy wymianie danych SSH.
          Powszechną praktyką jest stosowanie algorytmu DH 
          (<em>Diffie-Hellman</em>), do generowania klucza współdzielonego
          algorytmów symetrycznych jak 3DES czy AES.
        </p>
        <h2 id="3.3.summary">Podsumowanie</h2>
        <p>
          Ten rodział przedstawił nam kompleksową wiedzę na temat zagrożeń
          bezpieczeństwa sieciowego, poznaliśmy rodzaje hakerów, ich narzędzia,
          rodzje złośliwego oprogramowania, typowe ataki sieciowe. 
          Podatności protokołów sieciowych IP, TCP i UDP czy usług IP.
          Na koniec poznaliśmy najlepsze praktyki bezpieczeństwa oraz podstawy
          kryptografii.
        </p>
        <h1 id="3.4.aclconcepts">3.4. Koncepcje ACL</h1>
        <p>
          <strong>ACL</strong>, czyli listy kontroli dostępu do seria poleceń
          IOS służąca do filtrowania ruchu. Filtrowanie ruchu odbywa się
          na podobnej zasadzie do routingu. Informacje z nagłówków są
          konfrontowane z kryteriami reguł ACL i na podstawie najlepszego
          dopasowania, ruch może zostać albo przepuszczony dalej albo
          zablokowany. Listy składają się z sekwencyjnych instrukcji zezwolenia
          albo odmowy te reguły są nazywane ACE - wpisami listy kontroli.
        </p>
        <p>
          Poniżej znajduje się lista zadań, które mogą zostać wykonane za
          pomocą ACL:
        </p>
        <ul>
          <li>Ogranicznie ruchu w celu zwiększenia wydajności sieci.</li>
          <li>Zapewnienie kontroli przepływu.</li>
          <li>Zapewnienie podstawowych zabezpieczeń podczas dostępu do sieci.</li>
          <li>Filtrowanie ruchu w oparciu o typ ruchu.</li>
          <li>Kontrolowanie hostów aby zezwolić lub zablokować dostęp do sieci.</li>
          <li>Zapewnienie priorytetu określonym klasom ruchu sieciowego.</li>
        </ul>
        <p>
          Filtrowanie pakietów może wystąpić w warstwie 3 lub w 4, w zalezności
          od zastosowanych przez nas list kontroli dostępu. Routery Cisco
          obsługują dwa rodzaje list ACL:
        </p>
        <ul>
          <li><strong>Standardowe ACL</strong> - ACL filtruje tylko w warstwie
            3, na podstawie adresu źródłowego.</li>
          <li><strong>Rozszerzone ACL</strong> - ACL może filtrować w warstwie
            3 lub 4 na podstawie adresu źródłowego lub docelowego, protokołu,
            czy numeru portu.</li>
        </ul>
        <p>
          Dla ACL ważny jest również kierunek przesyłanie pakietu. Każdy
          interfejs mimo, że transmisja odbywa się w dwóch kierunkach naraz
          to możemy określić czy dana transmisja pakietów opuszcza interfejs
          lub przez niego wchodzi. I to niezależnie od sieci, bowiem każdy
          z interfejsów przesyła ruch w obu kierunkach, a my możemy nałożyć
          po jednej z list każdy z kierunków.
        </p>
        <p>
          Listy muszą mieć chociaż jedną wpis zezwolenia, w przeciwnym razie
          wszelki ruch zostanie odrzucony z powoduje niejawnego wpisu
          odrzucania całego ruchu. Każda z list posiada taką niejawną regułę.
        </p>
        <h3 id="3.4.1.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/4.1.4-packet-tracer---acl-demonstration_pl-PL.pdf">Demonstracja działania listy ACL - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/4.1.4-packet-tracer---acl-demonstration_pl-PL.pka">Demonstracja działania listy ACL - zadanie</a>
        </p>
        <h2 id="3.4.2.wildcardmaskinacls">3.4.2. Maska blankietowa w listach ACL</h2>
        <p>
          ACL używają w regułach masek blankietowych. Obliczanie tych masek
          poznaliśmy w przypadku omawiania OSPF-a. Dla przypomnienia aby
          tworzyć maskę blankietową, musimy odjąć od maski /32 bitowej maskę
          podsieci w postaciach dziesiętnych. W przypadku maski blankietowej,
          0 oznaczają zgodność a 1 ignorowanie.
        </p>
        <p>
          ACL-ki wprowadzają dwa słowa kluczowe dla konkretynych wartości masek
          blankietowych:
        </p>
        <ul>
          <li><strong>any</strong> - 255.255.255.255</li>
          <li><strong>host</strong> - 0.0.0.0. Przyczym słowo
            <em>host</em> zapisujemy przez adresem IP hosta.</li>
        </ul>
        <p>
          Możemy również tworzyć maski blankietowe dla zakresów IP, jeśli
          chcemy aby jeden wpis obejmował kilka sieci. to wówczas możemy 
          utworzyć taki o to wpis w ACL:
        </p>
<pre class="code-block">
access-list 10 permit 192.168.16.0 0.0.15.255
</pre>
        <p>
          Ten wpis spowoduje zezwolenie na ruch z adresów 192.168.16.0 do
          192.168.31.0.
        </p>
        <h2 id="3.4.2.instructionsforcreatingacls">3.4.2. Wytyczne do tworzenia ACL</h2>
        <p>
          Do interfejsu możemy przypisać określoną liczbę ACL, są to dwie listy
          dla każdego protokołu - IPv4 i IPv6, dla ruchu przychodzącego i
          wychodzącego.
        </p>
        <p>
          Podczas implementacji ACL w sieci musimy wykazać się sporą
          starannością, ponieważ błędy w listach mogą doprowadzić do przestojów
          w łączności. Poniżej znajdują się zasady jakimi należy kierować się.
        </p>
        <ul>
          <li>Opierać listy ACL na zasadach bezpieczeństwa organizacji.</li>
          <li>Określić co ma robić konkretna lista ACL.</li>
          <li>Użyć edytora tekstu, aby tworzyć, edytować i zapisywać wszystkie
            listy ACL.</li>
          <li>Dokumentować listy ACL za pomocą polecenia
            <strong>remark</strong>.</li>
          <li>Testować listy w sieci testowej przed zastosowaniem jest w sieci
            produkcyjnej.</li>
        </ul>
        <h2 id="3.4.3.typeofacls">3.4.3. Typy list ACL IPv4</h2>
        <p>
          Routery Cisco obsługują dwa rodzaje ACL-ek:
        </p>
        <ul>
          <li><strong>Standardowe ACL</strong> - ich kryteria dopasowania
            dotyczną jedynie adresów źródłowych (działają w warstwie 3).</li>
          <li><strong>Rozszerzone ACL</strong> - działają w warstwie 4, w
            jednej regule możemy zapisać do 5 warunków: protokoł 
            (najczęściej TCP lub UDP),
            adres, port - źródłowy, adres, port - docelowy.</li>
        </ul>
        <p>
          Listę standardową możemy utworzyć na przykład za pomocą poniższego
          polecenia:
        </p>
<pre class="code-block">
access-list 10 permit 192.168.10.0 0.0.0.255
</pre>
        <p>
          Standardowa ACL, filtruje wyłącznie po adresie źródłowym, tym samym
          dopuszczając całą sieć 192.168.10.0.
          Rozszerzoną ACL możemy utworzyć na przykład za pomocą
          poniższego polecenia:
        </p>
<pre class="code-block">
access-list 100 permit tcp 192.168.10.0 0.0.0.255 any eq www
</pre>
        <p>
          Rozszerzona ACL, może znacznie bardziej kształtować ruch, w przypadku
          wyżej wymienionej list, to zezwala ona wyłącznie na ruch HTTP dla
          sieci 192.168.10.0/24.
        </p>
        <p>
          ACL mogą być <strong>numerowane</strong>, tak jak to było w 
          powyższym przypadku. Tutaj
          musimy wiedzieć jedną rzecz - z ACL numerowanymi wiąża się zakresy
          numerów jakie możemym nadać listom, tym samym deklarując ich typ. 
          <strong>Listy
          standardowe mają numery od 1 do 99 oraz od 1300 do 1944</strong>.
          Natomiast <strong>Listy rozszerzone mają numery od 100 do 199 oraz
          od 2000 do 2699</strong>.
        </p>
        <p>
          Inną opcją są listy <strong>nazwane</strong>, ich tworzenie
          przypomina trochę zakładanie puli DHCP. Na początku wydajemy
          polecenie z rodzajem oraz nazwą listy, i następnie w trybie
          konfiguracji listy podajemy kolejne wpisy.
        </p>
        <p>
          Czynnikiem dość istotnym podczas wdrażania ACL-ek jest określenie
          miejesca gdzie należy je umieścić. Generalnie posługujemy się zasadą,
          że ACL-ki umiescza w miejscach gdzie będą one miały najwiekszy wpływ
          na wydajność i wobec tego istnieją dwie reguły oparte o rodzaj
          ACL-ek: 
        </p>
        <ul>
          <li><strong>ACL standardowe</strong> - umieszczamy jak
            <strong>najbliżej celu</strong>.</li>
          <li><strong>ACL rozszerzone</strong> - umieszczamy jak
            <strong>najbliżej źródła</strong>.</li>
        </ul>
        <p>
          Najlepiej obrazuje to blokowanie, ponieważ ruch który ma niedocierać
          jest już wycinany na pierwszym routerze. Z kolei jeśli już stosujemy
          standardowe ACL-ki, to warto wykorzystać je do dopuszczenia ruchu
          z zaufanych sieci, na końcu każdej listy znajduje się nie jawna
          reguła, która zablokuje pozostały ruch.
        </p>
        <h2 id="3.4.summary">Podsumowanie</h2>
        <p>
          W tym rodziale dowiedzliśmy się w jaki sposób kształtować ruch za
          pomocą ACL. Poznaliśmy czym są listy dostępowe, ich rodzaje oraz
          dobre praktyki podczas ich tworzenia przypomnieliśmy sobie również
          w jaki sposób oblicza się maski blankietowe.
        </p>
        <h1 id="3.5.configurationacllistforipv4">3.5. Konfiguracja list ACL dla IPv4</h1>
        <p>
          W poprzednim rodziale dowiedzieliśmy się czym są ACL-ki i w jaki
          sposób możemy wykorzystać je do kształtowania ruchu. Poznaliśmy
          również podstawowe polecenia, ale bez ich omawiania. Ten rozdział
          przedstawi nam w jaki sposób tworzyć oraz modyfikować, standardowe i
          rozszerzone listy ACL oraz dodatkowo jak wykorzystać ACL do kontroli
          zdalnego dostępu do urządzeń.
        </p>
        <h2 id="3.5.1.configurestdaclforipv4">3.5.1. Konfiguracja standardowych ACL dla IPv4</h2>
        <p>
          Tworzenie ACL najlepiej rozpocząć od zapisania w edytorze tekstu
          specyfiki polityki bezpieczeństwa organizacji, następnie musimy
          przełożyć te zasady na polecenia IOS, w tym momencie warto dołączać
          komentarze. Kiedy nasza lista jest hipotetycznie gotowa, możemy ją
          skopiować do środowiska testowego - może to być PT lub fizyczne
          urządzenia.
        </p>
        <p>
          Chcąc utworzyć standardową numerowaną listę ACL w konfiguracji
          globalnej wydajemy następujące polecenie:
        </p>
<pre class="code-block">
Router(config)# access-list access-list-number {deny | permit | remark text}
source [source-wildcard] [log]
</pre>
        <p>
          Jeśli będziemy chcieli usunąć listę użyjemy polecenia:
          <code class="code-inline">no access-list access-list-number</code>
        </p>
        <p>
          Poszczególne elementy składni polecenia tworzenia standardowych
          numerycznych ACL znajduje się poniżej:
        </p>
        <ul>
          <li><code class="code-inline">access-list-number</code> - numer listy
            ACL, dla standardowych list jest od 1 do 99 lub 1300 do 1999.</li>
          <li><code class="code-inline">deny</code> - odmowa dostępu, jeśli
            warunek został spełniony.</li>
          <li><code class="code-inline">permit</code> - udzielenie dostępu,
            jeśli warunek został spełniony.</li>
          <li><code class="code-inline">remark <em>text</em></code> - 
            opcjonalny komentarz dla celów dokumentacji. Długość komentarza
            jest ograniczona do 100 znaków.</li>
          <li><code class="code-inline">source</code> - określa adres sieci
            hosta źródłowego do filtrowania. Tutaj możemy posłużyć się, słowem
            kluczowym <em>any</em>, aby określić wszystkie sieci oraz słowem
            kluczowym <em>host ip-address</em> lub poprostu <em>ip-address</em>,
            aby zidentyfikować konkretny adres IP.</li>
          <li><code class="code-inline">source-wildcard</code> - opcjonalna
            32-bitowa maska blankietowa stosowana dla adresów źródłowych. Jeśli
            zostanie pominięta, zakłada się domyślną maskę 0.0.0.0.</li>
          <li><code class="code-inline">log</code> - opcjonalne słowo kluczowe
            generujące i wysłające komunikat gdy ACE (wpis w ACL) zostanie
            dopasowany. Wysyłany komunikat zawiera numer ACL, dopasowany
            warunek (<em>permit</em> or <em>deny</em>), adres źródłowy oraz
            liczbę pakietów. Komunikat generowany jest dla pierwszego
            pasującego pakietu. Wysyłanie komunikatów powinno być stosowane
            wyłączenie w celach diagnostycznych lub ze względów bezpieczeństwa.</li>
        </ul>
        <p>
          Chcąc utworzyć listę ACL standardową nazwaną, w konfiguracji
          globalnej musimy wydać następujące polecenie:
        </p>
<pre class="code-inline">
Router(config)# ip access-list standard access-list-name
</pre>
        <p>
          <code class="code-inline">access-list-name</code> to unikatowa nazwa
          dla listy. Zatwierdzenie tego polecenia, spowoduje, że przejedziemy
          w trybu konfiguracji listy ACL. Wówczas konfiguracja takiej listy
          skupia się tworzeniu reguł rozpoczynających się od słów kluczowych
          <code class="code-inline">permit, deny</code> i ewentualnie
          <code class="code-inline">remark</code>.
        </p>
<pre class="code-inline">
R1(config)# ip access-list standard PERMIT-ACCESS
R1(config-std-nacl)# remark ACE permits host 192.168.10.10
R1(config-std-nacl)# permit host 192.168.10.10
</pre>
        <p>
          Chcąc usunąć taką listę poprzedzamy polecenie
          <code class="code-inline">ip access-list standard PERMIT-ACCESS</code>
          słowem kluczowym <em>no</em>. 
        </p>
        <p>
          Określenie listy nie czyni jej jeszcze działającą. Jak pamiętamy
          listy są przypisywane do interfejsów i to na określonych kierunkach
          transmisji, więc chcąc podłączyć listę do interfejsu należy wydać
          poniższe polecenie:
        </p>
<pre class="code-block">
Router(config-if) # ip access-group {access-list-number | access-list-name} {in | out}
</pre>
        <p>
          Po słowie <code class="code-inline">access-group</code>, podajemy
          albo numer listy, albo jej nazwę i na koncu podajemy kierunek dla
          ruchu wychodzącego - <code class="code-inline">out</code> a dla ruchu
          przychodzącego - <code class="code-inline">in</code>. Aby odwołać
          listę musimy poprzedzić polecenie
          <code class="code-inline">ip access-group</code> słowem <em>no</em>
          oraz podać numer bądź nazwę listy.
        </p>
        <h3 id="3.5.1.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.1.8-packet-tracer---configure-numbered-standard-ipv4-acls_pl-PL.pdf">Konfigurowanie numerowanych standardowych list ACL IPv4 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.1.8-packet-tracer---configure-numbered-standard-ipv4-acls_pl-PL.pka">Konfigurowanie numerowanych standardowych list ACL IPv4 - zadanie</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.1.9-packet-tracer---configure-named-standard-ipv4-acls_pl-PL.pdf">Konfigurowanie nazywanych standardowych list ACL IPv4 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.1.9-packet-tracer---configure-named-standard-ipv4-acls_pl-PL.pka">Konfigurowanie nazywanych standardowych list ACL IPv4 - zadanie</a>
        </p>
        <h2 id="3.5.2.modifyingaclsforipv4">3.5.2. Modyfikowanie list ACL dla IPv4</h2>
        <p>
          Modyfikowanie ACL-ek, nie uchodzi za szczególnie przyjmne zajęcie.
          To zadanie może zrealizować na dwa sposoby. Możemy użyć albo
          wcześniej zapisanej w edytorze tekstu listy - tę listę wdrożoną
          należy usunąć poprzez słowo <em>no</em>, zmieć co trzeba i następnie
          utworzyć nową listę wklejając jej polecenia z edytora. Drugim
          sposobem jest użycie <strong>numerów sekwencyjnych</strong>.
        </p>
        <p>
          Numery sekwencyjne wyświetlane są gdy używamy polecenia
          <code class="code-inline">show access-list</code> do wyświetlenia
          list ACL. 
        </p>
<pre class="code-block">
R1# show access-lists 
Standard IP access list 1 
    10 deny 19.168.10.10 
    20 permit 192.168.10.0, wildcard bits 0.0.0.255
R1#
</pre>
        <p>
          Do ich edycji musimy skorzystać z polecenia
          <code class="code-inline">ip access-list standard</code>, następnie
          usuwamy wadliwy wpis, w tym przypadku jest
          <code class="code-inline">10</code> poprzedzając numer sekwencji
          słowem <em>no</em> i następnie poprawiony wpis rozpoczynamy od numeru
          sekwencji. Poniżej znajduje się przykład z IOS:
        </p>
<pre class="code-block">
R1# conf t
R1(config)# ip access-list standard 1
R1(config-std-nacl)# no 10
R1(config-std-nacl)# 10 deny host 192.168.10.10
R1(config-std-nacl)# end
R1# show access-lists
Standard IP access list 1
    10 deny   192.168.10.10
    20 permit 192.168.10.0, wildcard bits 0.0.0.255
R1#
</pre>
        <p>
          W przypadku nazwanej listy postępujemy podobnie, tylko zamiast numeru
          podajemy nazwę. Użycie numerów sekencyjnych daje nam jeszcze jedną 
          dodatkową funkcję, mianowicie pozwala nam wprowadzać wpisy w
          konkretne miejsca, na liście. Biorąc pod uwagę poprzedni przykład
          chcąc dodać host 192.168.10.5, którego ruch ma również zostać
          zablokowany, to jeśli dopiszemy ją to ta reguła nie będzieć mieć
          sensu. Druga reguła dopuszcza ruch z całej sieci 192.168.10.0/24.
          Zatem musimy wstawić regułę zablokowania hosta 192.168.10.5 pomiędzy
          regułę 10 a 20, na przykład. Możemy ją również wstawić na początku
          samej listy, również będzie ona miała swoje zastosowanie.
        </p>
<pre class="code-inline">
R1# configure terminal
R1(config)# ip access-list standard NO-ACCESS
R1(config-std-nacl)# 15 deny 192.168.10.5
R1(config-std-nacl)# end
R1#
R1# show access-lists
Standard IP access list NO-ACCESS
    15 deny   192.168.10.5
    10 deny   192.168.10.10
    20 permit 192.168.10.0, wildcard bits 0.0.0.255
R1#
</pre>
        <p>
          Chcąc wstawić w regułę edytujemy listę za pomocą polecenia
          <code class="code-inline">ip access-list</code> następnie
          rozpoczynamy wpis od numer np. 15. Na koniec opuszczamy tryb
          konfiguracji listy i wyświetlamy zawartość listy. Wydawać by się
          mogło, że
          nie takiego efektu się spodziewaliśmy. Ten efekt jest spowodowany
          działaniem funkcji mieszaczjącej na standardowych listach ACL dla
          IPv4.
        </p>
        <p>
          Wyświetlając listę za pomocą polecenia
          <code class="code-inline">show access-lists</code> możemy zauważyć,
          że IOS zlicza przypasowania do wpisów w ACL, dzięki czemu możemy
          zauważyć, czy te wpisy mają w ogóle zastosowanie. Czyszczenia
          liczników możemy dokonać za pomoca polecenia:
        </p>
<pre class="code-block">
R1# clear access-list counters
</pre>
        <p>
          Wydanego w trybie uprzywilejowanym EXEC.
        </p>
        <h2 id="3.5.3.securingvtylinesviastdaclsforipv4">3.5.3. Zabezpieczenia linii VTY za pomocą standardowyej ACL IPv4.</h2>
        <p>
          Przy użyciu ACL możemy określić, kto może się podłączyć do naszego
          urządzenia zdalnie, a kto nie. Cała metoda polega na utworzeniu
          standardowej listy ACL i następnie na liniach VTY możemy za pomocą
          polecenia <strong>access-class</strong> wskazać ACL, która będzie
          zezwalać lub blokować zdalny dostęp dla zapisanych w niej sieciach
          lub hostach. Poniżej znajduje się składania polecenia
          <em>access-class</em>:
        </p>
<pre class="code-block">
R1(config-line)# access-class {access-list-number | access-list-name} { in | out } 
</pre>
        <p>
          Zwróć my uwagę to polecenie pozwala również na ustalenie kierunku.
          Stosowanym w praktyce kierunkiem jest
          <code class="code-inline">in</code>, drugi kierunek odfiltrowuje
          ruch VTY wychodzący i jest on rzadko stosowany.
        </p>
<pre class="code-block">
R1(config)# username ADMIN secret class
R1(config)# ip access-list standard ADMIN-HOST
R1(config-std-nacl)# remark This ACL secures incoming vty lines
R1(config-std-nacl)# permit 192.168.10.10
R1(config-std-nacl)# deny any
R1(config-std-nacl)# exit
R1(config)# line vty 0 4
R1(config-line)# login local
R1(config-line)# transport input ssh
R1(config-line)# access-class ADMIN-HOST in
R1(config-line)# end
R1#
</pre>
        <p>
          Przy tak skonfigurowanej liniach VTY, dostęp przez SSH do urządzenia
          będzie mieć wyłącznie host o adresie 192.168.10.10.
        </p>
        <h2 id="3.5.4.extendedacllist">3.5.4. Rozszerzone listy ACL</h2>
        <p>
          Rozszerzone listy ACL pozwalają nam na dodanie większej ilości
          kryteriów dopasowania pakietów. Listy rozszerzone podobnie jak listy
          standardowe również mogą być numerowane oraz nazwane. Składnia 
          tworząca listę wraz ze wpisem wygląda następująco:
        </p>
<pre class="code-inline">
Router(config)# access-list access-list-number {deny | permit | remark text} 
protocol source source-wildcard [operator {port}] destination destination-wildcard
[operator {port}] [established] [log]
</pre>
        <p>
          Pierwszą zmianą odnośnie list standardowych jest:
          <code class="code-inline">protocol</code> - nazwa lub numer protokołu
          sieci Internet. Typowymi słowami kluczowymi są tutaj:
          <em>ip, tcp, udp, icmp</em>. Pełną listę możemy wyświetlić za pomocą
          znaku zapytania (<strong>?</strong>). Słowo kluczowe IP pasuje do
          wszystkich protokołów IP; 
          <code class="code-inline">destination</code> i
          <code class="code-inline">destination-wildcard</code> - adres ip oraz
          maska blankietowa dla sieci bądź hosta docelowego. Mogą tutaj 
          występować słowa kluczowe <em>host</em> oraz <em>any</em>;
          <code class="code-inline">operator</code> - porównuje porty źródłowe
          i docelowe. Możliwe argumenty to: <em>lt</em> (mniejsze niż),
          <em>gt</em> (większe niż), <em>eq</em> (równy), <em>neq</em>
          (nie równy) oraz <em>range</em> (zakres);
          <code class="cdoe-inline">port</code> - numer bądź nazwa portu TCP
          lub UDP. Pod znakiem zapytania (<strong>?</strong>), dostępna jest
          pełna lista wraz z numerami portów;
          <code class="code-inline">established</code> - funkcja
          zapory pierwszej generacji, tylko dla TCP.
        </p>
        <p>
          Włączanie list rozszerzonych wygląda tak samo jak w przypadku list
          standardowych, oto przykład:
        </p>
<pre class="code-inline">
R1(config)# access-list 110 permit tcp 192.168.10.0 0.0.0.255 any eq www
R1(config)# access-list 110 permit tcp 192.168.10.0 0.0.0.255 any eq 443
R1(config)# interface g0/0/0
R1(config-if)# ip access-group 110 in
R1(config-if)# exit
R1(config)#
</pre>
        <p>
          Stosowanie list rozszerzonych umożliwia nam dostęp do bardzo 
          wygodnej funkcji. Jeśli chcemy zabezpieczyć naszą sieć wewnętrzną
          za pomocą ACL-ek, to utworzyli byśmy dwie listy jedną na ruch 
          wchodzący do interfejsu sieci wewnętrznej, zezwalający np. jej
          użytkownikom na korzystanie z HTTP/S. Wówczas hosty naszej sieci,
          nie będą mogły korzystać z innych protokołów, jednak ta pojedyncza
          lista daje możliwość skomunikowania się z hostami naszej sieci
          z zewnątrz. Potrzebujemy drugiej ACL-ki, która zablokuje taką
          możliwość. Mogli byś my utworzyć pustą listę i przypisać ją do
          kierunku wychodzącego naszego interfejsu wewnętrzego i to tyle. Cały
          ruch zablokowany, w tym odpowiedzi od serwerów WWW dla hostów naszej
          sieci. Oczywiście przy takiej transmisji moglibyśmy dopuścić ruch
          na porcie źródłowym TCP/80 lub TCP/443 (HTTP, HTTPS). Co nie jest
          dobrym rozwiązaniem, ponieważ nie jest problemem wysłanie pakietu 
          o sfałszowanym porcie źródłowym. W tym przypadku skorzystamy z
          wpisu dopuszczającego cały TCP dla sieci 192.168.10.0/24, ale tylko
          dla połączeń już nawiązanych, blokując tym samym możliwość nawiązania
          nowego połączenia z zewnatrz temu służy opcja
          <strong>established</strong>. Należa zapamiętać, że z tej funkcji
          może skorzystać <strong>tylko dla protokołu TCP</strong>.
        </p>
<pre class="code-inline">
R1(config)# access-list 120 permit tcp any 192.168.10.0 0.0.0.255 established
R1(config)# interface g0/0/0
R1(config-if)# ip access-group 120 out 
R1(config-if)# exit
R1(config)#
</pre>
        <p>
          Wiele pozostałych czynności dokonywanych na listach rozszerzonych
          dokonuje się w sposób analogiczny do listy standardowych. Przyczym
          w przypadku wstawiania zasad do listy, to na listach rozszerzonych
          nie działa algorytm mieszający, zatem kolejność wpisów powinna być
          taka jaką my sobie zadeklarowaliśmy, ale nie jak ustalił to IOS.
        </p>
        <p>
          Do weryfikacji ACL, możemy wykorzystać polecenia:
          <code class="code-inline">show ip interface</code>, pokaże nam ono
          jakie listy są przypisane do tego interfejsu;
          <code class="code-inline">show access-list</code>, zwróci
          zdeklarowane w systemie listy ACL;
          <code class="code-inline">show running-config | begin ip access-list</code>,
          wyświetla listy ACL z bierzącej konfiguracji urządzenia.
        </p>
        <h3 id="3.5.4.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.4.12-packet-tracer---configure-extended-ipv4-acls---scenario-1_pl-PL.pdf">Konfiguracja rozszerzonych list ACL IPv4 - Scenariusz 1 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.4.12-packet-tracer---configure-extended-ipv4-acls---scenario-1_pl-PL.pka">Konfiguracja rozszerzonych list ACL IPv4 - Scenariusz 1 - zadanie</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.4.13-packet-tracer---configure-extended-ipv4-acls---scenario-2_pl-PL.pdf">Konfiguracja rozszerzonych list ACL IPv4 - Scenariusz 2 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.4.13-packet-tracer---configure-extended-ipv4-acls---scenario-2_pl-PL.pka">Konfiguracja rozszerzonych list ACL IPv4 - Scenariusz 2 - zadanie</a>
        </p>
        <h3 id="3.5.5.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.5.1-packet-tracer---ipv4-acl-implementation-challenge_pl-PL.pdf">Wdrażanie ACL IPv4 - wyzwanie - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/5.5.1-packet-tracer---ipv4-acl-implementation-challenge_pl-PL.pka">Wdrażanie ACL IPv4 - wyzwanie - zadanie</a>
        </p>
        <h3 id="3.5.5.lab">Laboratorium</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/lab/5.5.2-lab---configure-and-verify-extended-ipv4-acls_pl-PL.pdf">Konfiguracja i weryfikacja rozszerzonych list ACL IPv4</a>
        </p>
        <h2 id="3.5.summary">Podsumowanie</h2>
        <p>
          Ten rozdziała pokazał nam w jaki sposób tworzyć oraz modyfikować
          listy ACL. Poznaliśmy sposób na zabezpieczenie linii VTY za pomocą
          ACL oraz funkcję <em>established</em> rozszerzonych list dostępu.
          Na koniec poznaliśmy w jaki sposób możemy weryfikować listy ACL na 
          naszych urządzeniach.
        </p>
        <h1 id="3.6.natforipv4">3.6. NAT dla IPv4</h1>
        <p>
          Jak może pamiętamy z poprzedniego modułu pula adresów IPv4 jest
          na wyczerpaniu. W obecnym stanie rzeczy nie wystarcza adresów dla
          wszystkich urządzeń podłączonych do Internetu. Gdy osoby 
          odpowiedzialne za rozwój sieci globalnej spostrzegli, że pula adresów
          jest alokowana w bardzo szybkim tempie i za jakiś czas ich po prostu
          zacznie brakować, wydzielono trzy klasy adresów prywatnych. Adresy
          tego rodzaju są nie jednoznaczne dlatego też nie mogą być routowane
          w Internecie. Nie należą bowiem one do żadnej organizacji. Za
          definicję adresów odpowiada dokument RFC 1918, wydzielając tym samym:
        </p>
        <ul>
          <li><strong>Klasa A</strong> - 10.0.0.0 - 10.255.255.255 - 10.0.0.0/8</li>
          <li><strong>Klasa B</strong> - 172.16.0.0 - 172.31.255.255 -
            172.16.0.0/12</li>
          <li><strong>Klasa C</strong> - 192.168.0.0 - 192.168.255.255 -
            192.168.0.0/16</li>
        </ul>
        <p>
          Lokalne sieci komputerowe wykorzystują klasę adresów prywatnych do
          adresowania swoich komputerów. Jako, że te adresy nie mogą 
          funkcjonować poza sieciami lokalnymi, to musi istnieć mechanizm,
          który pozwoli na zamianę adresów prywatnych na adresy publiczne. 
          Tym właśnie jest <strong>NAT</strong>. Jak wszsystko na świecie,
          ta funkcjonalność posiada wady i zalety, które zostaną omówione
          w tym rozdziale.
        </p>
        <p>
          Mechanizm translacji adresów, zamienia adresy prywatne na adresy
          publiczne. W zależności czy są to adresy prywatne czy publiczne lub
          ruch jest przychodzący lub wychodzący spotkamy się z takimi
          określeniami adresów jak:
        </p>
        <ul>
          <li><strong>Wewnętrzny lokalny (<em>Inside local</em>)</strong> - 
            adres źródła widziany z perspektywy wnętrza sieci. Zwykle jest to
            prywatny adres IPv4.</li>
          <li><strong>Wewnętrzny globalny (<em>Inside global</em>)</strong> -
            adres źródła widziany z zewnątrz sieci. Jest to zazwyczaj globalnie
            rutowalny adres IPv4.</li>
          <li><strong>Zewnętrzny globalny (<em>Outside global</em>)</strong> - 
            adres docelowy widziany z zewnątrz sieci. Jest adresm IPv4
            globalnie rutowalny przypisanym hostowi w Internecie.</li>
          <li><strong>Zewnętrzny lokalny (<em>Outside local</em>)</strong> -
            Adres docelowy widziany z perspektywy wnętrza sieci. Nie jest to
            powszechnie praktykowane, ale adres ten może być inny niż
            adres publiczny.</li>
        </ul>
        <p>
          Terminy te wypełniąją taką instyucję jak <strong>tablica NAT</strong>,
          zawiera ona wszystkie mapowania adresów oraz portów.
        </p>
        <h2 id="3.6.1.typesofnat">3.6.1. Typy NAT</h2>
        <p>
          Mechnizm NAT może występować w kilku wariantach. Które różnią się
          technikami mapowania adresów. Pierwszym z nich jest 
          <strong>statyczny NAT</strong>, w
          którym to jeden adres prywatny zamieniany na jeden adres publiczny.
          Translacja jeden-do-jeden (1:1). Takie mapowania są wykonywane przez
          administratora i są niezmienne bez rekonfiguracji.
        </p>
        <p>
          Drugim rodzajem jest <strong>dynamiczny NAT</strong> - przypisuje on
          adresy na podstawie kolejności żądań dostępu do sieci zewnętrznej.
          Obie te metody NAT, wymagają odpowiednio dużej <strong>puli adresów
          publicznych</strong> przydzielonych przez operatora internetowego,
          jeśli pula będzie za mała, to tylko część z hostów będzie mieć
          dostęp do sieci zewnętrznej. A jak możemy się domyślić to operatorzy
          obecnie już nawet klientom biznesowym niechętnie ustępniają adresy
          IPv4.
        </p>
        <p>
          Istnieje również mechanizm, który jest w stanie zapewnić dostęp do
          sieci zewnętrznej przy jednym lub kilku adresach zewnętrznych. Takim
          mechanizmem jest <strong>PAT (<em>Port Address Translation</em>)</strong>
          nazywany również NAT-em z przeciążeniem. Ponieważ przeciążamy jeden
          adres, ruchem większym niż pochodzący z jednego komputera.
          Poza zwykłą translacją adresów,
          działa on na zasadzie zmiany portu źródłowego jeśli do routera
          docierają połączenia z różnych hostów z tymi samymi numerami portów
          źródłowych. Wówczas dla adresu wewnętrznego globalnego przypisywany
          jest inny numer portu i tak przetworzony pakiet wysyłany jest do
          hosta docelowego. W taki sposób działają mechnizmy NAT w urządzeniach
          domowych lub przeznaczonych dla małych firm.
        </p>
        <p>
          Podczas działania mechaznizm PAT stara się zachować oryginale porty,
          jeśli jest to jednak niemożliwe, wówczas używa on pierwszego
          dostępnego z odpowiedniej grupy portów: 0-511, 512-1023 lub 
          1024-65535. Jeśli jakimś cudem wszystkie porty zostaną wykorzystane,
          to dopiero mechanizm przechodzi do kolejnego adresu.
        </p>
        <p>
          Porównując PAT oraz NAT. To NAT:
        </p>
        <ul>
          <li>Mapowanie jeden do jeden między adresami wewnętrznymi lokalnymi
            a wewnętrznymi globalnymi.</li>
          <li>Używa tylko adresów IPv4 w procesie translacji.</li>
          <li>Unikalny adres wewnętrzny globalny jest wymagany, dla każdego
            wewnętrznego hosta łączącego się z siecią zewnętrzną.</li>
        </ul>
        <p>
          A PAT z kolei:
        </p>
        <ul>
          <li>Jeden adres wewnętrzny globalny można mapować na wiele adresów
            wewnętrznych.</li>
          <li>Używa adresów IPv4 i numerów portów źródłowych TCP lub UDP w
            procesie translacji.</li>
          <li>Pojedynczyny unikalny adres wewnętrzny globalny, może być
            wspołdzielony przez wiele wewnętrznych hostów łączących się z
            siecią zewnętrzną.</li>
        </ul>
        <p>
          W przypadku mechanizmu PAT, pozostaje jedna nierozwiązana kwestia.
          Otóż wymiana komunikatów <em>echo</em> protokołu ICMP przez PAT.
          Tak naprawdę to TCP, UDP i ICMP przez PAT osbługiwane są w nieco inny
          sposób. W przypadku działania narzędzia <em>ping</em> wykorzystywane
          jest pole <strong>Query ID</strong> zawarte w komunikatach
          <em>echo request</em> i <em>echo reply</em>. To pole zwiększane jest
          o jeden z każdym wysłanym zapytaniem do sieci zewnętrznej.
        </p>
        <h3 id="3.6.1.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.2.7-packet-tracer---investigate-nat-operation_pl-PL.pdf">Badanie działania NAT - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.2.7-packet-tracer---investigate-nat-operation_pl-PL.pka">Badanie działania NAT - zadanie</a>
        </p>
        <h2 id="3.6.2.natprosandcons">3.6.2. Zalety i wady mechanizmu NAT</h2>
        <p>
          Do zalet mechanizmu NAT możemy zaliczyć:
        </p>
        <ul>
          <li>Zmniejszenie zapotrzebowania na publiczne adresy IP.</li>
          <li>Zwiększenie elastyczności połączenia z siecią zewnętrzną.</li>
          <li>Zapewnienie spójności schematów adresowania.</li>
          <li>Ukrycie adresów IPv4 użytkowników i urządzeń sieci lokalnej.</li>
        </ul>
        <p>
          Natomiast do wad mechanizmu NAT możemy zaliczyć:
        </p>
        <ul>
          <li>Wydajność sieci, szczególnie widoczna w protokołach czasu
            rzeczywistego takich VoIP.</li>
          <li>Translacje z adresu prywatnego na prywatny.</li>
          <li>Utrata adresowania <em>end-to-end</em>, co może powodować
            zaburzenie działania aplikacji bezpieczeństwa, np. podpisu
            elektronicznego.</li>
          <li>Utrata śledzenia pakietów IP <em>end-to-end</em>.</li>
          <li>Komplikacje podczas używania protokołów tunelowania - przez
            ingerencje w pakiety.</li>
          <li>Zakłócenie działania protokółów inicjujących połączenia TCP z
            zewnątrz (FTP), czy protokołów bezstanowych UDP.</li>
        </ul>
        <h2 id="3.6.3.staticnatonios">3.6.3. NAT statyczny w IOS</h2>
        <p>
          Załóżmy hipotetycznie, że mamy serwer WWW o adresie 192.168.1.10,
          ma on być dostępny dla klientów z sieci zewnętrznej pod adresem
          209.169.201.6. Co należy zrobić, aby zrealizować to zadanie przy
          użyciu routera Cisco?
        </p>
        <p>
          Otóż na początek tworzymy odwzorowanie między adresem wewnętrznym
          lokalnym, a adresem wewnętrznym globalnym.
        </p>
<pre class="code-block">
Router(config)# ip nat inside source static 192.168.10.254 209.169.201.5
</pre>
        <p>
          W powyższym polecenie użyliśmy słów kluczowych:
          <code class="code-inline">inside</code> ze względu, że dokonujemy
          mapowań wewnętrznych (lokalny do globalnego),
          <code class="code-inline">source</code>, ponieważ router ma zamieniać
          adresy źródłowe oraz <code class="code-inline">static</code>,
          ustawiamy NAT statyczny, to jest mapowanie adresów 1:1.
        </p>
        <p>
          Następnym zadaniem jest określenie stron translacji. Sieć LAN
          wykorzystuje <em>Ethernet</em> więc ostatni port będzie łączem z
          sieci do routera. Natomiast port szeregowy będzie symulować naszą
          sieć rozległą.
        </p>
<pre class="code-block">
Router(config)# interface GigabitEthernet0/2
Router(config-if)# ip address 192.168.1.2 255.255.255.0
Router(config-if)# ip nat inside
Router(config-if)# exit
R2(config)# interface serial 0/1/1
R2(config-if)# ip address 209.169.200.1 255.255.255.252
R2(config-if)# ip nat outside
</pre>
        <p>
          Teraz adresy źródłowe serwera WWW będą tłumaczone na nasz adres
          wewnętrzny globalny.
        </p>
        <p>
          Jeśli chcielibyśmy sobie przeanlizować jak to wygląda, to klient
          gdzieś w Internecie, wpisuje adres strony. System DNS tłumaczy ten
          adres strony na adres IP pod którym widnieje nasz serwer w sieci
          zewnętrznej. Pakiet z żądaniem strony dociera do naszego serwer i ten
          mu odpowiada. Pakiet z odpowiedzią zawiera <strong>adres źródłowy
          prywatny</strong> - tj. 192.168.1.10 i adresem docelowym jest
          adres źródłowy żądania strony. Oczywiście adres jest poza siecią
          więc docelowym adresem MAC ramki <em>Ethernet</em> będzie adres
          MAC interfejsu bramy. W momecie gdy pakiet osiągnie router,
          dochodzi do translacji adresów. W tym momencie dochodzimy różnicy w
          rodzajach mechanizmu
          NAT, ponieważ w przypadku statycznego NAT-u, <strong>adres źródłowy
          zostanie zamieniony na zmapowany wcześniej adres publiczny.</strong>
          Zatem do naszej bramy adresem źródłowym będzie: 192.168.1.10,
          natomiast po jej opuszczeniu adresem źródłowym będzie 209.169.201.5.          
        </p>
        <p>
          Do w celu weryfikacji ustawień NAT-u możemy posłużyć się dwoma
          poleceniami:
        </p>
        <ul>
          <li><strong>show ip nat translations</strong> - wyświetlenie tablicy
            NAT-u, w przypadku NAT-u statycznego, mimo że nie było żadnych
            połączeń to i tak zawiera ona mapowania.
<pre class="code-block">
Router# show ip nat translations
Pro  Inside global       Inside local       Outside local     Outside global
---  209.165.201.5       192.168.10.254     ---               ---
Total number of translations: 1
</pre>
            W tablicy znajdują się kolumny, które powinniśmy znać z początku
            rozdziału, dodatkową kolumną jest
            <code class="code-inline">Pro</code>, oznaczająca protokół.
            Tablicę można wyczyścić za pomocą polecenia:
            <code class="code-inline">clear ip nat translations *</code>, 
            gwiazdka (<strong>*</strong>) oznacza, że należy wyczyścić tablicę
            dla obu kierunków - <em>inside</em> oraz <em>outside</em>.
            Polecenie to wydaje w trybie uprzywilejowanym EXEC.
          </li>
          <li><strong>show ip nat statistics</strong> - wyświetlenie statystyk
            dotyczących NAT-u. To polecenie wyświetla nam ilość połaczeń, w
            których zostały zamienione adresy.
<pre class="code-block">
Router# show ip nat statistics
Total active translations: 1 (1 static, 0 dynamic; 0 extended)
Outside interfaces:
  Serial0/1/1
Inside interfaces:
  GigabitEthernet0/2
Hits: 0  Misses: 0
...
</pre>
          Podczas interpretacji wyniku tego polecenia powinno, nam najbardziej
          zależeć na linii: <code class="code-inline">Hits: 0  Misses: 0</code>.
          Pokazują one w ilu połączeniach zostały zmienione adres
          (<code class="code-inline">Hits:</code>), oraz
          ile połączeń nie udało się zrealizować (z różnych powodów) - 
          (<code class="code-inline">Misses:</code>).
          </li>
        </ul>
        <h2 id="3.6.4.dynamicnatonios">3.6.4. Dynamiczny NAT w IOS</h2>
        <p>
          Poprzedni rodzaj NAT-u wymagał zmapowania adresów prywatnych z
          publicznymi, jeden
          do jeden. W tym przypadku mapowanie będzie odbywać się na podstawie
          żądania do sieci zewnętrznej i będzie odbywać się dynamicznie.
          Wcześnie to administrator decydował o tym jaki adres prywatny będzie
          mapowany na adres publiczny. Teraz decyduje o tym router. Ten stan
          rzeczy powoduje, że konfiguracja będzie nieco bardziej skomplikowana. 
        </p>
        <p>
          Załóżmy, że mamy dwa komputery w dwóch różnych sieciach, mają one
          następujące adresy: 192.168.10.10/24 oraz 192.168.11.10/24. Komputery
          chcą skomunikować się z serwerem od adresie 209.165.200.254.
        </p>
        <p>
          Na początku musimy rozpocząć naszą konfigurację od określenia puli
          adresów, jakie mogą być mapowane podczas dynamicznego NAT-u. Taką
          pulę zazwyczaj uzyskuje się od swojego dostawcy usług internetowych.
          W naszym przypadku są to adresy od 209.165.200.226 do 209.165.200.240
          z maską /27. Aby skonfigurować pulę w trybie konfiguracji globalnej
          wydajemy poniższe polecenie:
        </p>
<pre class="code-block">
Router(config)# ip nat pool NAT-POOL1 209.165.200.226 209.165.200.240 netmask 255.255.255.224
</pre>
        <p>
          Za pomocą powyższego polecenia zdefiniowaliśmy pulę o nazwie
          <code class="code-inline">NAT-POOL1</code>. Teraz musimy utworzyć
          warunek, dzięki któremu określimy jakie sieci mają kwalifikować się
          tłumaczenia
          lub ich adresy mają być tłumaczone na jasno określoną pulę adresów.
          Takie warunki tworzy się za pomocą standardowych list ACL.
        </p>
<pre class="code-block">
Router(config)# access-list 1 permit 192.168.0.0 0.0.255.255
</pre>
        <p>
          Teraz należy połaczyć ze sobą pulę adresów NAT-u oraz listę ACL,
          w jednej definicji dynamicznej translacji adresów.
        </p>
<pre class="code-block">
Router(config-if)# ip nat inside source list 1 pool NAT-POOL1
</pre>
        <p>
          Przyczym, ACL nie musi być numerowana, nazwana również jest możliwa
          do użycia w tym przypadku. Ostatnią czynnością jest określenie
          wewnętrznych i zewnętznych interfejsów. 
        </p>
<pre class="code-block">
Router(config)# interface GigabitEthernet0/1
Router(config-if)# ip nat inside
Router(config)# interface GigabitEthernet0/2
Router(config-if)# ip nat inside
Router(config)# interface serial 0/1/1
Router(config-if)# ip nat outside
</pre>
        <p>
          Wersje sprzętowe IOS posiadają dodatkowy słowo kluczowe
          <code class="code-inline">verbose</code> dla polecenia
          <code class="code-inline">show ip nat translations</code>. Która
          wyświetla więcej informacji na temat wpisów w tablicy NAT.
        </p>
<pre class="code-inline">
Router# show ip nat translation verbose
Pro Inside global      Inside local       Outside local      Outside global
tcp 209.165.200.228    192.168.10.10      ---                ---
    create 00:02:11, use 00:02:11 timeout:86400000, left 23:57:48, Map-Id(In): 1, 
    flags: 
none, use_count: 0, entry-id: 10, lc_entries: 0
tcp 209.165.200.229    192.168.11.10      ---                ---
    create 00:02:10, use 00:02:10 timeout:86400000, left 23:57:49, Map-Id(In): 1, 
    flags: 
none, use_count: 0, entry-id: 12, lc_entries: 0
</pre>
        <p>
          Zwróćmy uwagę na to, że wpisy w tablicy NAT-u widnieją przez
          określony czas. W przypadku NAT-u dynamicznego, domyślnie są to 24
          godziny, chyba że zdefiniowano inaczej przy pomocy polecenia
          <code class="code-inline">ip nat translation timeout</code>. Nie
          musimy jednak wyczekiwać na wygaśnięcie wpisów. Możemy je ręcznie
          usunąć, czy przy użyciu tego samego polecenia
          (<code class="code-inline">clear ip nat translation</code>), 
          które czyści całą tablicę - w tym przypadku podajemy
          <code class="code-inline">inside lokalny-adr globalny-adr</code> lub
          <code class="code-inline">outside lokalny-adr globalny-adr</code>.
        </p>
        <p>
          W przypadku dynamicznego NAT i polecenie <code class="code-inline">
          show ip nat statistics</code> wzraca więcej informacji, np. procent
          zaalokowanej puli.
        </p>
<pre class="code-inline">
Router# show ip nat statistics 
Total active translations: 4 (0 static, 4 dynamic; 0 extended)
Peak translations: 4, occurred 00:31:43 ago
Outside interfaces:
  Serial0/1/1
Inside interfaces: 
  GigabitEthernet0/1
  GigabitEthernet0/2
Hits: 47  Misses: 0
CEF Translated packets: 47, CEF Punted packets: 0
Expired translations: 5
Dynamic mappings:
-- Inside Source
[Id: 1] access-list 1 pool NAT-POOL1 refcount 4
 pool NAT-POOL1: netmask 255.255.255.224
	start 209.165.200.226 end 209.165.200.240
	type generic, total addresses 15, allocated 2 (13%), misses 0
...
</pre>
        <p>
          Wyświetlając bierzącą konfiguracje z poleceniem filtrujący
          <em>include</em>, możemy podejrzeć konfiguracje NAT-u.
        </p>
<pre class="code-inline">
R2# show running-config | include NAT
ip nat pool NAT-POOL1 209.165.200.226 209.165.200.240 netmask 255.255.255.224
ip nat inside source list 1 pool NAT-POOL1
</pre>
        <h3 id="3.6.4.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.5.6-packet-tracer---configure-dynamic-nat_pl-PL.pdf">Konfigurowanie dynamicznego NAT - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.5.6-packet-tracer---configure-dynamic-nat_pl-PL.pka">Konfigurowanie dynamicznego NAT - zadanie</a>
        </p>
        <h2 id="3.6.5.patonios">3.6.5. PAT w IOS</h2>
        <p>
          W większości przypadków, konfiguracji sieci czy to w mniejszych, czy
          większych organizacjach, nie skorzystamy z żadnej z powyższych metod,
          gdyż wymagają one puli adresów publicznych, a te obecnie są bardzo
          rzadko przydzielane. Najczęstszym rodzajem NAT-u jaki będziemy 
          konfigurować jest właśnie PAT.
        </p>
        <p>
          Scenariusz z dynamicznego NAT-u rozszerzymy od dodatkowy serwer.
          Serwery będą mieć adresy 209.165.201.1 oraz 209.165.202.129. Adres
          sieci zewnętrznej naszego routera to 209.165.200.224/27. Natomiast
          adres interfejsu podłączonego do sieci zewnętrznej to: 
          209.165.200.225. Adres sieci zewnętrznej określa pulę przydzielonych
          adresów publicznych od usługodawcy.
        </p>
        <p>
          Konfigurując PAT, mamy do wyboru tak naprawdę dwa podejścia.
          Pierszym z nich jest przeciążenie pojedynczego adresu, który mamy
          przypisany do interfejsu. Tak zazwyczaj będzie w przypadku domów lub
          małych biur. Konfigurację rozpoczynamy od utworzenia ACL-ki w celu
          określenia jakie sieci źródłowe mają być tłumaczone.
        </p>
<pre class="code-block">
Router(config)# access-list 1 permit 192.168.0.0 0.0.255.255
</pre>
        <p>
          Następnie musimy powiązać listę ACL z interfejsem, podobnie jak
          w przypadku dynamicznego NAT-u, kiedy powiązaliśmy ACL z pulą. W celu
          uruchomienia PAT-u, dodajemy do polecenia słowo kluczowe
          <strong>overload</strong>.
        </p>
<pre class="code-block">
Router(config)# ip nat inside source list 1 interface serial 0/1/1 overload
</pre>
        <p>
          W tym przypadku wykorzystaliśmy słowo kluczowe 
          <code class="code-inline">interface</code> i podaliśmy ID interfejsu.
          Teraz wszystkie połączenia z dwóch naszych podsieci będą tłumaczone
          na ten jeden adres, który jest ustawiony na interfejsie
          <code class="code-inline">serial 0/1/1</code>. Poza słowem
          <code class="code-inline">overload</code> reszta polecenia pozostaje
          taka sama. Ostatnią czynnością jest określenie stron na interfejsach.
        </p>
<pre class="code-block">
Router(config)# interface GigabitEthernet0/1
Router(config-if)# ip nat inside
Router(config)# interface GigabitEthernet0/2
Router(config-if)# ip nat inside
Router(config)# interface serial 0/1/1
Router(config-if)# ip nat outside
</pre>
        <p>
          Drugim podejściem jest translacja adresów na adresy z wcześniej
          zdefiniowanej puli. Tutaj wykonujemy wszystkie czynności w taki
          sam sposób jak w przypadku dynamicznego NAT-u, ale do polecenia
          dowiązania listy ACL do puli dodajemy słowo kluczowe
          <code class="code-inline">overload</code>.
        </p>
<pre class="code-block">
Router(config)# ip nat pool NAT-POOL1 209.165.200.226 209.165.200.240 netmask 255.255.255.224
Router(config)# access-list 1 permit 192.168.0.0 0.0.255.255
Router(config-if)# ip nat inside source list 1 pool NAT-POOL1 overload
Router(config)# interface GigabitEthernet0/1
Router(config-if)# ip nat inside
Router(config)# interface GigabitEthernet0/2
Router(config-if)# ip nat inside
Router(config)# interface serial 0/1/1
Router(config-if)# ip nat outside
</pre>
        <p>
          Po uruchomieniu NAT-u wyżej wymienionymi metodami, router będzie
          starał zachować oryginalne porty, jednak jednak u któregoś z hostów
          porty źródły będzie się powtarzać to zostanie zmieniony na pierwszy
          wolny. Router przeszukuje trzy grupy w poszukiwaniu odpowiedniego
          portu do zmiany. Jeśli w jakiś sposób porty się wyczerpią, wówczas
          dopiero, albo dalsza możliwość tłumaczenia zaniknie, jeśli
          tłumaczyliśmy na pojedynczy adres, albo zostanie wykorzystany
          kolejny adres z puli. Poniżej znajdują się zrzuty tablicy NAT oraz
          statystyk dotyczących skonfigurowanego przez nas PAT-u.
        </p>
<pre class="code-inline">
Router# show ip nat translations
  Pro Inside global          Inside local         Outside local      Outside global
  tcp 209.165.200.225:1444  192.168.10.10:1444  209.165.201.1:80   209.165.201.1:80
  tcp 209.165.200.225:1445  192.168.11.10:1444  209.165.202.129:80 209.165.202.129:80

Router# show ip nat statistics 
Total active translations: 4 (0 static, 2 dynamic; 2 extended)
Peak translations: 2, occurred 00:31:43 ago
Outside interfaces:
  Serial0/1/1
Inside interfaces: 
  GigabitEthernet0/1
  GigabitEthernet0/2
Hits: 4  Misses: 0
CEF Translated packets: 47, CEF Punted packets: 0
Expired translations: 0
Dynamic mappings:
-- Inside Source
[Id: 3] access-list 1 pool NAT-POOL1 refcount 2
  pool NAT-POOL1: netmask 255.255.255.224
      start 209.165.200.225 end 209.165.200.240
      type generic, total addresses 15, allocated 1 (6%), misses 0
...
</pre>
        <h3 id="3.6.5.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.6.7-packet-tracer---configure-pat-instructions_pl-PL.pdf">Konfiguracja PAT - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.6.7-packet-tracer---configure-pat-instructions_pl-PL.pka">Konfiguracja PAT - zadanie</a>
        </p>
        <h2 id="3.6.6.nat64"> 3.6.6. NAT64</h2>
        <p>
          Protokół IPv6 nie potrzebuje takich mechanizmów jak NAT, zawiera
          bardzo dużo adresów - nie wiadomo czy kiedyś się one skończą, Zawiera
          on także adresy lokalne podobne do tych z RFC1918, ale nie mają one
          takiej samej funkcji. NAT w IPv6, nazwany <strong>NAT64</strong>
          ma zupełnie inną funkcję, otóż służy on do tworzenia
          transparentnych połączeń pomiędzy sieciami IPv6 a IPv4. Jest to
          technologia przejściowa na czas całkowite migracji do IPv6.
        </p>
        <h3 id="3.6.7.pka">Zadanie praktyczne - Packet Tracer</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.8.1-packet-tracer---configure-nat-for-ipv4_pl-PL.pdf">Konfiguracja NAT dla IPv4 - scenariusz</a><br />
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/6.8.1-packet-tracer---configure-nat-for-ipv4_pl-PL.pka">Konfiguracja NAT dla IPv4 - zadanie</a>
        </p>
        <h3 id="3.6.7.lab">Laboratorium</h3>
        <p>
          <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/lab/6.8.2-lab---configure-nat-for-ipv4_pl-PL.pdf">Konfiguracja NAT dla IPv4</a>
        </p>
        <h2 id="3.6.summary">Podsumowanie</h2>
        <p>
          W tym rozdziale zapoznaliśmy się z mechanizmem sieciowym NAT dla IPv4.
          Mechnizm ten zapewnia dostęp komputerom sieci lokalnej do sieci
          zewnętrznych. Poznaliśmy jego metodę działania oraz jego odmiany.
          Dowiedziliśmy się w jaki sposób uruchomić go na sprzęcie Cisco z
          systemami IOS. Na koniec wyjaśniono czym jest NAT64.
        </p>
        <h1 id="3.7.wanconcepts">3.7. Koncepcje sieci WAN</h1>
        <p>
          Sieci lokalne LAN, są sieciami budowanymi na małym obszarze lub na
          małą skalę. Jednego budynku, jednego przedsiębiorstwa na niewielkim
          obszarze. Innym rodzajemy sieci jest sieć WAN - sieć rozległa, która
          rozciąga się swoim poza budynki, często wykorzystując
          infrastrukturę miejską, łącząc ze sobą również inne miasta czy
          mniejsze miejscowości. W tym temacie opowiemy sobie o technologiach,
          które stoją za tym, że w domu mamy puszkę światłowowodową, kabel
          koncentryczny czy gniazdo telefoniczne za ich pośrednictwem możemy
          mieć dostęp do sieci Internet, ale i nie tylko. Mając odpowiednie
          zasoby finansowe możemy połączyć ze sobą dwa budynki będące w różnych
          częściach mista lub w różnych miastach dedykowanym tylko dla nas
          łączem.
        </p>
        <p>
          Sieci LAN, są wyłącznie naszą sprawą prywatną. W przypadku gdy przy
          sieciach rozległych sprawa nie jest aż tak oczywista. Mimo iż
          struktura takiej sieci należy do naszego usługodawcy to współdzielimy
          ją z innymi abonentami. Wyjątkiem tutaj są dzierżawione linie
          abonenckie, gdzie usługodawca zestawia nam połączenie sieci WAN
          (w tych technologiach) między jednym a drugim naszym punktem. Jednak
          ich cena, nawet bogatsze firmy zmusza do wykorzystywania 
          infrastruktury publicznej, oczywiście jako klienci biznesowi są
          lepiej traktowani i mają wiecej możliwości. Jest jednak branża,
          która dalej będzie korzystać z dzierżawionych łączy i jest nią
          bankowość.
        </p>
        <p>
          Sieci rozległe podobnie jak ich lokalne odpowiedniki posiadają
          topologie, i wśród nich możemy wyróżnić:
        </p>
        <ul>
          <li><strong>Połaczenie punkt-punkt</strong> - połaczenie łączące dwa
            punkty siecią rozległą. Dla stron w komunikacji rozwiązanie tego
            typu jest transparente. Najczęściej jest nim dzierżawiona linia
            abonencka.</li>
          <li><strong>Topologia <em>Hub-and-spoke</em></strong> - topologią
            umożliwiająca łączność mniejszych sieci za pośrednictwem tylko i
            wyłącznie jednego punktu centralnego.</li>
          <li><strong>Topologia <em>dual-homed</em></strong> - jest to 
            zwielokrotniona topologia <em>Hub-and-spoke</em>, niewelująca
            wadę poprzedniej topologii, jaką był pojednyczy punkt awarii.
            Topologia ta zawiera zwielokrotnione punkty centralne (podwójne)
            oraz dodatkowe łącza z mniejszych sieci (po dwa na sieć).</li>
          <li><strong>Topologia pełnej siatki</strong> - jest połączenie 
            każdy z każdym. Topologia jest drogą w budowie, ale zapewnia
            najlepsze warunki podwzględem niezawodności i wydajności.</li>
          <li><strong>Topologia siatki niepełnej</strong> - jest topologia
            zapewniająca pewien procent, nadmiarowych łączy pomiędzy węzłami
            sieci, jednak nigdy nie będzie to 100%, tj. każdy z każdym
            (topologia pełnej siatki). Mimo to taka topologia może
            zapewnić komunikację miedzy wszystkimi urządzeniami.</li>
        </ul>
        <p>
          W sieciach korporacyjnych możemy spotkać się z większą niż jeden
          liczbą połączeń do sieci rozległej, najczęściej zapewnianą przez
          dwóch różnych operatorów. Ma to na celu zapewnienie niezawodności - 
          dalszego działania usług, pomimo awarii jednego z łączy oraz
          wydajności poprzez równoważnie obciążenia przez te łącza. Klienci
          biznesowi (duże firmy) zazwyczaj podpisują z operatorem
          <strong>umowę o poziomie usług - SLA</strong>, w której to mogą
          znajdować
          się takie zapisy jak możliwa długość braku dostępu do usługi w skali
          roku lub deklarowana przepustowość.
        </p>
        <p>
          Sieci lokalne mogą ewoluować, rozrastać się pod względem ilości
          hostów czy podsieci, ale również rozrastać fizycznie wraz rozwojem
          firmy. Wówczas technlogie sieci lokalnych, mogą okazać nie wydajne
          i zbyt drogie, aby móc połączyć ze sobą nawet dwa budynki, ale
          znajdujące się np. w różnych częsciach miasta czy kraju. Remedium
          na tego typu problemy są właśnie sieci rozległe oraz ich technologie.
        </p>
        <h2 id="3.7.1.wanoperation">3.7.1. Operacje WAN</h2>
        <p>
          Za standardy sieci WAN odpowiedzialne są takie organizacje jak:
          <strong>TIA/EIA</strong>, <strong>ISO</strong>, <strong>IEEE</strong>.
        </p>
        <p>
          Sieci WAN najczęsciej operują w warstwie 1 oraz 2. Protokoły warstwy
          pierwszej opisują elementy elektryczne, mechaniczne oraz operacyjne
          przesyłania bitów przez medium transmisyjne. Obecnie najczęściej
          wykorzystywane są światłowody o dużej odległości, a rozwiązania
          stosowane to między innymi:
        </p>
        <ul>
          <li><strong>Synchronus Digital Hierarchy (SDH)</strong>,</li>
          <li><strong>Synchronus Optical Networking (SONET)</strong>,</li>
          <li><strong>Dense Wavelength Division Multiplexing (DWDM)</strong>.</li>
        </ul>
        <p>
          SDH oraz SONET zasadniczo świadczą te same usługi. SDH upowszechnił
          się na kontencie europejskim natomiast SONET stosowany jest w krajach
          Ameryki Północnej. Te dwie technologie mogą rozszerzyć swoją nośność
          dzięki zastosowaniu DWDM.
        </p>
        <p>
          Protokoły warstwy drugiej definiują sposoby przesyłania danych w
          ramkach. Do rozwiązań stosowanych przez sieci WAN w tej warstwie
          możemy zaliczyć takie protokoły jak:
        <p>
        <ul>
          <li><strong>Połączenia szerokopasmowe (tj. DSL i kablowe)</strong>,
          <li><strong>Łączność bezprzewodowa</strong>,</li>
          <li><strong>Ethernet WAN</strong>,</li>
          <li><strong>Multiprotocol Label Switching (MPLS).</strong></li>
        </ul>
        <p>
          Do rzadziej stosowanych technologii, możemy zaliczyć:
          <strong>Point-to-Point Protocol (PPP)</strong>, czy
          <strong>High-Level Data Link Control (HDLC)</strong>.
        </p>
        <p>
          Ze względu na fakt działania sieci WAN w wartstwie 1 i 2 
          musimy zapoznać się z terminologią związaną z fizycznymi połączeniami
          pomiędzy siecią firmową a siecią usługodawcy. Poniżej znajduje się
          lista terminów związanych z sieciami WAN:
        </p>
        <ul>
          <li><strong>Urządzenie końcowe (DTE)</strong> - urządzenie abonenta,
            zazwyczaj jest to router, jednak równie dobrze może to być serwer.</li>
          <li><strong>Urządzenie komunikacyjne (DCE)</strong> - urządzenie
            najczęściej dzierżawione lub przezkazane przez operatora na czas
            świadczenia usługi. Urządzenie jest dostosowane do medium
            stosowanego przez operatora i służy do komunikacji z jego siecią.</li>
          <li><strong>Urządzenia końcowe użytkownika (CPE)</strong> - termin
            określający urządzenie lub zestaw urządzeń przekazanych do
            abonenta. Abonent może dzierżawić CPE lub być ich właścicielem.
            Mianem CPE określa się zbiorczo DCE i DTE oraz często samego
            abonenta.</li>
          <li><strong>Punkt obecności (POP)</strong> - punkt, w którym
            abonament łączy się z usługodawcą.</li>
          <li><strong>Punkt graniczy (punkt demarkacyjny)</strong> - skrzynka
            z kablowaniem, znajdująca się na terenie abonenta łącząca CPE do
            lokalnej pętli.</li>
          <li><strong>Pętla lokalna (ostatnia mila)</strong> - fizyczne
            połączenie łącze CPE do CO usługodawcy, może być to kabel miedziany
            lub światłowód.</li>
          <li><strong>Biuro centralne (Central Office - CO)</strong> - lokalny
            obiekt usługodawcy lub budynek łączący CPE z siecią usługodawcy.</li>
          <li><strong>Sieć płatna</strong> - dedydkowane łączą komunikacyjne
            wykorzystujące infrastrukturę usługodawcy.</li>
          <li><strong>Sieć dostępowa</strong> - sieć połączonych ze sobą
            punktów dostępowych do sieci usługodawcy. Sieci tego typu obejmują
            powiaty, województwa lub regiony.</li>
          <li><strong>Sieć szkieletowa</strong> - sieci o dużej pojemności
            wykorzystywane do łączenia sieci dostawcy usług i tworzenia sieci
            nadmiarowych.</li>
        </ul>
        <p>
          Do urządzeń sieci rozległych możemy zaliczyć, różnego rodzaju modemy
          konwertery optyczne, a czasem nawet routery czy punkty dostępowe.
        </p>
        <p>
          Komunikację sieciową można zrealizować za pomocą komunikacji z
          komutacją (przełączaniem) łączy. Sieć z komutacją łączy ustanawia
          dedykowany obwód (lub kanał) między punktami końcowymi, zanim
          użytkownicy będą mogli się komunikować. Najpopularniejsze
          technologie WAN, wykorzystujące komuntację łączy to: <strong>PTSN</strong>
          - publiczna
          komuntowana sieć telefoniczna i cyfrowa sieć z integracją usług
          - <strong>ISDN</strong>. Sieci tego rodzaju są zaszłością i zostały
          wyparte przez sieci z przełączaniem pakietów, takie jak
          <em>Ethernet WAN</em> (<em>Metro Ethernet</em>) czy MPLS.
        </p>
        <p>
          Standardy sieci WAN warstwy pierwszej - SONET/SDH, definiują sposób
          przesyłania ogromnych ilości danych, danych głosowych czy komunikacji
          wideo, przez swiadłowód na duże odległości. Standardy te są użwane w
          topologii pierścienia, zawierająca ścieżki nadmiarowe umożliwiające
          przepływ ruchu w obu kierunkach. Technologia DWDM zwiększa nośność
          dla SDH i SONET poprzez przesyłanie przez ten sam światłowód 
          impulsów świetlnych o różnej długości fali, zapewniając tym samy
          odrębne kanały komunikacyjne.
        </p>
        <h2 id="3.7.2.currentwantechnologies">3.7.2. Obecne technologie sieci WAN</h2>
        <p>
          Generalnie technologia <em>Ethernet</em>, nie była przeznaczona dla
          innych sieci poza lokalnymi ze względu na ograniczenia długości
          okablowania miedzianego, jednak zmianę tego punktu widzenia
          przyniosły światłowowdy. Dzięki nim <em>Ethernet</em>, stał się jedną
          z opcji dostępowych dla sieci WAN. Niektóre standardy potrafią 
          przesyłać informacje na odległosci do 70 km (IEEE 1000BASE-ZX).
        </p>
        <p>
          Innym przykładem może być <strong>MPLS</strong> to wysoce wydajna
          technologa routingu WAN dla dostawcy usług bez względu na metodę
          dostępu lub rodzaj obciążenia. MPLS, może obsługiwać różne metody
          dostępu klienta - czy łączy się przez <em>Ethernet</em>, czy za 
          pomocą kabla koncentrycznego. MPLS może enkapsulować wszystkie typy
          protokołów w tym IPv4 czy IPv6. Obecnie MPLS jest najczęściej
          stosowanym protokółem warstwy 2 w sieciach rozległych.
        </p>
        <h2 id="3.7.3.internetconnections">3.7.3. Łączność internetowa</h2>
        <p>
          Sieci WAN, napewno większości będą kojarzyć się z połączeniem z
          siecią Internet i jest w większości przypadków dobra myśl. Ponieważ
          jak wcześniej wspominaliśmy, nawet duże przedsiębiorstwa rzadko
          decydują się na ustanowienie prywatnej sieci WAN, przez jednego z
          operatorów. Najczęściej wykorzystują oni sieć publiczną -
          współdzieloną z innymi abonentami, już nie koniecznie biznesowymi.
          Zapewniając tym samym łączność miedzy np. oddziałami firmy wraz z 
          dostępem do Internetu.
        </p>
        <p>
          Technologie łączności internetowej możemy podzielić na przewodowe
          oraz bezprzewodowe. Do sieci przewodowowych możemy zaliczyć
          technologię takie jak:
        </p>
        <p>
          <strong>DSL</strong> jest wykorzystaniem linii telefonicznej dla
          połączeń szerokopasmowych. Technologia ta wykorzystuje nieużwane
          przez rozmowy telefoniczne przestrzeń częstotliwości. Istnieje
          kilka jej odmian oferujących różne przepustowości. Odmiana ADSL - 
          asymetryczny DSL - wykorzystuje węższy zakres częstotliwości dla
          wysłania danych i szerszy dla ich pobierania, co przełoży się
          na różnice w przepustowości łącza w tych kierunkach transmisji.
          Poza częstotliwością na szybkość DSL wpływa długość pętli
          lokalnej, rodzja użytego kabla oraz jego stan. Dla odmiany ADSL,
          długość pętli lokalnej możemy wynosić maksymalnie 5,46 km. Poza 
          ADSL, istnieje kilka wersji takich jak, ADSL2+ czy SDSL -
          symetryczny DSL. Modemy DSL-owe, konwertują sygnał
          <em>Ethernet</em>-u na sygnał DSL, który jest przesyłany do
          urządzenia DSLAM i tam jest rodzielany na połaczenie telefoniczne
          oraz połącznie internetowe. W przypadku DSL każdy abonent ma
          oddzielne połącznie z DSLAM, który znajduje się w CO operatora,
          więc ilość użytkowników nie ma wpływu na jego obciążenie, tak jak 
          w przypadku połączenia kablowego. 
        </p>
        <p>
          Technlogia DSL dla warstwy drugiej używa protokołu PPP, mimo że jest
          on przestarzały to zapewnia następujące czynniki, które z poziomu
          usługodawcy mogą być dość istotne:
        </p>
        <ul>
          <li>Protokół PPP może zapewnić uwierzytelnianie abonenta.</li>
          <li>PPP może przypisać adres publiczny IP.</li>
          <li>PPP zapewnia zarządzanie jakością łączy.</li>
        </ul>
        <p>
          Modemy mają złącza DSL do podłączenia linii telefonicznej oraz 
          <em>Ethernet</em>
          do podłączenia routera lub hosta. Ethernet nie wspiera PPP i wówczas
          należy wdrożyć taką metodę jak <strong>PPPoE</strong>. Host z
          uruchomionym klientem PPPoE, enkapsuluje ramkę PPP w ramce
          <em>Ethernet</em> i wysyła ją do modemu. Modem denkapsuluje ramkę
          PPP z ramki Ethernet i przesyłą ją do usługodawcy za pomocą sygnałów
          DSL. Jedną z metod wdrożenia PPPoE jest albo uruchomienie klienta na
          hosie, wówczas jego interfejs zostanie zaadresowany za pomocą
          publicznego adresu IP. Drugim wariantem jest uruchomienie routera
          z funkcją PPPoE. Wówczas hosty komunikują się z nim w taki sam sposób
          jak z innym urządzeniem. Router zajmuję się już obsługą PPPoE.
        </p>
        <p>
          <strong>Technologia kablowa</strong>, jest sposobem na uzyskanie
          dostępu do Internetu przy użyciu kabla koncentrycznego. Nowoczesne
          systemy technologi kablowej konwergują usługi dostarczając do
          domostw Internet, telewizję oraz telefonię. Technologie kablowe
          opisuje standard <strong>DOCSIS</strong> obecnie w wersji 3, 
          pozwalającej na stosowanie HFC. Jest to topologia hybrydowa
          pozwalającą wykorzystanie połączenia światłowodowego pomiędzy np.
          budynkiem wielorodzinnym, a CO operatora. Umożliwia ona
          przepustowości nawet powyżej 1Gb/s.
        </p>
        <p>
          W przypadku wyboru <strong>światłowodu</strong> jako metody na
          dostęp do Internetu, 
          będzie mieć doczynienia z technologiami <em>Fiber to the</em> i do
          wyboru możemy mieć:
        </p>
        <ul>
          <li><strong>Fiber to the Home (FTTH)</strong> - najpopularniejsza
            opcja. Operator podłącza nam światłowód w mieszkaniu, wówczas
            naszym DCE może być konwerter optyczny, pozwalający podłączyć się
            do sieci światłowodowej zwykłą skrętką.</li>
          <li><strong>Fiber to the Building (FTTB)</strong> - światłowód do
            budynku, np. do bloku (domu wielorodzinnego).</li>
          <li><strong>Fiber to the Node/Neighborhood (FTTN)</strong> -
            światłowód do węzła optycznego na osiedlu.</li>
        </ul>
        <p>
          Obecnie stosowane technologie dostępu do szerokopasmowego Internetu,
          zapewniają dostęp do niego bez potrzeby przeciągania żadnych kabli.
          Do wyboru bowiem mamy <strong>technologie bezprzewodowe</strong>, 
          spośród, których możemy wyróżnić:
        </p>
        <ul>
          <li><strong>Miejska sieć bezprzewodowa</strong> - pozwala na 
            uzyskanie dostępu do 
            Internetu z wykorzystaniem takich samych technologii, jak WLAN.
            Wymaga jednak zakupu anten kierunkowych.</li>
          <li><strong>Sieć komórkowa</strong> - wykorzystanie sieci komórkowej
            jest wstanie zapewnić szybki dostęp do Internetu. W tym przypadku
            wymagany jest zakup routera ze specjalnym modemem, do którego
            wkładana jest karta SIM. Sieć LTE (4 generacji) oraz 5 generacji 
            (tzw. 5G)
            mogą osiągać przepustowości rzędu setek megabitów na sekundę. 
            Taki bezprzewodowy światłowód.</li>
          <li><strong>Dostęp satelitarny</strong> - drogi oraz nie zbyt szybki
            dostęp do sieci Internet. Zaletą tej technologii jest to, że
            zadziała w każdym możlwiwym miejscu na ziemi.</li>
        </ul>
        <p>
          Rozpatrując wybór technologii dostępu do Internetu, musimy również
          zadbać o bezpieczeństwo naszych połączeń. Należy pamiętać, że 
          współdzielimy sieć operatora wraz z innymi abonentami.
          Jeśli pracownicy naszej
          firmy będą pracować zdalnie, muszą mieć zapewnione bezpieczne
          połączenie. I jednym punktem wejścia do firmowej sieci powinny być
          wirtualne sieci prytwane - <strong>VPN</strong>. Sieci tego typu
          są alternatywą dla drogich lączy dzierżawionych, ponieważ mogą
          wirtualnie zapewniać połączenie punkt-punkt. Sieci VPN zazwyczaj
          szyfrują swój ruch. Chociaż istnieją rodzaje tuneli (połączenia,
          wewnątrz innego połączenia), które formalnie
          są VPN, ale nie zapewniają tej warstwy szyfrowania. Korzyści jakie
          płyną ze stosowania VPN to:
        </p>
        <ul>
          <li><strong>Oszczędność wydatków</strong></li>
          <li><strong>Bezpieczeństwo</strong></li>
          <li><strong>Skalowalność</strong></li>
          <li><strong>Kompatybilność z technologiami szerokopasmowymi</strong>
        </ul>
        <p>
          Do zaimplementowania będziemy mieć dwa podejścia, w zależności od
          naszych potrzeb. Jeśli będziemy łączyć oddziały w firmie, to 
          wybierzemy podejscie <strong>Site-to-site</strong>, gdzie tunel
          rozpoczyna się i kończy na routerach. Klienci nie są swiadomi tego,
          że ich ruch jest tunelowany (pakiety IP, są przesyłane wewnątrz innej
          transmisji IP). Drugim podejściem jest <strong>dostęp zdalny</strong>
          gdzie np. pracownicy pracują zdalnie i powinni korzystać z tunelu
          w trakcie pracy lub w momencie gdy potrzebują dostępu do konkretnego
          zasobu w sieci firmowej. Tunel wówczas jest zestawiany pomiędzy
          routerem a urządzeniem docelowym - laptopem pracownika.
        <p>
        <p>
          Oczywiście musimy miec na uwadze fakt, że mogą zdarzyć się takie
          sytuacje, że nasz operator może mieć awarie i nasi pracownicy zdalni
          nie są wstanie podłączyć dokońca tunelu VPN. Taka sytuacja będzie
          mieć miejsce, w momencie nasze połączenie z usługodawcą jest 
          w trybie <em>single-homed</em> - oznacza ono jedno łącze do
          usługodawcy, rozwiązaniem tego może być tryb <em>dual-homed</em>,
          który wprowadza nadmiarowość w łączach do operatora. Jednak w naszym
          przypadku to usługodawca jest kiepski i nonstop ma jakieś mniejsze
          lub większe awarie. Wówczas pozostaje nam zakupić łączne od kolejnego
          usługodawcy. Takie podejście nazywamy <strong>multihomed</strong>,
          a jeszcze lepiej by było, abyśmy mieli po dwa łącza do każdego z nich
          - <strong>dual-multihomed</strong>.
        </p>
        <h2 id="3.7.summary">Podsumowanie</h2>
        <p>
          W tym rodziale zapoznaliśmy się z technologiami sieci rozległych.
          Ich działaniem oraz cechami charakterystycznymi poszczególnych ich
          rodzajów. Na koniec poznaliśmy popularne rodzaje łączności
          szerokopasmowych zapewniających dostęp do Intenetu. Wspomniane
          zostały także sieci VPN.
        </p>
        <h1 id="3.8.vpnandipseconcepts">3.8. Koncepcje VPN oraz IPSec</h1>
        <p>
          Wirtualne sieci prywatne <strong>VPN</strong> są obecnie standardem
          zapewnienia bezpiecznego zdalnego dostępu do zasobów przedsiębiorstw.
          Sieci te wykorzystują publiczną infrastrukturę do przesyłania
          szyfrowanych danych.
        </p>
        <p>
          Jeśli mówimy o sieciach VPN, często mamy namyśli szyfrowany tunel.
          Istnieje wyjątek od tej reguły. Protokół GRE firmy Cisco jest zwykłym
          tunelem sieci IP, nie zapewnia warstwy szyfrowania, służy do
          enkapsulowania protokołów IPv4 i IPv6 tworząc tym samym wirtualny
          tunel punkt-punkt.
        </p>
        <p>
          W przypadku technologii VPN firmy najczęściej same zajmują się
          jej wdrażaniem wśród pracowników czy między oddziałami firmy, wówczas
          do wyboru dla połączeń lokacja-lokacja mamy takie rozwiązania jak:
        </p>
        <ul>
          <li>IPSec VPN</li>
          <li>GRE przez IPSec</li>
          <li>Cisco Dynamic Multipoint Virtual Private Network (DMVPN)</li>
          <li>Interfejs wirtualnego tunelu IPsec (VTI)</li>
        </ul>
        <p>
          Dla połączeń zdalnego dostępu możemy skorzystać z takich rozwiązań
          jak:
        </p>
        <ul>
          <li>Połączenie IPSec oparte na kliencie.</li>
          <li>Bezklientowe połączenie SSL.</li>
        </ul>
        <p>
          Jeśli firma nie posiada odpowiedniego personelu, który mógłby
          wdrożyć usługi VPN może wówczas skorzystać z usług VPN oferowanych
          przez usługowdawcę. Tego rodzaju sieci VPN operają się o
          protokół MPLS rozszerzając jego działanie na warstwę trzecią.
        </p>
        <h2 id="3.8.2.vpntypes">3.8.2. Rodzaje sieci VPN</h2>
        <p>
          W przypadku zdalnego dostępu, mamy dwie opcje - możemy skorzystać
          z przeglądarki (uwierzytelniając się na specjalnie przygotowanej do 
          tego stronie) zabezpieczając połączenie przy użyciu SSL. Wówczas
          mówimy o <strong>połączeniu VPN bez klienta</strong>, połączenia
          wychodzące z przeglądarki są zabezpieczone tego typu tunelem. Ten
          tunel działa tylko i wyłącznie dla protokołów obsługiwanych z
          przez przeglądarki.
        </p>
        <p>
          Innym rodzajem zdalnego dostępu jest użycie klienta VPN, w przypadku
          Cisco jest to program <em>Any Connect Secure Mobilty</em>.
          Użytkownicy muszą zainicjować połączenie VPN i uwierzytelnić się
          w bramie sieci VPN. Ruch uwierzytelnionych pracowników może być
          kierowany do sieci firmowej w celu uzyskania dostępu do jej zasobów.
          Oczywiście wszystko zależy od ustawionych tras. Oprogramowanie
          klienta szyfruje ruch za pomocą protokołów IPSec lub SSL.
        </p>
        <p>
          Połączenie VPN przy użyciu SSL ma dość duże ograniczenia - jest więc
          dość rzadko stosowane. Tunele służące do dostępu zdalnego są
          najczęściej realizowane przy użyciu klienta VPN z wykorzystaniem
          szyfrowania IPSec.
        </p>
        <p>
          Połączenia między routerami, a co za tym idzie między lokalizacjami,
          wykorzystują szyfrowanie IPSec. Tego rodzaju połączenia VPN są
          transparentne, użytkownicy sieci lokalnych nawet nie wiedzą, że ich
          połączenia są szyfrowane i przekazywane przez tunel, w siedzibie
          firmy brama VPN usuwa nagłówki, następnie deszyfruje i przekazuje
          pakiet do sieci wewnętrznej.  
        </p>
        <p>
          Wadą połączeń VPN z wykorzystaniem szyfrowania IPSec jest zdolność
          jedynie do przenoszenia ruchu <em>unicast</em>-wego. Taka zależność
          powoduje, że protokoły routingu wykorzystujące adresy
          <em>multicast</em> nie bedą mogły działać przez tunel. Rozwiązaniem
          tego problemu jest wspomniany już wcześniej protokół GRE, choć tutaj
          wadą tego protokołu jest brak warstwy bezpieczeństwa. Nie mniej
          jednak możliwe jest umieszczenie wewnatrz tunelu IPSec danych
          tunelu GRE. W tej technice używa się nazewnictwa
          <strong>protokołu transportowego</strong> - protokołu faktycznie
          używanego do przekazania pakietów,
          <strong>protokół przewoźnika</strong> - protokół używany do noszenia
          oryginalnego protokołu, w tym przypadku jest GRE oraz
          <strong>protokół pasażera</strong> - protokół faktycznie niosący
          dane, w przypadku protokołów routingu może to byc OSPF.
        </p>
        <p>
          Połączenia lokacja-lokacja sprawdzają się w przypadku gdy oddziałów
          jest kilka. Ponieważ bramy VPN oddziałów wymagały statycznej
          konfiguracji każdego innego oddziału lub oddziału centralnego.
          Rozwiązaniem tego ograniczenia może być użycie technlogii DMVPN,
          która działa w technologii <em>Hub-and-spoke</em>. Lokalizacje
          są konifigurowane przy użyciu wielopunktowej enkapsulacji generycznej
          routingu (mGRE), wiec dodanie nowej lokalizacji wykorzysta tę
          samą konfigurację. Natomiast bramy VPN w poszczególnych oddziałach
          mogą wykorzystać informacje z lokalizacji centralnej do ustanowienia
          tuneli VPN pomiędzy sobą. Technologia DMVPN wykorzystuje tunel
          IPSec.
        </p>
        <p>
          Innym uproszczeniem procesu konfigracji obsługi wielu lokalizacji i
          zdalnego dostępu jest <strong>VTI</strong> - interfejs wirtualnego
          tunelu IPsec. IPSec VTI może wysyłać i odbierać zaszyfrowanych ruch
          zarówno <em>unicast</em> IP jak i <em>multicast</em> dzięki czemu
          protokoły routingu są obsługiwane automatycznie i nie ma potrzeby
          stosowania GRE.
        </p>
        <p>
          Dostawcy usług MPLS mogą zapewnić klientom zarządzane rozwiązanie
          VPN, wówczas za zabezpieczenie ruchu odpowiadać będzie dostawca.
          Istnieją dwa rodzaje rozwiązań MPLS VPN:
        </p>
        <ul>
          <li><strong>MPLS VPN Warstwy 3</strong> - dostawca usług uczestniczy
            w kierowaniu klientów przez ustanowienie komunikacji równorzędnej
            między ruterami klienta i routerami dostawcy.</li>
          <li><strong>MPLS VPN Warstwy 2</strong> - usługodawca nie jest 
            zanagażowany w routing klienta. Zamiast tego dostawca wdraża
            usługę wirtualnej prywatnej sieci LAN (VPLS), aby emulować
            wielodostępny segment sieci LAN Ethernet w sieci MPLS.
            Routery klienta należą wówczas do tej samej sieci wielodostępowej.
          </li>
        </ul>
        <h2 id="3.8.2.ipsec">3.8.2. IPsec</h2>
        <p>
          <strong>IPsec</strong> to standard definiuje sposób zabezpieczenia
          VPN w sieciach IP. IPsec chroni i uwierzytelnia pakiety IP między
          źródłem a miejscem docelowym.
        </p>
        <p>
          IPsec zapewnia następujące podstawowe funkcje bezpieczeństwa:
        </p>
        <ul>
          <li><strong>Poufność</strong> - IPsec wykorzystuje algorytmy
            szyfrowania, aby uniemożliwić cyberprzestępcom odczytanie 
            zawartości pakietu.</li>
          <li><strong>Integralność</strong> - IPsec używa algorytmów mieszania,
            aby zapewnić, że pakiety nie zostały zmienione między źródłem a
            miejsce docelowym.</li>
          <li><strong>Uwierzytelnianie pochodzenia</strong> - IPsec używa
            protokołu <strong>Internet Key Exchange</strong> do
            uwierzytelnienia źródła i miejsca docelowego. Metody
            uwierzytelniania, w tym korzystanie z klucz wstępnych (haseł),
            certyfikatów cyfrowych lub certyfikatów RSA.</li>
          <li><strong>Algorytm Diffie-Hellman</strong> - Bezpieczna wymiana
            kluczy, wykorzystując różne grupy algorytmu DH.</li>
        </ul>
        <p>
          IPsec składa się z pięciu różnych funkcji zabezpieczeń:
        </p>
        <ul>
          <li><strong>Protokołu IPsec</strong> - tutaj mamy do wyboru: nagłówek
            uwierzytelniania (AH), <em>Encapsulation Securty Protocol</em>
            (ESP). AH uwierzytelnia pakiety warstwy 3, a ESP je szyfruje.
            Kombinacja ESP+AH jest rzadko używana, gdyż nie jest w stanie
            przejść przez NAT.</li>
          <li><strong>Poufność</strong> - szyfrowanie zapewnia poufność pakietu
            w.3. Do wyboru mamy DES, 3DES, AES oraz SEAL.</li>
          <li><strong>Integralność</strong> - zapewnia, że dane dotrą w
            niezmienionej postaci do miejsca docelowego za pomocą algorytmu
            haszującego, takiego jak MD5 lub wariant SHA (SHA-256).</li>
          <li><strong>Uwierzytelniania</strong> - Protokół IPsec używa usługi
            Internet Key Exchange (IKE) do uwierzytelnienia użytkowników i
            urządzeń, które mogą prowadzić komunikację niezależnie. IKE 
            używa kilku rodzajów uwierzytelnienia w tym nazwa użytkownika,
            hasło, jednorazowe hasło, dane biometryczne, klucze wstępne (PSKs)
            oraz certyfikaty RSA.</li>
          <li><strong>Diffie-Hellman</strong> - Protokół IPsec używa algorytmu
            DH w celu udostępnienia metody wymiany klucz publicznych dla
            dwóch peerów w celu ustanowienia wspolnego tajnego klucza.
            Isnieje kila różnych grup do wyboru, w tym DH14, 15, 16 i DH 19, 20,
            21 i 24. DH1, 2 i 5 nie są już zalecane.</li>
        </ul>
        <p>
          Skojarzenia zabezpieczeń - SA, są podstawowym element składowym
          protokołu IPsec. Podczas ustanawiania łącza VPN, urządzenia peerów
          muszą wynegocjowawać powyższe parametry, aby mieć zgodne SA. Jeśli
          paramety zostaną ustalone wówczas dochodzi do zestawienia tunelu.
        </p>
        <h2 id="3.8.summary">3.8. Podsumowanie</h2>
        <p>
          W tym rozdziale zapoznaliśmy się z koncepcjami VPN dowiedzialiśmy
          się czym są tak naprawdę wirtualne sieci prywatne. Omówiliśmy ich
          rodzaje, w których to używa się protokołu IPsec, który zapewnia
          bezpieczeństwo transmisji pakietów w.3. Standard ten tutaj również
          został omówiony. Poznaliśmy kilka dodatkowych technologii,
          pozwalających lepsze zarządzanie wieloma tunelami typu 
          lokacja-lokacja.
        </p>
        <h1 id="3.9.qosconcepts">3.9. Koncepcje QoS</h1>
        <p>
          Obecnie w sieciach występuje duże natężenie różnorakiego ruchu. Nowe
          rodzaje komunikatorów, zamiast wysyłania wyłącznie wiadomości
          tekstowych pozwalają na komunikację głosową czy transmisję wideo.
          Tego rodzaju transmisje zarówno dźwieku jak i obrazu w czasie
          rzeczywistym wymagają lepszych warunków sieciowych.
        </p>
        </p>
          Niestety często jest tak, że wiele linii komunikacjnych gromadzi się
          pojedynczym urządzeniu, takim jak np. router. Takie ilości danych
          są następnie przesyłane przez kilka mniejszych łączy lub jedno łącze
          o niskiej przepustowości. Takie obchodzenie się z pakietami 
          doprowadza najcześciej do <strong>zatorów</strong>. Jest to stan, w
          którym wydłuża się czas oczekiwania na informacje przesyłane przez
          sieć. Innym czynnikiem powodującym zatory jest transmisja dużych 
          pakietów, która uniemożliwia dostęp do pasma tym mniejszym.
        </p>
        <p>
          Jeśli nie można przesłać, pewnych informacji ze względu na duże
          natężenie ruchu, pakiety te są kolejkowane w pamięci operacyjnej
          urządzeń, w oczekiwaniu na zwolnienie się łącza i swoją kolej do
          do przesłania. Oczywiście do urządzenia mogłą napływać dalsze
          transmisje tego rodzaju, czego urządzenie nie będzie mogło
          zmieścić, zostanie poprostu odrzucone.
          Takie zachowanie generuje opóźnienia we właściwej
          transmisji z aplikacji do aplikacji. Rozwiązanie tego typu problemu
          może być <strong>klasyfikowanie ruchu</strong>.
        </p>
        <p>
          Router na podstawie różnych parametrów, może utworzyć dla całego
          ruchu kilka odrębnych kolejek i przesyłać ten ruch do hostów na
          podstawie przydzielonego kolejkom priorytetu.
        </p>
        <p>
          Wraz z klasyfikacją ruchu sieciowego używa się kilku terminów,
          których wyjaśnienie znajduje się poniżej:
        </p>
        <ul>
          <li><strong>Przepustowość</strong> - liczba bitów, którą można
            przesłać w ciągu jednej sekundy. Innym określenie z jakim możemy
            się spotkać jest <strong>szerokość pasma</strong>.</li>
          <li><strong>Opoźnienie</strong> - jest to czas z jakim podróżuje
            pakiet od źródła do miejsca docelowego. Istnieją dwa rodzaje
            opóźnienia. Opóźnienie stałe (o stałej wartości czasu) oraz
            zmienne, którego czas może być nie dokońca określony. Opóźnienie
            zmienne, może mieć wpływ na takie czynniki ilość przysyłanego
            ruchu.</li>
          <li><strong>Jitter</strong> - jest to potoczna nazwa dla zmiennego
            opóźnienia. Pakiety w komunikacji sieciowej są przesyłane w
            równych odstępach. Jednak przeciążenie sieci,
            niewłaściwe kolejkowanie czy błędy w konfiguracji mogą doprowadzić
            zmiennej długości odstępów między pakietami.</li>
        </ul>
        <p>
          Spośród źródeł opoźnienia możemy wyróżnić sobie takie czynniki jak:
        </p>
        <ul>
          <li><strong>Opóźnienie kodu</strong> - stała ilość czasu potrzebna
            do skompresowania danych przed wysłanie i wysłaniem jej do
            pierwszego urządzenia.</li>
          <li><strong>Opóźnienie pakietowania</strong> - Stały czas potrzebny
            do enkapsulacji pakietu ze wszystkimi niezbędnymi informacjami w
            nagłówkach.</li>
          <li><strong>Opóźnienie kolejkowania</strong> - zmienna ilość czasu,
            w której pakiet lub ramka czeka na przesłanie na łączu.</li>
          <li><strong>Opóźnienie serializcji</strong> - stała ilość czasu
            potrzebna na przesłanie ramki przez okablowanie.</li>
          <li><strong>Opóźnienie propagacji</strong> - zmienne ilość czasu
            potrzebna na przejście ramki od nadawcy do odbiorcy.</li>
          <li><strong>Opóźnienie eliminacji jittera</strong> - Stała ilość
            czasu potrzebna na zbuforowanie przełpływu pakietów, a
            następnie przesłanie ich w równych odstępach.</li>
        </ul>
        <p>
          Powyższe aspekty transmisji danych, są częścią mechamizmów
          zapewniających jakość usług - <strong>QoS</strong> w sieciach IP.
        </p>
        <p>
          W wyniku przeciążenia urządzenia może ono zacząć odrzucać pakiety.
          Bez mechaznizmów QoS, pakiety transmisji w czasie rzeczywistym są
          traktowane na równi z transmisją, której dane nie są za bardzo
          wrażliwe na opóźnienia. Utrata pakietów jest bardzo często przyczą
          problemów z jakością głosu w sieci IP. Kodeki obsługujące tego 
          rodzaju ruch posiadają pewną tolerację utraty pakietów bez znacznej
          utraty jakości połączenia. Aby zapewnić czytelność transmisji
          w czasie rzeczywistym, używa się mechanizmów QoS do klasyfikowania
          pakietów pod kątem zerowej utraty pakietów. Często nadaje się tego
          rodzaju transmisjom pierwszeństwo na innymi mniej wrażliwymi na
          utratę pakietów.
        </p>
        <h2 id="3.9.1.specificsofnetworktrafic">3.9.1. Specyfikacja ruchu sieciowego</h2>
        <p>
          Na początku XXI w. w ruchu sieciowym można było zaobserwować takie
          transmisje jak klasyczna transmisja danych oraz transmisje głosowe
          VoIP. Obecenie również dużą częścią ruchu zajmują również transmisje
          wideo, zarówno spotkania przy użyciu komunikatorów jak i telewizja
          wykorzystująca obecnie w dużej mierze sieć Intenet. Te rodzaje
          ruchu mają bardzo specyficzne wymagania odnośnie jakości połączenia.
        </p>
        <p>
          Ruch transmisji głosowej jest bardzo wrażliwy na opóźnienia oraz na
          utracone pakiety. Retransmisje w tym przypadku nie mają sensu,
          dlatego też ruch tego rodzaju musi mieć wyższy priorytet niż ruch
          innego rodzaju. Transmisje głosowe dopuszczają poźnienie do 150 ms,
          <em>jitter</em> do 30 ms, strata pakietów do 1% oraz wymaganie
          przepustowości od 30 do 128 Kb/s. Cechami charakterystycznymi tego
          ruchu są: płynność, łagodność, wrażliwość na opoźnienia i przerwania
          oraz preferencja transmisji UDP nad TCP.
        </p>
        <p>
          W przypadku ruchu wideo jest on bardziej niespójny i nieprzewidywalny
          w porównaniu do ruchu głosowego. W zależności od dynamiki
          wyświetlanych treści ruch ten może przesłać znacznie więcej danych 
          tym samym odcinku czasu. Podobnie do ruchu głosowego, ruch ten jest
          wrażliwy na warunki sieciowe, ale nie aż tak bardzo jak ruch głosowy.
          Ruch wideo również powinien posiadać zwiększony priorytet, kosztem
          ruchu mniej wrażliwego na zakłócenia - takiego jak ruch danych.
          W przeciwnym wypadku transmisje czy strumienie wideo mogą być 
          niezdatne do oglądania. Transmisje wideo dopuszczają opoźnienia na
          poziomie do 200 - 400 ms. <em>Jitter</em> do 30-50 ms, stratę
          pakietów na poziomie od 0,1% do 1% oraz minimalną przepustowość na
          poziomie od 384 Kb/s do 20 Mb/s. Cechy charakterystyczne dla ruchu
          wideo to: gwałtowność, zachłanność, wrażliwość na przerwania i
          opóźnienia oraz wybór UDP nad TCP.
        </p>
        <p>
          W przypadku transmisji danych aplikacje wykorzystują protokoły UDP
          oraz TCP. Gdy aplikacja nie toleruje błędów, wybrany zostanie
          protokoł TCP nad UDP, gdyż dokonuje on korekcji błędów przez
          retransmisje. Ruch danych może być płynny lub gwałtowny, ale
          zazwyczaj jest płynny i przewidywalny. Przypadku ruchu danych to
          niektóre aplikacje TCP mogą wykorzystać tyle przepustowości ile da
          się uzyskać. Ruch danych jest stosunkowo niewrażliwy na spadki i
          opóźnienia w porównaniu z ruchem wideo czy głosowym, to przy
          ustalaniu priorytetów, należy wziąć po uwagę doświadczenia
          użytkowników - istnieją dwa kryteria:
        </p>
        <ul>
          <li>Czy dane podchodzą z aplikacji interaktywnej?</li>
          <li>Czy dane są krytyczne?</li>
        </ul>
        <p>
          Jeśli aplikacja jest interaktywa, a dane są krytyczne to należy
          ustawić priorytet dla ruchu tej aplikacji aby uzyskać opoźnienia
          mieszczące się w granicach ludzkiego czasu reakcji. Około 1 do 2s.
          Jeśli na dane nie są krytyczne do aplikację zyskają na większym
          priorytecie/mniejszym opoźnieniu.
        </p>
        <p>
          Jeśli aplikacja jest nie interaktywna, a dane są krytyczne to
          opóźnienie może znacznie się różnić, o ile zostanie zapewniona
          minimalna przepustowość. Jeśli dane są nie krytyczne, aplikacja może
          pobrać dla siebie pozostałą część przepustowości związaną z obsługą
          głosu, wideo oraz innych danych. 
        </p>
        <h2 id="3.9.2.queingalgorithms">3.9.2. Algorytm kolejkowania</h2>
        <p>
          Do implementacji jakości usług potrzebne są algorytmy kolejkowania.
          Te mechanizmy stają się aktywne gdy na łączu występuję przeciążenie.
          Kolejkowanie jest narzędziem do zarządzania ograniczeniami, które
          można buforować ustalać priorytety i ewentualnie, jeśli to konieczne
          zmieniać kolejność pakietów przed przesłaniem ich do miejsca
          docelowego. Do wyboru mamy takie algorytmy jak:
        </p>
        <ul>
          <li>First In First Out (FIFO)</li>
          <li>Ważone uczciwe kolejkowanie (Weighted Fair Queuing - WFQ)</li>
          <li>Uczciwe kolejkowanie oparte na klasach (Class-Based Weighted Fair
            Queuing - CBWFQ.</li>
          <li>Kolejkowanie o niskim opoźnieniu (Low Latency Queuing - LLQ).</li>
        </ul>
        <p>
          Pierwszą kolejką jest <strong>FIFO</strong>. Jest to najprostszy
          model kolejki, przekazuje on pakiety dalej w kolejności ich 
          przybycia. Kolejka tego typu nie rozpoznaje ani priorytetów, ani
          klas ruchu. Ta kolejka może dopuścić do utraty pakietów ważnego dla
          nas ruchu. Jeśli nie są wdrożone żadne inne kolejki jest domyślna
          kolejka dla wszystkich interfejsów z wyjątkiem interfejsów
          szeregowych E1 (europejskie łącza dzierżawione).
        </p>
        <p>
          <strong>WFQ</strong> jest zautomatyzowaną metodą planowania,
          zapewniającą uczciwy podział przepustowści dla całego ruchu. WFQ
          stosuje priorytet lub wagi do zidentyfikowania ruchu. WFQ nie
          zezwala na konfiguracji opcji klasyfikacji. WFQ klasyfikuje ruch
          do rozmów lub przepływów, następnie określa ile każdy przepływ ma
          otzymać przepustowości względem innych. WFQ umożliwia nadanie
          niewielkiemu interaktywnemu ruchowi typu SSH lub ruch głosowy
          pierszeństwa w stostunku do dużego ruchu takiego jak FTP. WFQ
          opiera swoje klasyfikacje na adresacji pakietów, adresach MAC, 
          numerach protów, protokołach oraz wartości pola typu usługi (ToS) w
          nagłówku IPv4. Przy ruchu o niskiej przepustowości otrzymają
          usługę preferencyjną, która pozwoli na terminowe przesłanie całego
          ładunku transmisji. Wiekszy ruch jest dzielony proporcjonalnie
          między pozostałą przepustowość. WFQ nie jest obsługiwana przez
          funkcje tunelowania oraz szyfrowania, ponieważ te funkcje modyfikują
          informacje o zawartości pakietów wymaganej przez WFQ do klasyfikacji.
          Mechanizm ten również trochę mniej precyzyjnie zapewnia kontrolę
          nad alokacją pasma.
        </p>
        <p>
          <strong>CBWFQ</strong> rozszerza standardową funkcjonalność WFQ
          zapewniając obsługę klas ruchu. Za pomoca CBWQF możemy zdefiniować
          klasy na podstawie dopasowania do protokołów, listy ACL, czy
          interfejsów wejściowych. Klasy są przypisywane według kryteriów
          dopasowania. Definiując klasę określamy jej przepustowość, wagę czy
          maksymalny limit pakietów, zdefiniowana przepustowość jest to
          gwarantowana szerokość pasma dostarczana klasie podczas przeciążenia.
          Chcąc określić klasę, należy również określić limit kolejki dla tej
          klasy, tj. maksymalną liczbę pakietów, które mogą się w niej
          znajdować. Po osiągnięciu tego limitu pakiety każdy pakiet 
          docierający na koniec kolejki (nowy pakiet) będzie porzucany. Ten
          mechanizm nazywa się <strong><em>tail drop</em></strong> - porzucenie
          ogona. <em>Tail drop</em>, traktuje ruch jednakowo i nie rozróżnia
          klas usług.
        </p>
        <p>
          <strong>LLQ</strong> jest funkcja kolejki zapewniająca ścisłe
          kolejkowanie priorytetowe (PQ) dla CBWFQ. Ścisłe PQ zapewnia
          wysłanie pakietów wrażliwych na opoźnienia takich jak transmisja
          głosowa przed pakietami w innych kolejkach. LLQ zapewnia ścisłą
          kolejkę priorytetową dla CBWFQ, zmieniejszając zniekształcenia w
          transmisji głosowej.
        </p>
        <h2 id="3.9.3.qosmodels">3.9.3. Modele QoS</h2>
        <p>
          Istnieją trzy modele QoS, które możemy wdrożyć: 
        </p>
        <ul>
          <li><strong>Model best-effort</strong></li>
          <li><strong>Usługi zintegrowane (IntServ)</strong></li>
          <li><strong>Usługi zróżnicowane (DiffServ)</strong></li>
        </ul>
        <p>
          QoS jest zaimplementowany w sieci przy użyciu <em>IntServ</em> lub 
          <em>DiffServ</em>. Podczas gdy <em>IntServ</em> zapewnia najwyższą
          gwarancję jakości usług jest bardzo zasobochłonny, a zatem nie jest
          łatwo skalowalny. Natomiast <em>DiffServ</em> jest mniej 
          zasobochłonny i bardziej skalowalny. Te dwa podejścia są czasami
          współwdrażane w sieciowych implementacjach QoS.
        </p>
        <p>
          Modele do wdrożenia QoS:
        </p>
        <ul>
          <li><strong>Model best-effort</strong> - To tak naprawdę nie jest
            implementacja, ponieważ QoS nie jest jawnie skonfigurowana. Można
            użyć tej metody gdy jakość usług nie jest wymagana.</li>
          <li><strong>Usługi zintegrowane (IntServ)</strong> - <em>IntServ</em>
            zapewnia bardzo wysoką jakość usług dla pakietów IP z
            gwarantowaną dostawą. Definiuje proces sygnalizacji dla aplikacji w
            celu zasygnalizowania sieci, że wymagają specjalnego QoS przez
            pewien okres i że przepustowość powinna być zarezerewowana.
            <em>IntServ</em> może poważnie ograniczyć skalowalność sieci.</li>
          <li><strong>Usługi zróżnicowane (DiffServ)</strong> -
            <em>DiffServ</em> zapewnia wysoką skalowalność i elastyczność we
            wdrażaniu QoS. Urządzenia sieciowe rozpoznają klasy ruchu i
            zapewniają różne poziomy jakości usług do róznych klas ruchu.</li>
        </ul>
        <h2 id="3.9.4.qosimplementationtechniques">3.9.4. Techniki wdrażania QoS</h2>
        <p>
          Utrata pakietów jest zwykle wynikiem przeciążenia na interfejsie.
          Większość aplikacji korzystających z protokołu TCP spowoduje to 
          spowolnienie, ponieważ TCP automatycznie dostosowuje się do
          przeciążenia sieci. Porzucone segmenty TCP powoduje, że sesje TCP
          zmniejszają rozmiary okien. Niektóre aplikacje nie używają TCP i
          nie obsługują zrzutów. Następujące podejścia mogą zapobiegać spadkom
          w aplikacjach wrażliwych:
        </p>
        <ul>
          <li>Zwiększ pojemność łącza, aby ułatwić lub zapobiec zatłoczeniu.</li>
          <li>Zapewnij wystarczającą przepustowość i zwiększ przestrzeń 
            buforową, aby pomieścić impulsy ruchu z delikatnych przypływów.
            WFQ, CBWFQ i LLQ mogą zagwarantować przepustowość i zapewnić
            priorytetowe przekazywanie do aplikacji wrażliwych.</li>
          <li>Utrata pakietów o niższym priorytecie przed wystąpieniem zatorów
            Cisco IOS QoS zapewniają mechnizmy kolejkowania, takie jak ważone
            losowe wczesne wykrywanie (WRED), które rozpoczynają odrzucanie
            pakietów zanim wystąpi przeciążenie.</li>
        </ul>
        <p>
          Narzędzia do wdrażania QoS:
        </p>
        <ul>
          <li><strong>Narzędzia do klasyfikacji i znakowania</strong> - Sesje
            lub przepływy są analizowane w celu określenia, która klasa ruchu
            jest do nich przydatna. Po określeniu klasy ruchu pakiety są
            oznaczone.</li>
          <li><strong>Narzędzia do unikania zatorów</strong> - Na klasy ruchu
            przydzielane są porcje zasobów sieciowych, zgodnie z zaleceniami
            przez badanie QoS. Zasady QoS określają również, w jaki sposób
            część ruchu może być selektywna utracona, opóźniona lub ponownie
            oznaczona, aby uniknąć zatorów. Głównym narzędziem do unikania
            przeciążenia WRED i służy do regulacji ruchu danych TCP w sposób
            efektywny pod względem przepustowści, za nim wystąpi
            <em>tail drop</em> spowodowane przepełnieniem kolejki.</li>
          <li><strong>Narzędzia do zarządzania zatorami</strong> - Gdy ruch
            przekracza dostępne zasoby sieciowe, jest umieszczany w kolejce
            w oczekiwaniu na dostępność zasobów. Wspólne narzędzia do
            zarządzania ograniczeniami oparte na systemie Cisco IOS obejmują
            CBWFQ i algorytmy LLQ.</li>
        </ul>
        <p>
          Zanim pakiet będzie mógł mieć zastosowaną politykę QoS musi zostać
          sklasyfikowany. Klasyfikacja i znakowanie pozwalają nam identyfikować
          lub <em>oznaczać</em> typy pakietów. Klasyfikacja określa klasę ruchu,
          do której należą pakiety lub ramki. Dopiero po zaznaczeniu ruchu
          można zastosować do niego zasady.
        </p>
        <p>
          Sposób, w jaki pakiet jest klasyfikowany, zależy od implementacji
          jakości usług. Metody klasyfikacji przepływów ruchu na warstwie 2 i
          3 obejmują korzystanie z interfejsów, ACL i map klas. Ruch można
          również klasyfikować w warstwach od 4 do 7 przy użyciu funkcji
          rozpoznawania aplikacji sieciowych (NBAR).
        </p>
        <p>
          Oznakowanie ruchu dla QoS:
        </p>
        <ul>
          <li><strong>Ethenet(802.1Q, 802.1p)</strong> - warstwa: 2, znakowanie
            pola: Klasa usług (CoS), Szerokość w bitach: 3</li>
          <li><strong>802.11 (Wi-Fi)</strong> - warstwa: 2, znakowanie pola:
            Identyfikator ruchu Wi-Fi (TID), szerokość w bitach: 3</li>
          <li><strong>MPLS</strong> - warstwa: 2, znakowanie pola:
            Eksperymentalne (EXP), szerokość w bitach: 3.</li>
          <li><strong>IPv4 i IPv6</strong> - warstwa: 3, znakowanie pola:
            Pierwszeństwo IP (IPP), szerokość w bitach: 3.</li>
          <li><strong>IPv4 i IPv6</strong> - warstwa: 3, znakowanie pola:
            DSCP (<em>Differentiated Services Code Point</em>), Szerokość w
            w bitach: 6.</li>
        </ul>
        <p>
          Standard 802.1Q obejmuje również schemat priotetyzacji QoS znany jako
          IEEE 802.1p. Wykorzystuję on pierwsze trzy bity w polu TCI
          (<em>Tag Control Information</em>), znane jako pole priorytetu
          PRI (<em>Priority</em>), to 3-bitowe pole identyfikuje oznaczenia
          klasy usług (CoS). Trzy bity oznaczają, że ramką Ethernet warstwy 2
          może być oznaczona jednym z ośmiu poziomów priorytetu (wartość 0-7).
        </p>
        <p>
          Wartość klasy usług (CoS) Ethernet:
        </p>
        <ul>
          <li><strong>Wartość CoS: 0</strong> - binarnie: 000, dane best-effort.</li>
          <li><strong>Wartość CoS: 1</strong> - binarnie: 001, dane o średnim
            priorytecie.</li>
          <li><strong>Wartość CoS: 2</strong> - binarnie: 010, dane o wysokim
            priorytecie.</li>
          <li><strong>Wartość CoS: 3</strong> - binarnie: 011, sygnalizacja
            połączeń.</li>
          <li><strong>Wartość CoS: 4</strong> - binarnie: 100, wideokonferencje.</li>
          <li><strong>Wartość CoS: 5</strong> - binarnie: 101, nośnik głosu
            (ruch głosowy).</li>
          <li><strong>Wartość CoS: 6</strong> - binarnie: 110, zarezerwowane.</li>
          <li><strong>Wartość CoS: 7</strong> - binarnie: 111, zarezerwowane.
        </ul>
        <p>
          IPv4 i IPv6 określają 8-bitowe pole w nagłówkach pakietów:
          <em>Type of Service</em> (ToS) dla IPv4 oraz pole
          <em>Trafic Class</em> dla IPv6.
        </p>
        <p>
          Typu usługi (IPv4) i klasa ruchu (IPv6) zawierają oznaczenia
          pakietów przypisane przez narzędzia do klasyfikacji QoS. To pole jest
          następnie okreslane przez urządzenia odbierające, które przekazują
          ruch w oparciu o odpowiednio przypisną politykę jakości usług.
          RFC 2474 zastępujący RFC 791 i na nowo definiuje pole ToS poprzez
          zmianę nazwy i oraz rozszerzenie pola <em>IP Precedence</em> (IPP),
          które wcześniej było używane do oznaczeń QoS - RFC 791. Nowe pole
          na 6-bitów przydzielone do QoS. Nazwane <strong>DSCP</strong>
          (<em>Differentiated Services Code Point</em>) przez długość 6 bitów
          oferuje maksymalnie 64 klasy usług. Pozostałe dwa bity
          <em>IP Extended Congestion Notification</em> (ECN) mogą być używane
          przez routery obsługujące ECN do oznaczanie pakietów zamiast ich
          odrzucania. Oznakowanie ECN informuje urządzenia o występującym
          przeciążęniu w ruchu pakietów.
        </p>
        <p>
          Wartość DSCP są podzielone na trzy kategorie:
        </p>
        <ul>
          <li><strong>Best-effort (BE)</strong> - domyślny tryb dla wszystkich
            pakietów IP. Wartość DSCP wynosi 0. Gdy router doświadczy 
            przeciążenia, pakiety te zostaną usunięte. Nie wdrożono planu QoS.</li>
          <li><strong>Przyspieszone przekazywanie (<em>Expedited 
            Forwarding - EF</em>)</strong> - RFC 3246 definiuje EF jako wartość
            dzięsiętną DSCP 46 (binarna 101110). Pierwsze trzy bity odwzorowują
            bezpośrednio wartość 5 CoS warstwy 2 używaną do ruchu głosowego.
            W warstwie trzeciej zaleca używanie EF tylko do oznaczania pakietów
            głosowych.</li>
          <li><strong>Zapewnione przekazywanie (Assured Forwarding - AF)</strong>
            - RFC 2597 definiuje AF, aby używać 5 najważniejszych bitów DSCP
            do wskazywania kolejek i preferencji utraty pakietów.</li>
        </ul>
        <p>
          Gwarantowane wartości przesyłania. Kolejki posortowane są od
          najlepszej do najgorszej.
        </p>
        <ol>
          <li><strong>Klasa 4</strong> - niski spadek: AF41 (34), średni spadek:
            AF42 (36), wysoki spadek: AF43 (38).</li>
          <li><strong>Klasa 3</strong> - niski spadek: AF31 (26), średni spadek:
            AF32 (28), wysoki spadek: AF33 (30).</li>
          <li><strong>Klasa 2</strong> - niski spadek: AF21 (18), średni spadek:
            AF22 (20), wysoki spadek: AF23 (22).</li>
          <li><strong>Klasa 1</strong> - niski spadek: AF11 (10), średni spadek:
            AF22 (12), wysoki spadek: AF13 (14).</li> 
        </ol>
        <p>
          <strong>AFxy</strong> - wzór jest określony w następujący sposób:
        </p>
        <ul>
          <li>Pierwsze 3 najbardziej znaczące bity są używane do wyznaczania
            klasy. Klasa 4 to najlepsza kolejka, a klasa 1 to najgorsza
            kolejka.</li>
          <li>Czwarty i piąty najbardziej znaczący bit są używane do
            określenia preferencji gubienia pakietów.</li>
          <li>Szósty najbardziej znaczący bit jest ustawiony na zero.</li>
        </ul>
        <p>
          Na przykład AF32 należy do klasy 3 (binarny 011) i ma preferencje
          średniej utraty pakietów (binarny 10). Pełna wartość DSCP wynosi
          28, ponieważ zawiera 6 bit 0 (binarny 011100). 
        </p>
        <p>
          Ponieważ pierwsze 3 bity pola DSCP wskażują klasę, bity te są również
          nazywane bitami selektora klasy (CS). Te 3 bity odwzorwują 
          bezpośrednio 3 bity pola CoS i pola IPP, aby zachować zgodność z
          802.1p i RFC 791.
        </p>
        <p>
          Ruch powinien być klasyfikowany i oznaczony tak blisko źródła, jak
          jest to technicznie i administracyjnie wykonalne. Granicę zaufania
          definiują:
        </p>
        <ol>
          <li>Zaufane punkty końcowe mają możliwość do oznaczania ruchu
            aplikacji do odpowiednich wartości CoS warstwy 2 i/lub DSCP
            warstwy 3. Przykłady zaufanych punktów końcowych obejmują telefony
            IP, bezprzewodowe punkty dostępowe, bramy i systemy 
            wideokonferencyjne, stacje konferencyjne IP i inne.</li>
          <li>Bezpieczne punkty końcowe mogą mieć ruch oznaczony na
            przełączniku warstwy 2.</li>
          <li>Ruch można również oznaczać na przełącznikach/routerach warstwy 3.</li>
        </ol>
        <p>
          Często również dochodzi do ponownego oznaczenia ruchu, np.
          przekładając wartość CoS na IPP lub DSCP.
        </p>
        <p>
          Zarządzanie zatorami obejmuje kolejkowanie i metody planowania, w
          których nadmiarowy ruch jest buforowany lub umieszczany w kolejce
          (a czasami odrzucany), gdy czeka na wysłanie przez interfejs
          wyjściowy. Narzędzia do unikania monitorują obciążenie ruchu
          sieciowego, starając się przewidywać i unikać zatorów we wspólnych
          wąskich gardłach sieci i intersieci, zanim zatory staną się
          problemem. 
        </p>
        <p>
          Niektóre techniki unikania zatorów zapewniają preferencyjne
          traktowanie, w przypadku którego pakiety są odrzucane. Na przykład
          Cisco IOS QoS obejmuje ważone losowe wczesne wykrywanie (WRED) jako
          możliwe rozwiązanie pozwalające uniknąć zatorów. Algorym WRED
          pozwala na unikanie przeciążeń na interfejsach sieciowych,
          zapewniając zarządzania buforami i pozwalając na zmniejszenie lub
          ogranicznie ruchu TCP przed wyczpaniem buforów. Korzystanie z
          WRED pomaga uniknąć spadków i maksymalizuje wykorzystanie sieci i
          wydajność aplikacji opartych na protokole TCP. Nie ma jednak techniki
          unikania zatorów w ruchu opartym na protokole UDP (User Datagram
          Protocol), takim jak ruch głosowy. W przypadku ruchu opartego na
          UDP metody takie jak kolejkowanie i techniki kompresji pomagają
          zmniejszyć, a nawet zapobiec utracie pakietów UDP.
        </p>
        <p>
          Kształtowanie ruchu i kształtowanie polityki to dwa mechanizmy
          zapewniane przez oprogramowanie Cisco IOS QoS w celu zapobiegania
          zatorom. Kształtowanie ruchu zatrzymuje nadmiarowe pakiety w kolejce,
          a następnie planuje nadwyżkę od poźniejszej transmisji w
          odstępach czasu. Wynikiem kształtowania ruchu jest wygładzona 
          szybkość
          przesyłania pakietów. Kształtowanie implikuje istnienie kolejki i
          wystarczające ilości pamięci do buforowania opóźnionych pakietów,
          podczas gdy zasady nie działają. Kształtowanie wymaga funkcji
          planowania dla poźniejszej transmisji wszelkich opóźnionych pakietów.
          Kształtowanie jest koncepcją wychodzącą - pakiety wychodzące do
          interfejsu są umieszczane w kolejce i mogą być kształtowane.
          Natomiast polityka jest stosowan dla ruchu przychodzącego na
          interfejsie. Gdy natężenie ruchu osiągnie skonfigurowaną maksymalną
          szybkość, nadmiar ruchu jest odrzucany (lub oznaczany). Usługi 
          polityki są powszechnie wdrażane przez dostawców usług w celu
          wyegzekwowania wkaźnika informacji o klientach objętych umową (CIR).
          Jednakże dostawca usług może również zezwolić na przepuszczanie przez
          CIR, jeśli sieć usługodawcy nie jest obecnie przeciążona.  
        </p>
        <p>
          Polityka QoS musi uwzględniać pełną ścieżkę od źródła do celu. Jesli
          jedno z urządzeń używa innej zasady niż jest wymagane, może mieć to
          wpływ na całą implementację QoS. Na przykład zacina się podczas
          odtwarzania wideo może być wynikiem jednego przełącznika na ścieżce,
          który nie ma odpowiedniej wartości CoS. Poniżej znajduje się kilka
          wskazówek, które pomgają zapewnić lepsze wrażenia użytkownikom
          końcowym:
        </p>
        <ul>
          <li>Włącz kolejkowanie na każdym urządzeniu na ścieżce między źródłem
            a celem.</li>
          <li>Klasyfikuj i oznaczaj ruch tak blisko źródła jak to możliwe.</li>
          <li>Ukształtowany ruch objęty polityką QoS przepływa jak najbliżej
            swoich źródeł.</li>
        </ul>
        <h2 id="3.9.summary">Podsumowanie</h2>
        <p>
          Na początku zdefiniowaliśmy sobie takie pojęcia jak klasyfikowanie
          ruchu, opoźnienia i <em>jitter</em>. Dowiedzilismy się także czym
          grozi utrata ruchu. Następnie sklasyfikowaliśmy sobie ruch sieciowy,
          poznaliśmy algorytm kolejkowania oraz modele QoS na koniec
          zaznajomiliśmy się z teoretycznymi podstawmi technik wdrażania
          mechnizmu QoS.
        </p>
      <h1 id="3.10.networkmanagement">3.10. Zarządzanie siecią</h1>
      <p>
        Za pomocą protokołu CDP możemy utworzyć mapę sieci. <strong>CDP</strong>
        to zastrzeżony protokół warstwy 2 firmy Cisco, który służy do zbierania
        informacji o urządzeniach Cisco współużytkujących to samo łącze
        danych. Protokół CDP jest niezależny od mediów czy innych protokołów
        działa na wszystkich urządzeniach Cisco, takich jak routery,
        przełączniki czy serwery dostępowe.
      </p>
      <p>
        Urządzenia wysyłają między sobą okresowe ogłoszenia CDP z informacjami
        na temat rodzaju wykrytego urządzenia, jego nazwie oraz typie i ilości
        interfejsów. Protokół ten może pomóc w podejmowaniu decyzji dotyczących
        projektu sieci, rozwiązywaniu problemów czy wprowadzaniu zmian w 
        sprzęcie. Protokół może być również używany jako narzędzie do
        wykrywania sieci w celu określenia informacji i sąsiednich urządzeniach.
        Te informacje mogą pomóc przy tworzeniu logicznej topologii sieci.
      </p>
      <p>
        Protokół CDP jest domyślnie włączony na wszystkich urządzeniach w
        sieci, jednak ze względów bezpieczeństwa może być pożądne jego
        wyłączenie, na niektórych interfejsach bądź globalnie. Może on zdradzać
        cenne informacje jakie adresy IP, wersja Cisco IOS oraz typ urządzenia.
      </p>
      <p>
        Aby zweryfikować stan CDP i wyświetlić informacje o CDP w trybie 
        uprzywilejowanym EXEC wydajemy następujące polecenie:
      </p>
<pre class="code-block">
Router# show cdp
Global CDP information:
      Sending CDP packets every 60 seconds
      Sending a holdtime value of 180 seconds
      Sending CDPv2 advertisements is enabled
</pre>
      <p>
        Aby wyłączyć CDP globalnie dla wszystkich obsługiwanych interfejsów 
        w trybie konfiguracji globalne wydajemy następujące polecenie:
      </p>
<pre class="code-block">
Router(config)# no cdp run
Router(config)# exit
Router# show cdp
CDP is not enabled
</pre>
      <p>
        Natomiast włączenie globalne CDP, odbywa się w tym samym trybie
        przy użyciu następującego polecenia:
      </p>
<pre class="code-block">
Router(config)# cdp run
</pre>
      <p>
        Wyłączenie oraz włączenie CDP dla interfejsów odbywa się w trybie
        konfiguracji interfejsu, poprzez wydanie polecenia
        <code class="code-inline">no cdp enable</code> - dla wyłączenia CDP na
        interfejsie lub <code class="code-inline">cdp enable</code> dla
        włączenia CDP na interfejsie.
      </p>
      <p>
        Aby wyświetlić listę sąsiadów, możemy użyć polecenia
        <code class="code-inline">show cdp neighbors</code> w trybie
        uprzywilejowanym EXEC. CDP zwraca kilka przydanych informacji.
      </p>
<pre class="code-block">
Router#show cdp neighbors
Capability Codes: R - Router, T - Trans Bridge, B - Source Route Bridge
                  S - Switch, H - Host, I - IGMP, r - Repeater, P - Phone
Device ID    Local Intrfce   Holdtme    Capability   Platform    Port ID
Switch       Gig 0/1          146            S       2960        Gig 0/2
</pre>
      <p>
        Za pomocą polecenia <code class="code-inline">show cdp interface</code>
        możemy wyświetlić podsumowanie interfejsów z włączonym CDP.
      </p>
<pre class="code-block">
Router#show cdp interface
Vlan1 is administratively down, line protocol is down
  Sending CDP packets every 60 seconds
  Holdtime is 180 seconds
GigabitEthernet0/0 is administratively down, line protocol is down
  Sending CDP packets every 60 seconds
  Holdtime is 180 seconds
GigabitEthernet0/1 is up, line protocol is up
  Sending CDP packets every 60 seconds
  Holdtime is 180 seconds
</pre>
      <p>
        Polecenie <code class="code-inline">show cdp neighbors</code> zawiera
        przydantne informacje o każdym sąsiednim urządzeniu.
      </p>
<pre class="code-block">
Router#show cdp neighbors
Capability Codes: R - Router, T - Trans Bridge, B - Source Route Bridge
                  S - Switch, H - Host, I - IGMP, r - Repeater, P - Phone
Device ID    Local Intrfce   Holdtme    Capability   Platform    Port ID
Switch       Gig 0/1          146            S       2960        Gig 0/2
</pre>
     <ul>
      <li><strong>Identyfikator urządzenia</strong>
        <code class="code-inline">Device ID</code> - nazwa hosta urządzenia
        sąsiada.</li>
      <li><strong>Identyfikator portu</strong> - jest to nazwa portu lokalnego
        (<code class="code-inline">Local Intrfce</code>) oraz portu zdalnego
        (<code class="code-inline">Port ID</code>).</li>
      <li><strong>Lista możliwości</strong>
        (<code class="code-inline">Capability</code>) - rodzaj urządzenia
        (<code class="code-inline">S</code> - przełącznik).</li>
      <li><strong>Platforma</strong> - 
        <code class="code-inline">Platform</code> - jest to platforma
        urządzenia.</li>
     </ul>
      <h3 id="3.10.pkt">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.1.5-packet-tracer---use-cdp-to-map-a-network_pl-PL.pdf">Użyj CDP do mapowania sieci - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.1.5-packet-tracer---use-cdp-to-map-a-network_pl-PL.pka">Użyj CDP do mapowania sieci - zadanie</a>
      </p>
      <h2 id="3.10.1.lldpdevicediscoveries">3.10.1. Odkrywanie urządzeń z protokołem LLDP</h2>
      <p>
        Protokół LLDP (<em>Link Layer Discovery Protocol</em>) robi to samo co
        CDP, ale jest on protokołem otwartym, dostępnym również na sprzęcie
        Cisco.
      </p>
      <p>
        W zależności od urządzenia LLDP może być domyślnie wyłączone, tak też
        jest w przypadku sprzętu Cisco (preferują swój protokół CDP). Aby
        włączyć protokół LLDP, w trybie konfiguracji globalnej wydajemy
        poniższe polecenie:
      </p>
<pre class="code-block">
Switch(config)#lldp run
</pre>
      <p>
        Protokół LLDP możemy włączyć również niekoniecznie dla całego
        urządzenia, ale dla konkretnych interfejsów. W przeciwieństwie do CDP,
        LLDP na interfejsie musi być skonfigurowany zarówno do odbierania i
        wysyłania pakietów, tak jak na poniższym przykładzie:
      </p>
<pre class="code-block">
Switch(config)# interface gigabitethernet 0/1
Switch(config-if)# lldp transmit
Switch(config-if)# lldp receive
Switch(config-if)# end
</pre>
      <p>
        Za pomocą polecenia <code class="code-inline">show lldp</code> możemy
        sprawdzić stan protokołu na naszym urządzeniu. Natomiast za pomocą
        polecenia <code class="code-inline">show lldp neighbors</code> możemy
        wyświetlić listę wykrytych sąsiadów oraz kilka informacji o nich.
      </p>
<pre class="code-block">
Router#show lldp
Global LLDP Information:
    Status: ACTIVE
    LLDP advertisements are sent every 30 seconds
    LLDP hold time advertised is 120 seconds
    LLDP interface reinitialisation delay is 2 seconds
Router#show lldp neighbors
Capability codes:
    (R) Router, (B) Bridge, (T) Telephone, (C) DOCSIS Cable Device
    (W) WLAN Access Point, (P) Repeater, (S) Station, (O) Other
Device ID           Local Intf     Hold-time  Capability      Port ID
Switch              Gig0/1         120        B               Gig0/2

Total entries displayed: 1
</pre>
      <p>
        LLDP zwraca podobną ilość informacji jak CDP, jedak brakuje tutaj
        informacji o platformie. Przełączniki tutaj są oznaczane jako mosty
        (B - <em>Bridge</em>).
      </p>
      <h3 id="3.10.1.pkt">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.2.6--packet-tracer---use-lldp-to-map-a-network_pl-PL.pdf">Użyj LLDP do mapowania sieci - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.2.6--packet-tracer---use-lldp-to-map-a-network_pl-PL.pka">Użyj LLDP do mapowania sieci - zadanie</a>
      </p>
      <h2 id="3.10.2.ntp">3.10.2. NTP</h2>
      <p>
        Poprawne ustawienie daty i czasu na urządzeniach sieciowych jest ważne
        jeśli korzystamy z usługi dziennika - <em>syslog</em> (omówiony poźniej
        w tym rozdziale). Samą czynność ustawienia bierzącej daty i czasu 
        możemy dokonać na dwa sposóby, albo za pomocą polecenia
        <code class="code-inline">clock set</code> w trybie uprzywilejowanym
        EXEC, albo za pomocą protokołu NTP. Mając wiele urządzeń ciężko sobie
        wyobrazić, że będziemy ręcznie ustawiać wszystkie zegary, dlatego też
        wykorzystamy protokół NTP.
      </p>
      <p>
        Protokół <strong>NTP</strong> umożliwia routerom w sieci synchronizację
        ustawień czasu z serwerem NTP. Klienci wykorzystujący NTP, uzyskują
        informacje o czasie i dacie z jednego źródła i mają bardziej spójne
        ustawienia czasu. Protokół NTP jest zaimplementowany w sieci, mozna
        go skonfigurować tak, aby synchronizował się z prywatnym zegarem
        głównym lub może synchronizować się z publicznie dostępnym serwerem
        NTP w Internecie. NTP używa protokołu UDP na port 123.
      </p>
      <p>
        Protokół NTP jest usługą hierarchiczna, każdy z poziomów nazywany jest
        warstwą lub <em>Stratum</em>, im niższa warstwa czas jest mniej
        dokładny. Warstwa maksymalnie jest 15. Wartstwa 0 zawiera urządzenia
        wystawiające wzrorzec czasu, kiedy przechodzi między warstwami jego
        stan odchyla się stanu rzecywistego (są to wartości, które zwykłym
        ludzią nie robią różnice, ale jednak występują). Warstwa 16 oznacza
        brak synchronizacji z NTP.
      </p>
      <p>
        Konfiguracja serwera NTP na sprzęcie Cisco polega na wydaniu poniższego
        polecenia w trybie konfiguracji globalnej.
      </p>
<pre class="code-block">
R1(config)# ntp server 209.165.200.225
</pre>
      <p>
        Synchronizacje naszego urządzenia z serwerem NTP możemy zweryfikować
        za pomocą poleceń:
      </p>
<pre class="code-block">
R1# show ntp associations   
  address         ref clock       st   when   poll reach  delay  offset   disp
*~209.165.200.225 .GPS.           1     61     64   377  0.481   7.480  4.261
 * sys.peer, # selected, + candidate, - outlyer, x falseticker, ~ configured

R1# show ntp status 
Clock is synchronized, stratum 2, reference is 209.165.200.225
nominal freq is 250.0000 Hz, actual freq is 249.9995 Hz, precision is 2**19
ntp uptime is 589900 (1/100 of seconds), resolution is 4016
reference time is DA088DD3.C4E659D3 (13:21:23.769 CET Mon Dec 09 2024)
clock offset is 7.0883 msec, root delay is 99.77 msec
root dispersion is 13.43 msec, peer dispersion is 2.48 msec
loopfilter state is 'CTRL' (Normal Controlled Loop), drift is 0.000001803 s/s
system poll interval is 64, last update was 169 sec ago.
</pre>
      <p>
        Serwer NTP znajduje się w warstwie 1, swiadczy o tym kolumna
        <code class="code-inline">st</code> zwracana przez polecenie
        <code class="code-inline">show ntp associations</code>. Nasz router,
        zaś w warstwie drugiej, urządzenia Cisco, które są skonfigurowane
        na synchonizację czasu z NTP, automatycznie też stają się serwerami
        tej usługi świadcząc wzorzec czasu na danym poziomie w sieci.
      </p>
      <h3 id="3.10.2.pkt">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.3.4-packet-tracer---configure-and-verify-ntp_pl-PL.pdf">Skonfiguruj i zweryfikuj NTP - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.3.4-packet-tracer---configure-and-verify-ntp_pl-PL.pka">Skonfiguruj i zweryfikuj NTP - zadanie</a>
      </p>
      <h2 id="3.10.3.snmp">3.10.3. SNMP</h2>
      <p>
        <strong>SNMP</strong> został opracowany aby umożliwić administratorom
        zarządzanie wezłami, takimi jak serwery, stacje robocze, routery,
        przełączniki itp. Umożliwia administratorom sieci monitorowanie
        jej wydajności, zarządzanie nią znajdowanie i rozwiązywanie problemów,
        planowanie rozwoju sieci. SNMP jest protokołem warstwy aplikacji,
        zapewniającymi format wiadomości, wykorzystywany w komunikacji pomiędzy
        urządzeniami, tzw. menedżerami a agentami. System SNMP składa się z
        trzech elementów:
      </p>
      <ul>
        <li>Menedżera SNMP</li>
        <li>Agenci SNMP (węzeł zarządzany)</li>
        <li>Baza danych zarządzania (MIB)</li>
      </ul>
      <p>
        Menadżer SNMP jest częścią zarządzania siecią. Uruchamia się na nim
        oprogramowanie do zarządzania SNMP. Może on zbierać informacje od 
        agenta SNMP za pomocą akcji <em>get</em> i zmieniać konfigurację za
        pomocą akcji <em>set</em>. Dodatkowo agenci mogą przekażywać informacje
        bezpośrednio do menedżera sieci za pomocą <em>traps</em> (pułapek).
      </p>
      <p>
        Agent SNMP i baza MIB znajdują się na urządzeniach klienckich SNMP.
        Urządzenia sieciowe wyposażone są w oprogramowanie agenta SNMP. 
        Bazy MIB przechowuje dane o urządzeniu oraz statystyki operacyjne.
        Agent SNMP jest również odpowiedzialny za zapewnienie dostępu do bazy
        MIB. Protokół określa też, w jaki sposób informacje sterujące
        wymieniane są miedzy aplikacjami zarządzającymi siecią a agentami.
        Menedżer SNMP bada agentów i wysyła zapytania dla agentów SNMP na
        porcie UDP 161, agenci wysyłają pułaki do menedzera na porcie 162 UDP.
      </p>
      <p>
        Pułapki (<em>Traps</em>) to komunikaty alarmowe generowane bez żądania,
        informujące menedżera SNMP o stanie sieci i ewentualnych zdarzeniach,
        które wystąpiły. Przykładowo komunikaty <em>trap</em> mogą zawierać
        informacje i nieprawidłowym uwierzytelnieniu, zmianach stanu łączy,
        czy nawet zamknięciach połączeń TCP. Powiadomienia kierowane przez
        pułapki zmniejszają zasoby sieci i agentów, eliminując potrzebę
        niektórych żądań odpytywania SNMP.
      </p>
      <p>
        SNMP istnieje w 3 wersjach. Wersja 1 jest starym roziwązaniem i nie
        jest już często spotykana. W ramach tego kursu zajmiemy się wersjami
        2c oraz 3. Druga wersja zawiera mechamizmy grupowego pobierania i
        szczegółowego raportowania do menedżerów, posiada ona także poprawioną
        obsługę błędów w tym rozszerzone kody błędów. Wersja 1 oraz 2 oferują
        minimalne funkcje bezpieczeństwa, co zostało poprawione z wersją 3
        posiada ona bowiem kilka dodatkowych modeli i poziomów bezpieczeństwa:
      </p>
      <ul>
        <li><strong>SNMPv1</strong> - poziom: <em>NoAuthNoPriv</em>, 
          uwierzytelnianie: <em>community string</em>, szyfrowanie: nie.
          Używa dopasowania <em>community string</em> do uwierzytelniania.</li>
        <li><strong>SNMPv2c</strong> - patrz: SNMPv1.</li>
        <li><strong>SNMPv3 NoAuthNoPriv</strong> - poziom: <em>NoAuthNoPriv</em>
          uwierzytelnianie: nazwa użytkownika, szyfrowanie: nie. Używa 
          dopasowania nazwy użytkownika do uwierzytelnienia (ulepszenie w
          stosunku do SNMPv2c).</li>
        <li><strong>SNMPv3 AuthNoPriv</strong> - poziom: <em>AuthNoPriv</em>,
          uwierzytelnianie: MD5 lub SHA, szyfrowanie: nie. Zapewnia 
          uwierzytelnianie oparte na algorytmach HMAC-MD5 lub HMAC-SHA.</li>
        <li><strong>SNMPv3 AuthPriv</strong> - poziom: AuthPriv (wymaga wersji
          IOS z rozszerzenie kryptograficznym), uwierzytelnianie: MD5 lub SHA,
          Szyfrowanie: DES lub AES. Zapewnia uwierzytelnianie oparte na
          algorytmach HMAC-MD5 lub HMAC-SHA. Umożliwia określenie modelu
          bezpieczeństwa (USM) z algorytmami szyfrowania DES i AES.</li>
      </ul>
      <p>
        Wybór odpowiedniej wersji SNMP wymaga konfiguracji agenta na
        urządzeniu, ponieważ może on komunikować się z wieloma menedżerami
        SNMP, możliwe jest skonfigurowanie oprogramowania do obsługi
        komunikacji przy użyciu protokołu SNMPv1, SNMPv2c lub SNMPv3.
      </p>
      <p>
        W celach uwierzytelniania, protokoły SNMPv1 oraz SNMPv2 wykorzystują
        tzw. <em>community strings</em> - łańcuchy społeczności, które 
        kontrolują dostęp do bazy MIB. Są to hasła zapisane jawnym tekstem.
        Łańcuchy społeczności SNMP uwierzytelniają dostęp do obiektów MIB.
      </p>
      <p>
        Istnieją dwa rodzaje ciągów społeczności:
      </p>
      <ul>
        <li><strong>Tylko do odczytu (ro)</strong> - ten typ zapewnia dostęp do
          zmiennych MIB, ale nie pozwala na ich zmianę.</li>
        <li><strong>Odczyt i zapis (rw)</strong> - ten typ zapewnia możliwość
          odczytania zawartości zmiennych MIB oraz ich modyfikacji.</li>
      </ul>
      <p>
        Zmienne MIB pozwalają oprogramowaniu zarządzającemu na monitorowanie i
        zarządzanie urządzeniami. Zmienne są zorgranizowane w sposób
        hierachiczny. Formalnie, baza MIB definiuje każdą zmienną przy pomocy
        identyfikatora obiektu OID. OID umożliwia unikatową identyfikację
        zarządzanych obiektów w hierarchii MIB. Baza MIB organizuje obiekty
        OID w sposób hierarchiczny, zazwyczaj w postaci drzewa bazujac na
        standardadach RFC. Standardy te definiują wspolne zmienne publiczne.
        Większość urządzeń implementuje te zmienne MIB. Ponadto, producenci
        sprzętu sieciowego, tacy jak Cisco, mogą definiować własne gałęzie
        drzewa i tym sposobem wprowadzać nowe zmienne specyficzne dla swoich
        urządzeń. Identyfikatory należą do Cisco są ponumerowane w następujący
        sposób: .iso(1) .org(3) .dod(6) .internet(1) .private(4) .enterprises(1)
        .cisco(9). Dlatego OID to .1.3.6.1.4.1.9.
      </p>
      <p>
        Chcąc uzyskać jakieś informacje za pomocą SNMP możemy wydać następujące
        polecenie.
      <p>
<pre class="code-inline">
$ snmpget -v2c -c community 10.250.250.14 .1.3.6.1.4.1.9.2.1.58.0
SNMPv2-SMI::enterprises.9.2.1.58.0 = INTEGER: 11
</pre>
      <p>
        To polecenie jest element wieloplatformowego pakiety obsługującego
        protokół SNMP. <code class="code-inline">-v2c</code> - jest wersją
        protokołu SNMP, <code class="code-inline">-c community</code> - jest
        podanie ciągu społeczności, następnie występuje adres oraz numer OID
        pobieranego parametru. Tym parametrem jest 5-minutowa średnia krocząca
        procentu zajętości procesora.
      </p>
      <h3 id="3.10.3.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/lab/10.4.10-lab---research-network-monitoring-software_pl-PL.pdf">Oprogramowanie do monitorowania sieci badawczej</a>
      </p>
      <h2 id="3.10.4.syslog">3.10.4. Syslog</h2>
      <p>
        <strong>Syslog</strong> - standard uzyskiwania dostępu do komunikatów
        systemowych (wpisów dziennika zdarzeń), również pod postacią protokołu
        sieciowego pozwalającego na wysłanie powiadomień do specjalnie
        przygotowanego serwera. <em>Syslog</em> używa portu 514 UDP.
      </p>
      <p>
        Usługi rejestrowania <em>syslog</em> zapewniają trzy podstawowe funkcje
        takie jak:
      </p>
      <ul>
        <li>Możliwość zbierania rejestrowania informacji na potrzeby 
          monitoringu i rozwiązywania problemów.</li>
        <li>Możliwość wyboru rodzaju informacji rejestrowanych, które mają 
          zostać przechwycone.</li>
        <li>Możliwość zdefiniowania odbiorców przechwytywanych informacji
          <em>syslog</em>.</li>
      </ul>
      <p>
        Urządzenie Cisco generują komunikaty <em>syslog</em> w następstwie
        różnych zdarzeń sieciowych. Każdy komunikat <em>syslog</em> zawiera
        obiekt, którego dotyczy oraz stopień ważności. Im niższy numer stopnia
        ważności, tym poważniejszy problem sygnalizowany przez urządzenie.
        Poniżej znajduje się lista poziomów <em>syslog</em>.
      </p>
      <ul>
        <li><strong>Nagła sytuacja</strong> - poziom: <strong>0</strong> - 
          System nie nadaje się do użytku.</li>
        <li><strong>Alarm</strong> - poziom: <strong>1</strong> - Potrzebne
          natychmiastowe działanie.</li>
        <li><strong>Krytyczne</strong> - poziom: <strong>2</strong> - Stan
          krytyczny.</li>
        <li><strong>Błąd</strong> - poziom: <strong>3</strong> - Stan błedu.</li>
        <li><strong>Ostrzeżenie</strong> - poziom: <strong>4</strong> - Stan
          ostrzegawczy.</li>
        <li><strong>Powiadomienie</strong> - poziom: <strong>5</strong> - Stan
          normalny, ale istotny.</li>
        <li><strong>Informacyjny</strong> - poziom: <strong>6</strong> -
          Komunikat informacyjny.</li>
        <li><strong>Debugowanie</strong> - poziom: <strong>7</strong> - 
          Komunikat debug.</li>
      </ul>
      <p>
        Oprócz poziomu ważności, komunikaty <em>syslog</em> zawierają także
        informacje o obiekcie, którego dotyczą. Obiety <em>syslog</em> to
        identyfikator usługi, pozwalającej zidentyfikować i skategoryzować
        dane na temat stanu systemu na potrzeby raportowania błedów i zdarzeń.
        Opcje rejestrowania, dostępne dla danego obiektu są specyficznego dla
        danych urządzeń. Do typowych obiektów syslog, raportowanych w
        komunikatach na routerach z systemem Cisco IOS, należą:
      </p>
      <ul>
        <li>IP</li>
        <li>OSPF</li>
        <li>system operacyjny (SYS)</li>
        <li>Zabezpieczenia na poziomie IP</li>
        <li>Interfejs IP</li>
      </ul>
      <p>
        Domyślny format komunikatów <em>syslog</em> oprogramowania Cisco IOS,
        wygląda następująco:
      </p>
<pre class="code-block">
%facility-severity-MNEMONIC: description 
</pre>
      <p>
        Natomiast przykładowy komunikat z systemu Cisco IOS może wyglądać w
        następujący sposób:
      </p>
<pre class="code-block">
%LINK-3-UPDOWN: Interface Port-channel1, changed state to up
</pre>
      <p>
        Obiektem tutaj jest <code class="code-inline">LINK</code>, ustawiono
        poziom ważności komunikatu na 3, natomiast nazwą menmoniczną jest
        obiektu jest <code class="code-inline">UPDOWN</code>.
      </p>
      <p>
        Domyślnie komunikaty diagnostyczne zwracane przez urządzenie wyświelane
        i przekazywane poźniej do syslog bez daty czy godziny. Co może czynić
        je bezużytecznymi. Jednak możemym użyć poniższego polecenia w trybie
        konfiguracji globalnej, aby wymusić wyświetlanie zrejestrowanych
        zdarzeń z datą oraz godziną.:
      </p>
<pre class="code-block">
R1(config)# service timestamps log datetime
</pre>
      <h2 id="3.10.5.backuprouterandswitchfiles">3.10.5. Konserwacja plików routera i przełącznika.</h2>
      <p>
        System plików Cisco IOS (IFS) umożliwia administratorowi przechodzenie
        do różnych katalogów i wyświetlanie listy plików w katalogu.
        Administrator może również tworzyć podkatalogi w pamięci flash lub na
        dysku. Dostępność katalogów zalęzy od urządzenia.
      </p> 
      <p>
        Za pomocą polecenia <code class="code-inline">show file systems</code>,
        możemy wyświelić listę obsługiwanych przez nasze urządzenie systemów
        plików.
      </p>
      <p>
        Dla nas najbardziej istotnymi systemami plików (obsługa) będzie TFTP,
        pamięć <em>flash</em> oraz pamięć NVRAM. Wyświetlenia zawartości
        pamięci <em>flash</em>, możemy dokonać za pomocą polecenia
        <code class="code-inline">dir</code>. Natomiast aby wyświetlić
        zawartość NVRAM, należy przejść do niej i wydać ponownie polecenie
        <code class="code-inline">dir</code>. Pokazano to na poniższym 
        przykładzie.
      </p>
<pre class="code-block">
Router#
Router# cd nvram: 
Router# pwd
nvram:/
Router# dir
Directory of nvram:/
32769  -rw-             1024                      startup-config
32770  ----               61                      private-config
32771  -rw-             1024                      underlying-config
    1  ----                4                      private-KS1
    2  -rw-             2945                      cwmp_inventory
    5  ----              447                      persistent-data
    6  -rw-             1237                      ISR4221-2x1GE_0_0_0
    8  -rw-               17                      ecfm_ieee_mib
    9  -rw-                0                      ifIndex-table
   10  -rw-             1431                      NIM-2T_0_1_0
   12  -rw-              820                      IOS-Self-Sig#1.cer
   13  -rw-              820                      IOS-Self-Sig#2.cer
33554432 bytes total (33539983 bytes free)
Router#
</pre>
      <p>
        Wersje systemów IOS na przełączniki również obsługują kilka rodzajów
        plików. Na pewno te same, które mogą nas interesować. Pełną listę
        wspieranych przez przełączniki systemów plików, możemym podejrzeć
        znanym nam już poleceniem.
      </p>
      <p>
        Wiele programów pozwalających nam podłączyć nasz system do konsoli
        urządzenia posiada w swoich opcjach funkcje
        <strong>logowania sesji</strong>, to jest zapisania do tekstowego
        wszystkie co jest wyświetlone w oknie programu. Dzięki tej funkcji
        możemy wyświetlić bierzącą konfigurację i automatycznie zapisać ją
        jako kopię bezpieczeństwa. Niektóre z programów pozwalają nawet wysłać
        pliki linia po linii przez konsole do urządzenia jako kolejne wpisywane
        polecenia.
      </p>
      <p>
        Innym sposobem zachowanie kopii konfiguracji, może być użycie
        serwera TFTP (prostej usługi transferu plików, bez uwierzytelniania,
        bez poleceń, poprostu adres serwera, nazwa docelowa dla pliku i plik
        zostaje przesłany. To samo w odwrotną strone. TFTP używa protokołu UDP
        zamiast TCP). TFTP jest docelowym systemem plików. Do wykonania kopii
        wykorzystamy standardowe polecenie <code class="code-inline">copy</code>
      </p>
<pre class="code-block">
R1# copy running-config tftp
Remote host []?192.168.10.254
Name of the configuration file to write[R1-config]? R1-Gru-2024
Write file R1-Gru-2024 to 192.168.10.254? [confirm]
Writing R1-Gru-2024 !!!!!! [OK]
</pre>
      <p>
        Niektóre z routerów Cisco są wyposarzone w porty USB, pozwalają one
        podłączenie pamięci <em>flash</em> USB firmy Cisco i wykonanie na nich
        kopii zapasowej czy to konfiguracji czy też obrazów z systemem IOS.
        Procedura wygląda identycznie jak w przypadku protokołu TFTP, ale 
        zamiast <code class="code-inline">tftp</code> podajemy 
        <em>usbflash0:</em> i przywracanie również wygląda analogicznie.
      </p>
      <p>
        Jednak co się stanie jeśli zapomnimy hasła do np. trybu
        uprzywilejowanego? Otóż posiadając fizyczny dostęp do urządzanie, mogąc
        podłączyć się do niego za pomocą konsoli. Jednak to nie wszystkie 
        czynności jakie trzeba wykonać. Po podłączeniu konsoli należy:
      </p>
      <ol>
        <li><strong>Wejść w tryb ROMMON.</strong><br />
          Jest tak jakby dostęp do urządzenia z poziomu programu ładującego.
          Aby wejść w ten tryb należy albo nacisnąć <em>Ctrl+Break</em>
          (dla programu PuTTY), zaraz po podłączeniu urządzenia do prądu. Drugą
          możliwością jest usunięcie zewnętrznej pamięci <em>Flash</em> gdy
          urządzenie jest <strong>wyłączone</strong>.
        </li>
        <li><strong>Zmienić rejestr konfiguracji.</strong><br />
          Tryb ROMMON jest dość biednie wyposarzony, ale obsługuje jedno
          interesujące nas polecenie - jest nim <strong>confreg</strong>. Jako
          argument tego polecenia podajemy wartość <strong>0x2142</strong>.
          Ten tryb wymusi na IOS, aby ten nie ładował konfiguracji z NVRAM-u,
          udostępnił czysty nie skonfigurowany system. Po zmianie rejestru
          wznawiamy ładowanie systemu operacyjnego poleceniem
          <strong>reset</strong>.
        </li>
        <li><strong>Skopiować konfigurację startowa do bierzącej.</strong><br />
          To tutaj odbywa się cała magia. Za pomocą zmiany tryby mamy pełen
          dostęp do urządzenia bez hasła, teraz więc możemy załadować
          konfigurację, w której znajduje się zapomniane hasło i je zmienić.
          System nas nie wyloguje, nie wyrzuci, ani nie zapyta o stare hasło.
        </li>
        <li><strong>Zmienić hasło.</strong></li>
        <li><strong>Skopiować bierzącą konfigurację do startowej.</strong><br />
          Przed tą czynnością można już przywrócić normalny tryb rozruchu, tym
          razem konfigurując rejestr już z poziomu systemu za pomocą polecenia
          <code class="code-inline">config-register</code> przy użyciu
          argumentu <strong>0x2102</strong>.
        </li>
        <li><strong>Załadować ponownie urządzenie</strong></li>
      </ol>
      <h3 id="3.10.5.pkt">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.6.10-packet-tracer---back-up-configuration-files_pl-PL.pdf">Tworzenie kopii zapasowych plików konfiguracyjnych - scenaiusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.6.10-packet-tracer---back-up-configuration-files_pl-PL.pka">Tworzenie kopii zapasowych plików konfiguracyjnych - zadanie</a>
      </p>
      <h3 id="3.10.6.lab">Laboratorium</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/lab/10.6.11-lab---use-tera-term-to-manage-router-configuration-files_pl-PL.pdf">Użyj Tera Term do zarządzania plikami konfiguracyjnymi routera</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/lab/10.6.12-lab---use-tftp,-flash,-and-usb-to-manage-configuration-files_pl-PL.pdf">Stosowanie TFTP, Flash i USB do zarządzania plikami konfiguracyjnymi</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/lab/10.6.13-lab---research-password-recovery-procedures_pl-PL.pdf">Zbadaj procedury odzyskiwania hasła</a>
      </p>
      <h2 id="3.10.6.iosimagemanagement">3.10.6. Zarządzanie obrazami IOS</h2>
      <p>
        Podobnie do plików konfigurajcyjnych możemy chcieć zapisać - oczywiście
        ze względów bezpieczeństwa obraz Cisco IOS na naszym serwerze. Jednak 
        najbardziej prawdopodobnym scenariuszem będzie sytuacja odwrotna, gdzie
        wykorzystamy nasz serwer TFTP do <strong>aktualizacji wersji IOS</strong>
        na naszym urządzeniu. Z serwerem TFTP mieliśmy styczność we 
        wcześniejszym podrozdziale. Aby dokonać takie aktualizacji, na
        początku sprawdzamy czy nasz serwer TFTP jest osiągalny z naszego
        urządzenia - za pomocą polecenia <em>ping</em>.
      </p>
<pre class="code-block">
R1# ping 2001:db8:cafe:100::99
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 2001:DB8:CAFE:100::99,
timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), 
round-trip min/avg/max = 56/56/56 ms
</pre>
      <p>
        Następnie za pomocą ostaniej linii wyjścia polecenia
        <code class="code-inline">show flash:</code> ostalamy ilość wolnego
        miejsca w pamięci <em>flash</em>.
      </p>
<pre class="code-block">
R1# show flash: 
-# - --length-- -----date/time------ path
...
6294806528 bytes available (537251840 bytes used) 
R1#
</pre>
      <p>
        Następną czynnością jest skopiowanie obrazu IOS z TFTP do
        pamięci <em>flash</em>.
      </p>
<pre class="code-block">
R1# copy tftp: flash: 
Address or name of remote host []?2001:DB8:CAFE:100::99
Source filename []? isr4200-universalk9_ias.16.09.04.SPA.bin
Destination filename [isr4200-universalk9_ias.16.09.04.SPA.bin]? 
Accessing tftp://2001:DB8:CAFE:100::99/ isr4200-
universalk9_ias.16.09.04.SPA.bin...
Loading isr4200-universalk9_ias.16.09.04.SPA.bin
from 2001:DB8:CAFE:100::99 (via
GigabitEthernet0/0/0): !!!!!!!!!!!!!!!!!!!!
 
[OK - 517153193 bytes]
517153193 bytes copied in 868.128 secs (265652 bytes/sec)
</pre>
      <p>
        Po zakończonym kopiowaniu <strong>należy pamiętać o aktualizacji
        domyślnego obrazu IOS</strong>. Dokonać tego możemy za pomocą 
        poniższego polecenia w trybie konfiguracji globalnej.
      </p>
<pre class="code-inline">
R1(config)# boot system flash0:isr4200-universalk9_ias.16.09.04.SPA.bin
</pre>
      <p>
        Po tej czynności nie pozostaje nam nic innego jak zapisać konfigurację
        i uruchomić nasze urządzenie ponownie.
      </p>
      <h3 id="3.10.6.pkt">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.7.6-packet-tracer---use-a-tftp-server-to-upgrade-a-cisco-ios-image_pl-PL.pdf">Użyj serwera TFTP do aktualizacji obrazu Cisco IOS - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/10.7.6-packet-tracer---use-a-tftp-server-to-upgrade-a-cisco-ios-image_pl-PL.pka">Użyj serwera TFTP do aktualizacji obrazu Cisco IOS - zadanie</a>
      </p>
      <h2 id="3.10.summary">3.10. Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy się z protokołami CDP, LLDP oraz
        protokołem synchronizacji czasu NTP. Następnie omówilśmy sobie w jaki
        sposób może być przydatny protokół SMNP oraz jak czytać komunikaty
        diagnostyczne zwracane na przez urządzenia. Na koniec dowiedzieliśmy
        się w jaki sposób tworzyć kopie bezpieczeństwa konfiguracji urządzeń
        oraz wykorzystać serwer TFTP do aktualizacji Cisco IOS.
      </p>
      <h1 id="3.11.desigingnetworks">3.11. Projektowanie sieci</h1>
      <p>
        Obecnie swiat cyfrowy ulega znacznym przemianom. Wiele firm dzięki
        dostępności Internetu oraz sieci firmowej nie musi już być ograniczona
        do pojedynczych biur, nawet pracownicy mogą zamieć biura na kąt w
        domowy zaciszu pracując zdalnie lub nawet pracować z dowolnego miejsca
        na świecie. To powoduje, że nie tylko branża IT ale także wszystkie
        inne gałęzie gospodarki państw stają się uzależnione od infrastruktury
        sieciowej. Dzięki niej firma może się rozwijać. Zmiany te mają znaczący
        wpływ na wymagania sieci, która musi <strong>skalowalna</strong>.
      </p>
      <p>
        Sieć musi być opracowywana w architektonicznym podejściu, które posiada
        wbudowaną inteligencję, upraszcza operacje oraz jest skalowalna pod
        przyszłe wymagania. Takie sieci są nazwywane
        <strong>nieograniczonymi sieciam przełączanymi</strong>. 
      </p>
      <p>
        Budowa takie sieci oparta jest o następujące zasady:
      </p>
      <ul>
        <li><strong>Hierarchiczność</strong> - wykorzystanie lub stworzenie
          projektu, który pozwoli na określenie roli każdego urządzenia w
          każdej warstwie, uprości wdrożenie, obsługę i zarządzanie oraz
          redukuje domeny błedów na każdej z warstwa.</li>
        <li><strong>Modułowość</strong> - Konstrukcja umożliwia bezproblemową
          rozbudowę sieci i wyłączenie zintegrowanych usług na żądanie.</li>
        <li><strong>Odporność</strong> - projekt musi spełniać oczekiwania
          użytkowników w zakresie utrzymania sieci zawsze włączonej.</li>
        <li><strong>Elastyczność</strong> - Konstrukcja umożliwia inteligente
          dzielenie obciążenia ruchu przy użyciu wszystkich zasobów sieciowych.</li>
      </ul>
      <p>
        Projektowanie nieograniczonej sieci przełączanej w sposób hierarhiczny
        tworzy podstawę, która zezwala projektantom sieci na pokrycie
        bezpieczeństwa, mobilności oraz jednolitych właściwości komunikacyjnych.
        Dwie sprawdzone w czasie i sprawdzone hierarhiczne struktury projektowe
        dla sieci kampusowych to modele trójwarstwowe oraz dwuwarstwowe.
      </p>
      <p>
        Model <strong>trójwarstwowy</strong> posiada warstwę <strong>dostępu</strong>,
        <strong>dystrybucji</strong> oraz <strong>rdzenia</strong>. Każda z 
        tych warstw jest dobrze zdefiniowany strukturalnym modułem pełniącym
        określone role i funkcje w sieci. Model <strong>dwuwarstwowy</strong>,
        spłyca warstwę dystrybucji oraz rdzenia do jednej wspólnej warstwy.
        Takie rozwiązanie może zostać zastosowane w mniejszych sieciach
        kampusowych.
      </p>
      <ul>
        <li><strong>Warstwa dostępu</strong> - reprezeuntuje ona brzeg sieci, w
          którym ruch wychodzi lub wchodzi do niej. Podstawowym funkcją
          przełącznika warstwy dostępu jest zapewnie użytkownikowi dostępu do
          sieci.</li>
        <li><strong>Warstwa dystrybucji</strong> - warstwa między warstwą
          dostępu, a warstwą rdzeniową. Zapewnia takie funkcje jak różnego
          rodzaju agregacje, wyznaczanie granic routingu, zapewnienie
          intligentnego przełącznia i routingu oraz dostępności i nadmiarowości
          Dostarcza również rózne usługi dla różnych klas aplikacji.</li>
        <li><strong>Warstwa szkieletowa</strong> - szkielet łączy
          poszczególnych warstw, dla których służy głównie jako agregator. Jej
          główną funkcją jest izolacja błedów oraz zapewnienie bardzo szybkiej
          łączności pomiędzy warstwami.</li>
      </ul>
      <h2 id="3.11.1.scallablenetworks">3.11.1. Sieci skalowalne</h2>
      <p>
        Aby obsługiwać dużą czy mała sieć, projektant musi opracować strategię
        umożliwijającą dostęp do sieci oraz efektywne i łatwe skalowanie.
        <strong>Skalowalność</strong> to termin, dla sieci która może się
        rozwiajać bez utraty dostępności i niezawodności. Poniżej znajdują się
        podstawowe zalecenia odnośnie projektowania sieci:
      </p>
      <ul>
        <li>Korzystaj z rozszerzalnego sprzętu lub urządzeń w klastrze, które
          można łatwo zaktualizować w celu zwiększenia możliwości.</li>
        <li>Zaprojektuj hierarchiczna się tak, aby zawierała moduły, które w
          razie potrzeby można dodawać, ulepszać i modyfikować bez wpływu na
          projekt innych obszarów sieci.</li>
        <li>Utwórz hierarchiczną strategię adresów IPv4 i IPv6.</li>
        <li>Jeśli to możliwe wybierz routery działające na różnych warstwach
          modelu OSI (wielowarstowe) w celu ograniczenia domeny
          rozgłoszeniowych i filtrowania pozstałego niepożądanego ruchu w
          sieci.</li>
      </ul>
      <p>
        W sieciach skalowanych, ważne jest zapewnienie redundancji, metodą
        jej implementacji może być <strong>trasy nadmiarowe</strong> -
        dodatkowe fizczne połączenia między urządzeniami służace do transmisji
        danych przez sieć. Zapewniają one wysoką dostępność w sieciach
        przełączanych. Jednakże, ze względu na zasadę działania przełączników,
        trasy nadmiarowe w sieci przełączanych mogą powodować pętle na
        poziomie warstwy 2. W takie sytuacji wymagane jest zastosowanie
        protokołu STP. Korzystanie z warstwy 3 w szkielecie to inny sposób na
        nadmiarowość bez konieczności stosowania STP w warstwie 2. Warstwa 3
        zapewnia również nalepszy wybór ścieżek i szybszą konwergencję podczas
        pracy awaryjnej.
      </p>
      <p>
        W dobrze zaprojektowanej sieci nie tylko występuje odpowiednia kontrola
        ruchu, orgraniczony jest także rozmiar domeny awarii. <strong>Domena
        awarii</strong> to obszar, w którym sieć jest narażona jest na
        uszkodzenie w sytuacji gdy występują problemy z urządzeniem lub usługą
        sieciową. Zakres domeny awarii wyznaczony jest przez funkcję, jaką
        spełnia urządzenie, które początkowo uległo awarii. Przykładowo,
        nieprawidłowe działanie przełącznika w segmencie sieci, w normalnej
        sytuacji wpływa tylko na hosty w tym segmencie. Jednakże, w momencie
        gdy awarii ulegnie router, lączący ten segment z innymi, jej zakres
        będzie znacznie większy. W celu zminimalizowani ryzyka awarii,
        powinno się stosować bardziej niezawodne urządzenia klasy
        <em>enterprise</em> oraz łącza nadmiarowe.
      </p>
      <p>
        W sieci hierarhicznej konieczne może być zwiększę przepustowości na
        niektórych łączach. W tym celu możemy wykorzystać <em>EtherChannel</em>
        oraz ogólne technologii agregacji łączy, wykorzystując do tego
        porty przełącznika. Z punktu widzenia urzadzenia kanał widoczny jest
        jako jedno łącze. EtherChannel jest także sposobem na lepsze
        wykorzystanie łączy nadmiarowych, wyłączonych przez STP.
      </p>
      <p>
        Sieć musi zostać zaprojetowana tak, aby można było ją rozszerzyć w 
        zależności od indywidualnych potrzeb oraz dostępnych urządzeń. Do
        komunikacji bezprzewodowej, urządzenia końcowe wymagają bezprzewodowej
        karty sieciowej, natomiast aby hosty bezprzewodowe mogły korzystać z
        zasobów sieci kablowej potrzebny punkt dostępu, umożliwiwający im
        dostęp do sieci firmowej (kablowej).
      </p>
      <p>
        W większych sieciach stosowany jest <strong>OSPF</strong>. Jest to
        protokół routingu według stanu łącza. Routery OSPF ustanawiają i 
        utrzymują sąsiedztwo z innymi podłączonymi routera OSPF. Routery 
        synchronizują swoją bazę stanu łącza. W przypadku zmiany sieci wysłane
        są aktualizacje stanu łączą, które informują inne routery OSPF o 
        zmianie i ustanawiają nową najlepszą ścieżkę, jeśli jest dostępna.
      </p>
      <h2 id="3.11.2.swicheshardwareplatform">3.11.2. Platformy sprzętowe przełączników</h2>
      <p>
        Jednym z prostych sposobów tworzenia hierarchicznych i skalowanych
        sieci jest użycie odpowiedniego sprzętu do pracy. Istnieje wiele
        platform przełączników i innych funkcji, które należy wziąć pod uwagę
        przed wyborem przełącznika. Projektując sieć, ważne jest, aby wybrać
        odpowiedni sprzęt, który spełni aktuane wymagania sieci, a także
        pozwoli na rozbudowę sieci. Urządzenia takie jak przełączniki i 
        routery spełniają w korporacjach kluczową role w procesie komunikacji
        sieciowej. 
      </p>
      <p>
        Administratorzy sieci muszą określić czynniki, na podstawie których
        będą decydować o wyborze przełącznika. Obejmuje to stałą konfigurację,
        konfigurację modułową, możliwość układania w stos lub ich brak.
      </p>
      <p>
        Parametr gęstości portów przełącznika określa ilość dostępnych portów
        przypadającą na jeden przełącznik. Przełącznik o stałej konfiguracji
        obsługują różne konfiguracje gęstości portów. Przełączniki 48 portowe
        mogą być dodatkowo wyposażane o dodatkowe porty.
      </p>
      <p>
        Szybkość przekazywania jest miarą ilości danych, które przełączniki
        może przetworzyć w ciągu sekundy. Serie przełączników są klasyfikowane
        na podstawie ich szybkości przekazywania. Przełączniki niższej klasy
        mają na ogół mniejszą przepustowość niż przełączniki klasy 
        <em>enterprise</em> Szybkość przekazywanie jest istotnym parametrem,
        który można uwzględnić, dobierając przełącznik. Na przykład typowy
        48-portowy przełącznik gigabitowy działający z pełną prędkością
        okablowania generuje ruch 48Gb/s. Jeśli przełącznik obsługuje tylko
        szybkość przekazywania 32Gb/s, nie może działać z pełną prędkością na
        wszystkich portach.
      </p>
      <p>
        Funkcja zasilanie przez <em>Ethernet</em> (PoE - Power over Ethernet) 
        umożliwia
        przełącznikowi dostarczenie enegrii elektrycznej do urządzenia przez
        istniejące okablowanie <em>ethernetowe</em>. Ta funkcja może być
        używana przez Telefony IP i niektóre bezprzewodowe punkty dostępowe,
        dzięki czemu można jest zainstalować w dowolnym miejscu, w którym jest
        kabel <em>Ethernet</em>. Przełączniki tego typu są dość drogie, więc
        trzeba się upewnić czy na pewno potrzebujemy takiej funkcji.
      </p>
      <p>
        Przełączniki wielowarstwowe są zwykle wdrażane w warstwie rdzenia i 
        warstwach dystrybucyjnych sieci przełączanej. Ich cechą
        charakterystyczną jest możliwość tworzenia tablic routingu, obsługa
        niektórych protokołów routingu oraz przekazywanie pakietów IP z
        szybkością zbliżoną do przełączania w warstwie 2. Obecnie w sieciach
        występuje tendencja tworzenia środowisk opartych wyłącznie na
        urządzeniach warstwy 3. Obecnie prawie wszystkie przełączniki obsługują
        routing. Prawodopodobnie wkrótce wszystkie przełączniki będą miały
        wbudowany procesor routingu. Przełączniki Catalyst 2960 ilustrują
        migrację do czystego środowiska warstwy 3. Przed IOS 15.x, przełączniki
        obsługiwały tylko jeden interfejs SVI, od momentu wydania IOS 15.x
        przełączniki obsługują teraz wiele aktywnych interfejsów SVI. Oznacza
        to, że przełącznik może mieć wiele skonfigurowanych adresów IP w 
        różnych podsieciach i łączyć się zdalnymi sieciami.
      </p>
      <h2 id="3.11.3.routerhardwarecomponents">3.11.3. Komponenty sprzętowe routera</h2>
      <p>
        Wybór routera to kolejna bardzo ważna decyzja. Routery odgrywają
        kluczową rolę w tworzeniu sieci. Wykorzystują one część sieciową
        (prefiks) docelowego adresu IP do kierowania pakietów do właściwego
        miejsca docelowego. W przypadku zerwania łącza wybierają alternatywną
        ścieżkę. Wszystkie hosty w sieci lokalnej umieszczają swojej
        konfiguracji adres IP interfejsu lokalnego routera, podłączonego do tej
        sieci. Interfejs ten pełni funkcję bramy domyślnej. Zdolnośc do
        wydajnego trasowania i odtwarzania po awarii łącza sieciowego ma
        kluczowe znaczenie dla dostarczania pakietów do miejsca przeznaczenia.
      </p>
      <p>
        Istnieją różne kategorie routerów Cisco:
      </p>
      <ul>
        <li><strong>Routery dla oddziałów</strong> - optymalizują na jednej
          platformie obsługę aplikacji w oddziałach i infrastrukturach WAN.</li>
        <li><strong>Routery brzegowe</strong> - umożliwiają brzegowi sieci
          dostarczenie wysokowydajnych, wysoce bezpiecznych i niezawodnych
          usług, które łączą kampus, centrum danych i sieć oddziałów.</li>
        <li><strong>Routery dostawców usług sieciowych</strong> - zapewniają
          kompleksowe, skalowalne rozwiązania i usługi dostosowane do abonentów.</li>
        <li><strong>Przemysłowe</strong> - są zaprojektwane tak, aby
          zapewniać funkcję klasy korporacyjnej w trudnych i bardzo trudnych
          warunkach.</li>
      </ul>
      <h3 id="3.11.pkt">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/11.5.1-packet-tracer---compare-layer-2-and-layer-3-devices_pl-PL.pdf">Porównaj urządzenia warstwy 2 i warstwy 3 - scenariusz</a><br />
        <a href="https://ftp.morketsmerke.org/~xf0r3m/cisco/module_3/pt/11.5.1-packet-tracer---compare-layer-2-and-layer-3-devices_pl-PL.pka">Porównaj urządzenia warstwy 2 i warstwy 3 - zadanie</a>
      </p>
      <h1 id="3.12.networkstroubleshooting">3.12. Rozwiązywanie problemów z sieciami</h1>
      <p>
        Rozwiązywanie problemów na początek rozpoczniemy od zagadanienia 
        utworzenia i prowadzenia dokumentacji.
      </p>
      <p>
        Aby skutecznie monitorować i rozwiązywać problemy z siecią, wymagana
        jest dokładna i kompletna dokumentacja sieciowa. Taka dokumentacja
        powinna zawierać nastepujące elementy:
      </p>
      <ul>
        <li>Diagramy fizycznej i logicznej topologii sieci.</li>
        <li>Dokumentacja urządzenia sieciowe rejestrująca wszystkie istotne
          informacje o urządzeniu.</li>
        <li>Dokumentacja bazowa wydajności sieci.</li>
      </ul>
      <p>
        Dokumentacja sieciowa powinna być przechowywana w formie papierowej
        w jednym miejscu lub w sieci na chronionym serwerze. Jej kopia zapasowa
        powinna być zabezpieczona i przechowywana w osobnej lokalizacji.
      </p>
      <p>
        <strong>Topologia fizyczna</strong> - przedstawia fizyczny układ 
        urządzeń podłączonych do sieci. Informacje zapisne w topologi fizycznej
        zazwyczaj obejmują:
      </p>
      <ul>
        <li>Nazwę urzadzenia</li>
        <li>Lokalizację urządzenia (adres, numer pokoju, lokalizaję szafy)</li>
        <li>Interfejs i używane porty</li>
        <li>Typ okablowania</li>
      </ul>
      <p>
        <strong>Topologia logiczna</strong> - ilustruje w jaki sposób urządzenia
        są ze sobą logicznie połaczone. Odnosi się do sposóbu przsyłania danych
        przez sieć podczas komunikacji z innymi urządzeniami. Informacje 
        zapisane w logicznej topologii sieći mogą obejmować:
      </p>
      <ul>
        <li>Identyfikatory urządzeń</li>
        <li>Adresy IP i długości prefiksów</li>
        <li>Identyfikatory interfejsu</li>
        <li>Protokół routingu / trasy statyczne</li>
        <li>Informacje warstwy 2 (tj. sieci VLAN, połączenia <em>trunk</em>, 
          <em>EtherChannel</em></li>
      </ul>
      <p>
        Jeśli nasz sieć działa w podwójnym stosie to możemy również dodać
        do topologi logicznej adresy IPv6, lub utworzyć dla niej zupełnie
        oddzielną.
      </p>
      <p>
        Dokumentacja urządzeń sieciowych powinna zawierać dokładne i aktualne
        zapisy sprzętu sieciowego. Dokumentacja powinna zawierać wszystkie
        istotne informacje takie jak nazwa urządzenia, model, opis,
        lokalizację, wersję oprogramowania oraz datę ostatniej jego
        aktualizacji. W przypadku routerów ważne jest opisanie każdego z
        interfejsów, przypisanych mu adresów IP, adresu MAC oraz przeznaczenia,
        podobnie w przypadku przełączników opis z czym łaczy się dany port,
        opisy konfiguracji VLAN czy port <em>trunk</em> czy działa w
        <em>EtherChannel</em>, dla <em>trunk</em>-ów ID natywnego VLAN oraz
        stan portów - włączony/wyłączony. 
      </p>
      <p>
        Celem procesu monitorowania sieci jest obserwacja wydajności i
        porównanie jej z wyznaczonym punktem odniesienia. Stan odniesienia
        służy do ustalenia normalnej wydajności sieci lub systemu w celu
        określenia <em>osobowości</em> sieci w normalnych warunkach. 
        Wyznaczenie stanu odniesienia wymaga zebrania danych o wydajności z
        poszczególnych portów i urządzeń, niezbędnych do działania sieci. Stan
        odniesienia powinien odpowiadać na następujące pytania:
      </p>
      <ul>
        <li>Jak sieć funkcjonuje podczas normalnego lub typowego dnia?</li>
        <li>Gdzie może wystąpić najwięcej błędów?</li>
        <li>Która część sieci jest najintensywniej wykorzystywana?</li>
        <li>Która część sieci jest najmniej wykorzystywana?</li>
        <li>Jakie urządzenia należy monitorować i jakie progi alarmowe należy
          ustawić?</li>
        <li>Czy sieć może spełniać określone zasady?</li>
      </ul>
      <p>
        Przygotowując punkt odniesienia należy:
      </p>
      <ol>
        <li>Określić jakie typu dane trzeba zebrać, aby analiza była łatwa ale
          zarazem miarodajna.</li>
        <li>Zindentyfikować interesujące urządzenia i porty, na który powinien
          odbywać się pomiar. Mogą być to porty urządzeń sieciowych, serwery
          czy kluczowi użytkownicy.</li>
        <li>Określ czas zbieraniania danych, aby ustalić normalny obraz sieci.</li>
      </ol>
      <p>
        Podczas zbierania informacji do dokumentacji, możemy swobodnie
        posługiwać się poznanymi dotychczas wariacjami polecenia
        <code class="code-inline">show</code>.
      </p>
      <h2 id="3.12.1.troubleshootingprocess">3.12.1. Proces rozwiązywania problemów</h2>
      <p>
        Istnieje kilka procesów rozwiązywania problemów, dla przykładu możemy
        użyć trzech prostych logicznych etapów.
      </p>
      <ol>
        <li><strong>Etap 1:</strong> - zebranie objawów.</li>
        <li><strong>Etap 2:</strong> - wyizolowanie problemu.</li>
        <li><strong>Etap 3:</strong> - wdrożenie działań naprawczych.</li> 
      </ol>
      <p>
        Jeśli problem wydaje się rozwiązny, to należy udokumentować rozwiązania
        i zapisz
        zmiany. Jeśli nie, lub też tworzony kolejny problem to należy cofnąć
        działania naprawcze i rozpocząć od początku.
      </p>
      <p>
        Oczywiście istnieje bardziej szczegółowy 7-etapowy proces rozwiązywania
        problemów, nie ma on już tak określonej kolejności dziań i dowolnie
        można skakać między wewnętrznymi krokami. Poniżej znajdują się omawiane
        kroki:
      </p>
      <ul>
        <li>Zdefiniuj problem.</li>
        <li>Zbierz informacje.</li>
        <li>Analizuj informacje.</li>
        <li>Wyeliminuj możliwe przyczyny.</li>
        <li>Zaproponuj hipotezę.</li>
        <li>Przetestuj hipotezę.</li>
        <li>Rozwiąż problem i udokumentuj rozwiązanie.</li>
      </ul>
      <p>
        Krok pierwszy oraz ostatni można uznać za kroki zewnętrzne.
      </p>
      <p>
        Wiele problemów z siecią jest początkowo zgłaszanych przez użytkownika
        końcowego. Jednakże dostarczone informacje są często niejasne lub
        wprowadzają w błąd. Na przykłąd użytkownicy często zgłaszaja problemy
        takie jak "sieć jest wyłączona", "Nie mogę uzyskać dostępu do mojej
        poczty", lub "Mój komputer jest wolny". Do komunikacji z użytkownikiem
        mogą być stosowane następujące zlecenia.
      </p>
      <ul>
        <li>Stosowanie języka technicznego na poziomie rozmówcy, unikanie
          złożonej terminologii.</li>
        <li>Skupienie się na komunikat przekazywanych przez użytkownika.
          Tworzenie notatek, może okazać się przydatne.</li>
        <li>Wykazanie się empatią, wobec zgłaszających.</li>
      </ul>
      <p>
        Zbierając objawy z podejrzanego urządzenia sieciowego, możemy użyć
        takich poleceń jak:
      </p>
      <ul>
        <li><code class="code-inline">ping</code></li>
        <li><code class="code-inline">traceroute</code></li>
        <li><code class="code-inline">telnet/ssh</code></li>
        <li><code class="code-inline">show ip interface brief</code></li>
        <li><code class="code-inline">show ip route</code></li>
      </ul>
      <p>
        Podczas izolowania problemów, możemy się posłużyć modelem ISO/OSI. Dla
        przykładu: warstwy od 7-5 - będą dotyczyć urządzenia końcowego,
        warstwy 4-3 - routera lub przełącznika wielowarstwowego, warstwa 2 - 
        przełącznika standardowego oraz warstwa 1 - interfejsów, przewodów oraz
        portów.
      </p>
      <p>
        Istnieje kilka uporządkowanych podejść do rozwiązywania problemów,
        które można wykorzystać. Każde z nich będzie zależalo od sytuacji.
      </p>
      <ul>
        <li><strong>Od dołu</strong> - rozwiązywanie problemów zaczynamy od
          dołu od fizycznych komponentów sieci i przechodzimy przez kolejne
          warstwy OSI.</li>
        <li><strong>Od góry</strong> - rozwiązywanie problemów rozpoczynamy od
          użytkownika końcowego i przechodzi przez kolejne warstwy OSI.</li>
        <li><strong>Dziel i rządź</strong> - w tej metodzie adminstrator
          wybiera jedną w warstw pośrednich następnie przeprowadza testy w obu
          kierunkach rozpoczynają od tej warstwy.</li>
        <li><strong>Podążanie ścieżka</strong> - Podejście najpierw odkrywa 
          rzeczyswitą drogę od źródła do miejsca docelowego. Zakres tego
          rozwiązania problemów jest ograniczony tylko do linków i urządzeń
          znajdujących się na ścieżce przesyłania dalej.</li>
        <li><strong>Podmiana</strong> - w tym podjeściu fizycznie zamieniamy
          problematyczne urządzenie na znane działające.</li>
        <li><strong>Porównanie</strong> - w tym podejściu próbujemy rozwiązać
          problem przez porównanie i zmiane elementów nieoperacyjnych z tymi
          działającymi.</li>
        <li><strong>Zgadywanie na podstawie doświadczenia.</strong></li>
      </ul>
      <h2 id="3.12.2.troubleshootingtools">3.12.2. Narzędzia do rozwiązywania problemów</h2>
      <p>
        Na rynku dostępnych jest szereg narzędzi sprzętowych i programowych, 
        wspomagających rozwiązanie problemów. Mogą one być wykorzystywane do
        zbierania i analizowania symptomów niewłaściwej pracy sieci. 
      </p>
      <ul>
        <li><strong>System zarządzania siecią</strong> - systemy zarządzania
          siecią zawierają oprogramowanie do monitorowanie na poziomie
          urządzenia, konfiguracji i oraz zarządzania usterkami.</li>
        <li><strong>Bazy wiedzy</strong> - bazy wiedzy online dostawców
          urządzeń sieciowych stały się przydatnym źródłem informacji. Często
          są zintegrowane z wyszukiwarkami.</li>
        <li><strong>Narzędzia do tworzenia stanu odniesienia</strong> - 
          Dostępnych jest wiele narzędzi służących do automatyzowania
          dokumentacji sieciowej oraz procesu stanu odniesienia. Narzędzia
          do pomiaru stanu odniesienia pomagają w wykonaniu typowych zadań
          związanych z dokumentacją sieci.</li>
      </ul>
      <p>
        Analizatory protokołów mogą badać zawartość pakietów podczas
        przepływu przez sieć. Analizator protokołu dekoduje zapisaną ramkę dla
        każdej warstwy przedstawia informacje o zawartych w niej protokołach
        w relatywnie protstym formacie. Takim analizatorem może być Wireshark.
      </p>
      <p>
        Do rozwiązywania problemów z siecią możemy wykorzystać narzędzia
        sprzętowe. Takie jak:
      </p>
      <ul>
        <li><strong>Cyfrowy multimetr</strong> - badanie zasilania urządzeń, 
          np. Fluke 179.</li>
        <li><strong>Tester kabli</strong> - badanie długości oraz ciągłości
          przewodowów, np. Fluke LinkRunner AT.</li>
        <li><strong>Analizator okablowania</strong> - testowanie oraz
          certyfikowanie kabli miedziany pod kątem różnych usług i standardów.
          np. Fluke DTX Cable Analyser.</li>
        <li><strong>Przenośne analizatory sieci</strong> - rozwiązywanie
          problemów z sieciami przełączanymi i sieciami VLAN.</li>
      </ul>
      <p>
        Implementacja usług rejestrowania jest ważnym elementem związanym z
        bezpieczeństwem sieci i rozwiązywaniem problemów. Urządzenia Cisco mogą
        rejestrować informacje dotyczące zmian w konfiguracji, naruszeń ACL,
        stanu interfejsów i wielu innych rodzajów zdarzeń. Mogą też wysyłać 
        logi do kilku różnych obiektów, takich jak:
      </p>
      <ul>
        <li>Konsola</li>
        <li>Linie terminala</li>
        <li>Rejestrowanie buforowane</li>
        <li>Pułapki SNMP</li>
        <li>Syslog (zewnętrzna usługa)</li>
      </ul>
      <h2 id="3.12.3.symptomsofnetworktroubles">3.12.3. Objawy i przyczyny problemów z siecią</h2>
      <p>
        Problemy występujące w sieci często są związane z wydajnością. Oznacza
        to że istnieje różnica między wydajnością oczekiwana a obserwowaną i
        czy system nie funkcjonuje tak, jak powinien. Działanie wyższych 
        warstwa modelu żależy od funkcjonowania warstwy fizycznej, 
        administrator musi umieć w sposób efektywny wyizolować i wyeliminować
        w problemy w warstwie fizycznej. Poniżej znajdują się symptomy oraz
        przyczyny problemów w tej warstwie.
      </p>
      <p>
        Symptomy:
      </p>
      <ul>
        <li>Wydajność poniżej poziomu odniesienia.</li>
        <li>Utrata łączności.</li>
        <li>Zatory lub przeciążenia w sieci.</li>
        <li>Wysokie wykorzystanie procesora.</li>
        <li>Komunikat o błędzie konsoli.</li>
      </ul>
      <p>
        Przyczyny:
      </p>
      <ul>
        <li>Przyczyny związane z mocą.</li>
        <li>Usterki sprzętowe.</li>
        <li>Błędy okablowania.</li>
        <li>Tłumienie.</li>
        <li>Zakłócenia.</li>
        <li>Błędy konfiguracji interfejsu.</li>
        <li>Przekroczenie limitów projektowych.</li>
        <li>Przeciążenie CPU.</li>
      </ul>
      <p>
        Problemy powstające w warstwie drugiej objawiają się w specyficzny
        sposób i jeśli zostaną odpowiedniu szybko rozpoznane, ich identyfikacja
        może nastąpić dość szybko. Poniżej znajdują symptomy oraz przyczny
        problemów z warstwą łącza. 
      </p>
      <p>
        Symptomy:
      </p>
      <ul>
        <li>Nieprawidłowe funkcjowanie brak łączności w warstwie sieci lub 
          wyższej.</li>
        <li>Działanie sieci wyjściowej poniżej poziomów wydajności.</li>
        <li>Nadmierne rozgłoszenia.</li>
        <li>Komunikaty konsoli.</li>
      </ul>
      <p>
        Przyczyny:
      </p>
      <ul>
        <li>Błędy enkapsulacji</li>
        <li>Błędy mapowania adresu</li>
        <li>Błędy ramek</li>
        <li>Błędy i pętle STP</li>
      </ul>
      <p>
        Problemy warstwy sieciowej obejmują każdy problem, który obejmuje
        protokół warstwy 3, takie jak IPv4, IPv6, EIGRP, OSPF itp. Poniżej
        znajdują się objawy oraz przyczny problemów z warstwą sieciową.
      </p>
      <p>
        Symptomy:
      </p>
      <ul>
        <li>Awaria sieci</li>
        <li>Nieoptymalna wydajność</li>
      </ul>
      <p>
        Przyczny:
      </p>
      <ul>
        <li>Ogólne problemy z siecią</li>
        <li>Problemy z łącznością</li>
        <li>Tabela routingu</li>
        <li>Problemy z ustanowieniem sasiedztwa</li>
        <li>Baza danych topologii</li>
      </ul>
      <p>
        Problemy sieci mogą w przypadku routerów wynikać z problemów warstwy
        transportowej, szczególnie na granicy sieci gdzie ruch jest filtrowany
        i modyfikowany. Zarówno listy kontroli dostępu - ACL, jak i translacja
        adresów - NAT działają w warstwie sieciowej i mogą obejmować operacje
        warstwy transportowej. Symptomy:
      </p>
      <ul>
        <li>Problemy z łącznością</li>
        <li>Problemy z dostępem</li>
      </ul>
      <p>
        Przyczyny:
      </p>
      <ul>
        <li>Konfiguracje ACL</li>
        <li>Konfiguracje NAT</li>
      </ul>
      <p>
        Do najczęstsze problem z listami ACL, na jakie możemy natrafić to:
      </p>
      <ul>
        <li>Wybór strumienia ruchu.</li>
        <li>Kolejność wpisów ACL.</li>
        <li>Domyślny <strong>deny any</strong>.</li>
        <li>Adres i maski blankietowe IPv4.</li>
        <li>Wybór protokołu warstwy transportowej.</li>
        <li>Porty źródłowe i docelowe.</li>
        <li>Użycie słowa kluczowego <em>established</em>.</li>
        <li>Rzadko używane protokoły</li>
      </ul>
      <p>
        Istnieje kilka problemów z NAT, takich jak brak integracji z usługami,
        takimi jak DHCP i tunelowanie. Mogą to być błędnie skonfigurowany NAT
        wewnątrz, NAT na zewnątrz lub listy ACL. Pozostałe problemy dotyczną
        interoperacyjności z innymi technologiami sieciowymi, szczególnie
        takimi, które wykorzystują informacje o adresacji hosta w sieci 
        umieszczone w pakiecie.
      </p>
      <p>
        Problemy w warstwie aplikacji blokują dostarczenie usług do programów
        obsługujących je. Usterka w warstwie aplikacji może w rezultacie
        sprawić, że zasoby sieci będą nieosiągalne lub niemożliwe do użycia,
        podczas gdy pozostałe warstwy funkcjonują prawidłowo. Połączenie z
        siecią jest prawidłowe, jednak aplikacje nie są w stanie ostarczać
        danych. 
      </p>
      <h2 id="3.12.4.troubleshootingwithipconnections">3.12.4. Rozwiązywanie problemów z łącznością IP.</h2>
      <p>
        Gdy nie ma łączności typu <em>end-to-end</em>, a administrator
        decyduje się na rozwiązanie problemów z podejściem oddolnym można
        wykonać następujące czynności:
      </p>
      <ol>
        <li>Sprawdź fizyczne połącznie w punkcie, w którym zauważono przerwę w
          komunikacji sieciowej. Obejmuje ono sprzęt i okablowanie. Problem
          może być spowodowany przez uszkodzony przewód lub interfejs, albo
          może dotyczyć nieskonfigurowanego lub wadliwego urządzenia.
          Do badania warstwy fizycznej możemy wykorzystać takie polecenia jak:
          <ul>
            <li><code class="code-inline">show interfaces</code></li>
            <li><code class="code-inline">show memory</code></li>
            <li><code class="code-inline">show processes cpu</code></li>
          </ul>
        </li>
        <li>Sprawdź zgodność interfejsu, poleceniem
          <code class="code-inline">show interface</code>.</li>
        <li>Sprawdź adresację warstwy łącza danych i warstwy sieci lokalnej.
          Należy skontrolować takie elememnty jak tablice ARP IPv4, tablicę
          sąsiadów IPv6 tablicę MAC oraz przepisania do sieci VLAN. Polecenia:
          <ul>
            <li><code class="code-inline">arp -a</code> (MS Windows)</li>
            <li><code class="code-inline">netsh interface ipv6 show neighbor</code>
            (MS Windows)</li>
            <li><code class="code-inline">show arp</code></li>
            <li><code class="code-inline">show mac address-table</code></li> 
          </ul></li>
        <li>Upewnij się, że brama domyślna jest prawidłowo ustawiona. Polecenia:
          <ul>
            <li><code class="code-inline">show ip route | include
              Gateway|0.0.0.0</code></li>
            <li><code class="code-inline">netstat -r</code> lub
              <code class="code-inline">route print</code> (MS Windows).</li>
          </ul>
        </li>
        <li>Upewnij się, że urządzenia ustalają prawidłową trasę od źródła do
          celu. Jeśli to konieczne skorygować informacje o routingu.
          Polecenia: <code class="code-inline">show ip/ipv6 route</code>.</li>
        <li>Sprawdź, czy warstwa transportowa działa prawiłowo, do tego można
          użyć polecenia <em>telnet</em> lub <em>nc</em>.</li>
        <li>Sprawdź, czy nie skonfigurowano list blokujących ACL. Polecenia:
          <ul>
            <li><code class="code-inline">show ip access-lists</code></li>
            <li><code class="code-inline">show ip interface ifX/Y | include access list</code>
          </ul> 
        </li>
        <li>Upewnij się czy ustawienia DNS są prawidłowe. Przynajmniej jeden
          serwer DNS powinien być osiągalny. Polecenia:
          <ul>
            <li><code class="code-inline">show running-config</code></li>
            <li><code class="code-inline">ip host nazwa adres_ip</code></li>
            <li><code class="code-inline">ping</code></li>
            <li><code class="code-inline">nslookup</code> (MS Windows, Linux)</li>
          </ul>
          Polecenia <code class="code-inline">ip host</code> służy do tworzenia
          statycznych mapować nazw na adresy IP.</li>
      </ol>
      <h2 id="3.12.summary">3.12. Podsumowanie</h2>
      <p>
        W tym temacie poruszyliśmy kwestie prowadzenia dokumentacji sieci.
        Przestawiono wiedzę na temat metod rozwiązywania problemów, 
        narzędzi fizycznych jak i oprogramowania. Poznaliśmy symptomy oraz
        objawy problemów z poszczególnymi warstwami na koniec dowiedzialiśmy
        w jaki sposób rozwiązywać problemy w połączeniach <em>end-to-end</em>.
      </p>
      <h1 id="3.13.virtualization">3.13. Wirtualizacja</h1>
      <p>
        Przetwarzanie w chmurze obejmuje dużą liczbę komputerów połączonych
        siecią, które mogą być fizycznie zlokalizowane w dowolnym miejscu.
        Dostawcy w dużym stopniu polegają na wirtualizacji, aby świadczyć
        usługi w chmurze. Przetwarzanie w chmurze może obniżyć koszty
        operacyjne dzięki wydajniejszemu wykorzystaniu zasobów.
        Rozwiązuje ono różne problemy związane z zarządzaniem danymi:
      </p>
      <ul>
        <li>Umożliwia dostęp do danych organizacji w dowolnym miejscu i czasie</li>
        <li>Usprawnia operacje IT organizacji, subskrybując tylko potrzebne
          usługi.</li>
        <li>Eliminuje lub ogranicza potrzebę posiada sprzętu IT na miejscu,
          konserweracji i zarządzania.</li>
        <li>Zmniejsza koszty sprzętu, energii, fizycznych wymagań zakładu i
          potrzeb szkoleniowych personelu.</li>
        <li>Umożliwia szybkie reagowanie na rosnące zapotrzebowanie na dane.</li>
      </ul>
      <p>
        Usługi w chmurze są dostępne w różnych opcjach, dostosowanych do
        wymagań klientów. Trzy głóne usługi przetwarzania w chmurze
        zdefiniowane przez NIST to:
      </p>
      <ul>
        <li><strong>Oprogramowanie jako usługa (SaaS)</strong> - Dostawca
          chmury jest odpowiedzialny za dostęp do aplikacji i usług, takich jak
          poczta e-mail, komunikacja i usługa Office 365, które są dostarczane
          przez Internet. Użytkownik nie zarządza żadnym aspektem usług w
          chmurze, z wyjątkiem ograniczonych ustawień aplikacji specyficznych
          dla użytkownika. Użytkownik musi jedynie podać swoje dane.</li>
        <li><strong>Platforma jako usługa (PaaS)</strong> - Dostawca chmury
          jest odpowiedzialny za zapewnienie użytkownikom dostępu do narzędzi
          programistycznych i usług używanych do dostarczenia aplikacji. Ci 
          użytkownicy są zazwyczaj programistami i mogą mieć kontrole na
          ustawieniami konfiguracyjnymi środowiska hostingu aplikacji usług w
          chmurze.</li>
        </li><strong>Infrastruktura jako usługa (IaaS)</strong> - Dostawca
          chmury jest odpowiedzialny za zapewnienie kierownikom IT dostępu
          do sprzętu sieciowego, zwirtualizowanych usług sieciowych i 
          infrastruktury pomocnicznej. Korzystanie z tej usługi w chmurze
          umożliwia menedżerom IT wdrażanie i uruchamianie kodu oprogramowania
          który może obejmować systemy operacyjne i aplikacje.</li>
      </ul>
      <p>
        Poniżej przedstawiono 4 modele chmur:
      </p>
      <ul>
        <li><strong>Chmury publiczne</strong> - Aplikacje i usługi oparte na
          chmurze oferowane ogółowi populacji. Usługi mogą być bezpłatne lub
          oferowane w modelu płatności za użycie.</li>
        <li><strong>Chmury prywatne</strong> - Aplikacje i usługi przeznaczone
          dla określonej organizacj lub podmiotu, takiego jak rząd.</li>
        <li><strong>Chmury hybrydowe</strong> - Chmura hybrydowa składa się
          z dwóch lub więcej modeli chmury. Może być częściowo publiczna oraz
          częściowo prywatna.</li>
        <li><strong>Chmury społecznościowe</strong> - Chmury społecznościowe
          jest tworzona do wyłącznego użytku przez określoną społeczność.</li>
      </ul>
      <p>
        Terminu centrum danych i przetwarznie w chmurze często jest używane
        nieprawidłowego. Oto poprawne definicje centrum danych oraz 
        przetwarzanie w chmurze.
      </p>
      <ul>
        <li><strong>Centrum danych</strong> - zazwyczaj obiekt do
          przechowywania i przetwarzania danych prowadzonych przez wewnętrzny
          dział IT lub wynajmowany poza siedzibą firmy.</li>
        <li><strong>Obliczanie w chmurze</strong> -  zwykle usługa zewnętrzna,
          która oferuje dostęp na żądanie współużytkowanej puli zasobów
          obliczeń, które możemy dostosowywać do własnych potrzeb.</li>
      </ul>
      <p>
        Centra danych to fizyczne obiekty, które zaspokajają potrzeby
        obliczeniowe, sieciowe i magazynowe usług przetwarzania w chmurze.
        Dostawcy usług w chmurze używają centrów danych do hostowania usług i
        zasobów.
      </p>
      <h2 id="3.13.1.virtualization">3.13.1. Wirtualizcja</h2>
      <p>
        Wirtualizacja oddziela system operacyjny OS od sprzetu. Różni dostawcy
        oferują usługi w chmurze wirtualnej, które mogą dynamicznie dostraczać
        serwery zgodnie w wymaganiami.
      </p>
      <p>
        Wirtualizacja serwerów wykorzystuje nieużywane zasoby i konsoliduje
        liczbę serwerów. Pozwala to instnienie wielu systemów operacyjnych
        na jednej platformie sprzętowej.
      </p>
      <p>
        Stosowanie wirtualizacji zwykle obejmuje redundancję. W razie
        awarii hiperwizora, maszyna wirtualna (pojedynczy serwer wirtualny,
        reprezentujący tak jakby fizyczną maszynę), może zostać uruchomiona
        na innym hiperwizorze. Ponad to można ją uruchomić w taki sposób, aby
        korzystała z większej ilości zasobów niż tylko pojedynczego
        hiperwizora.
      </p>
      <p>
        Hiperwizor to program, który dodaje warstwę abstrakcji na fizycznym
        sprzęcie. Warstwa ta pozwala na tworzenie maszyn wirtualnych, które
        mogą miec dostęp do całego sprzetu serwera fizycznego.
      </p>
      <p>
        Jedną z zalet wirtualizacji jest koszt: wymagana jest mniejsza ilość
        sprzętu, za co za tym idzie zmniejszone jest także zużycie energii
        elektrycznej oraz potrzebne mniej miejsca. Dodatkowymi zaletami
        są łatwiejsze prototypowanie (tworzenie środowisk testowych), szybsze
        udostępnienia serwerów, większy czas ich działania, lepsze odzyskiwanie
        po awariach czy wsparcie dla starszych wersji.
      </p>
      <p>
        Hiperwizor typu 2 to oprogramowanie, które tworzy i uruchamia
        wystąpienia maszyn wirtualnych. Komputer, na którym hiperwizor 
        obsługuje
        co najmniej jedną maszynę wirtualną, jest maszyną hosta. Hiperwizory
        typu 2 są również nazywane hiperwizorami hostowanymi. Dzieje się tak,
        ponieważ hiperwizor jest instalowany na istniejącym systemie 
        operacyjnym. Typowe hiperwizory typu 2 obejmują:
      </p>
      <ul>
        <li>Virtual PC</li>
        <li>VMWare Workstation</li>
        <li>Oracle VM VirtualBox</li>
        <li>VMware Fusion</li>
        <li>Mac OS X Parallels</li>
      </ul>
      <p>
        Większość z nich jest bezpłatnych, lub posiadających płatne 
        rozszerzenia. Ważne jest aby komputer, który ma hostować maszyny miał
        odpowiednie parametry: wielorzdzeniowy procesor oraz większą ilość
        pamięci RAM.
      </p>
      <h2 id="3.13.2.virtualnetworkinfrastructure">3.13.2. Infrastruktruktura sieci wirtualnej</h2>
      <p>
        Hiperwizor typu 1 są również nazwane podejściem <em>bare metal</em>,
        ponieważ hiperwizor jest instalowany bezpośrednio na sprzęcie.
        Hiperwizory typu 1 są zwykle używane na serwera przedsiebiorstwa i
        urządzeniach sieciowych w centrach danych. Instancje systemów
        operacynych są instalowane na hiperwizorze.
      </p>
      <p>
        Po zainstalowaniu hyperwizora typu 1 i ponownym uruchomieniu serwera
        wyświetlane są tylko podstawowe informacje, takie jak wersja systemu
        operacyjnego, ilość pamięci RAM i adres IP. Na tym ekranie nie można
        utworzyć instancji systemu operacyjnego. Hiperwizor typu 1 wymaga 
        <em>konsoli zarządzania</em>. Oprogramowania zarządzające służy do 
        zarządzania wieloma serwerami przy użyciu tego samego hiperwizora.
        Konsola zarządzania może automatycznie konsolidować serwery, wyłączać
        je lub włączać w zależności od potrzeb.
      </p>
      <p>
        Infrastruktura sieciowa również może skorzystać z wirtualizacji.
        Funkcje sieciowe można zwirtualizować, każde urządzenie sieciowe można
        podzielić na wiele urządzeń wirtualnych, które działają jako
        niezależne urządzenia. Przykłady obejmują podinterfejsy, interfejsy
        wirtualne, sieci VLAN i tablice routingu. Wirtualny routingu nazywany
        jest wirtualnym routingiem i przekazywaniem.
      </p>
      <h2 id="3.13.3.SDN">3.13.3. Sieć definiowana programowo</h2>
      <p>
        SDNy czy sieci definiowane programowo jest model konfigracji sieci, w
        którym za logikę sieci odpowiedzialny jest centralny sterownik,
        natomiast samym urządzeniom pozostaje przekazywanie danych ze źródła
        do miejsca docelowego.
      </p>
      <p>
        Urządzenia sieciowe zawierają dwie płaszczyzny.
      </p>
      <ul>
        <li><strong>Płaszycznę sterowania</strong> - służy do podejmowania
          decyzji dotyczących przekazywania. Płaszczyzna sterowania
          odpowiedzialna jest za switching czy routing.</li>
        <li><strong>Płaszczynę danych</strong> - zwykle struktura przełącznika
          łącząca różne porty sieciowe w urządzeniu. Płaszczyzna danych
          każdego urządzenia służy do przesyłania strumieni ruchu.</li>
      </ul>
      <p>
        Technologią podobną do SDN jest CEF, ponieważ nie wykorzystuję ona
        procesora do przekazywania pakietów są one kierowane w oparciu o
        informacje zapisane w FIB, która jest wstępnie wypełniana na podstawie
        tablicy rouingu przez płaszczyznę sterowania. CEF jednak nie usuwa
        z urządzenia warstwy kontrolnej w przeciweństwie do SDN. W przypadku
        modelu SDN urządzenia będą skupiać się wyłącznie na przekazywaniu
        danych.
      </p>
      <p>
        Opracowano dwie główne architektury sieciowe w celu obsługi
        wirtualizacji sieci:
      </p>
      <ul>
        <li><strong>Software-Defined Network</strong> - architektura sieci,
          która wirtualizuje sieć, oferując nowe podejście do administrowania
          siecią i zarządzania nią, które ma na celu uproszczenie i
          usprawnienie procesu administracyjego.</li>
        <li><strong>Cisco Application Centric Infrastructure</strong> - 
          Specjalnie zaprojektowane rozwiązanie sprzętowe do integracji
          przetwarzania w chmurze i zarządzania centrum danych.</li>
      </ul>
      <p>
        Składniki SDN mogą obejmować:
      </p>
      <ul>
        <li><strong>OpenFlow</strong> - zarządzanie ruchem miedzy urządzeniami,
          protokół jest podstawowym elementem budowania rozwiązań SDN.</li>
        <li><strong>OpenStack</strong> - platforma wirtualizacji i orkiestracji
          zaprojektowana do budowania skalowalnych środowisk chmury i 
          zapewnienia rozwiązania IaaS.</li>
        <li><strong>Inne komponenty</strong> - I2RS, TRILL, Cisco FP i IEEE
          802.1aq.</li>
      </ul>
      <p>
        W tradycyjnej architekturze routera lub przełącznika funkcje
        płaszczyzny sterowania i płaszczyzny danych występują w tym samym
        urządzeniu. Decyzje o routingu i przekierowanie pakietów są
        odpowiedzialne za system operacyjny urządzenia. W SDN zarządzanie
        płaszczyzną sterowania jest przeniesione do scentralizowanego
        kontrolera SDN. Kontroler SDN do jednostka logiczna, która umożliwia
        administratorom sieci zarządzanie ruchem w sieci i dyktowanie tego w
        jaki sposób płaszczyzna danych urządzeń ma obsługiwać ruch sieciowy.
        Organizuje, pośredniczy i ułatwia komunikację między aplikacjami i
        elementami sieci. 
      </p>
      <h2 id="3.13.4.SDNcontrolers">3.13.4. Kontrolery SDN</h2>
      <p>
        Wszystkie złożone funkcje wykonywane są przez kontroler. Sterownik
        wypełnia tablę przepływu, przełącznika zarządzają tablemi przepływu.
        Kontrole SDN wykorzystuje protokół <em>OpenFlow</em> do komunikacji
        z przełącznikami kompatybilnymi z tym protokołem, protokół ten jest
        bezpieczny wykorzystuje TLS. Przełącznika <em>OpenFlow</em> łączą się
        ze sobą oraz z urządzeniami końcowymi.
      </p>
      <p>
        Cisco ACI to rozwiązanie sprzętowe do integracji chmury obliczeniowej
        i zarządzania centrum danych. Na wysokim poziomie element zasad sieci
        jest usuwany z płaszczyznyc danych. Upraszcza to sposób tworzenia
        sieci centrów danych.
      </p>
      <p>
        Są trzy podstawowe elementy architektury ACI:
      </p>
      <ul>
        <li>Profil sieci aplikacji (ANP)</li>
        <li>Kontroler infrastruktury zasad aplikacji - APIC</li>
        <li>Przełączniki Cisco Nexus z serii 9000</li>
      </ul>
      <p>
        Sieć szkieletowa Cisco ACI składa się z APIC i przełączników Cisco
        Nexus 9000 wykorzystując dwupoziomową technologię 
        <strong>Spine-Leaf</strong>. Przełączniki szkieletowe <em>Leaf</em>,
        zawsze przyczepiają się do przełączników dostępowych <em>Spine</em>, 
        ale
        nigdy nie łączą się ze sobą. Podobnie przełączniki dostępowe <em>Spine</em>
        łączą się tylko do przełączników szkieletowych <em>Leaf</em> oraz do
        rdzenia. W tej dwuwarstwowej topologii wszystko jest oddzielone jednym
        przeskokiem od wszystkie innego.
      </p>
      <p>
        Istnieją trzy typy sieci definiowanych programowo.
      </p>
      <ul>
        <li><strong>SDN na urządzeniu</strong> - urządzenia są programowalne
          przez aplikacje na samym urządzeniu lub na serwerze.</li>
        <li><strong>SDN na kontrolerze</strong> - Ten typ sieci SDN
          wykorzystuje centralny kontroler, mający wiedzę o wszystkich
          urządzenia w sieci.</li>
        <li><strong>SDN na zasadach</strong> - wariacja SDN-a opartego na
          kontrolerze, zawiera dodatkową warstwę abstrackcji do automatyzacji
          zaawansowanych zadań konfiguracyjnych.</li>
      </ul>
      <h2 id="3.13.summary">3.13. Podsumowanie</h2>
      <p>
        Ten rodział poruszył temat wirtualizacji, dowiedzieliśmy się czym są 
        maszyny wirtualne oraz hiperwizory 1 i 2 typu. Dowiedzieliśmy się, że
        możemy wirtualizować elementy sieciowe. Na koniec zapoznaliśmuy się
        z pojęciem SDN oraz kontrolerami sieci definiowanej programowo.
      </p>
      <h1 id="3.14.networkautomatization">3.14. Automatyzacja sieci</h1>
      <p>
        Automatyzacja to każdy proces samoczynnie napędzany, który ogranicza i
        potencjalnie eliminuje potrzebę interwencji człowieka.
      </p>
      <h2 id="3.14.1.dataformats">3.14.1. Formaty danych</h2>
      <p>
        Format danych to sposób przechowywania i wymiany danych w 
        ustrukturyzowanym formacie. Jednym z takich formatów jest HTML.
      </p>
      <p>
        Formaty danych mają reguły strukturę podobną do tych, które mamy w
        przypadku języków programowania i języków pisanych. Każdy format danych
        będzie miał miał specyficzne cechy:
      </p>
      <ul>
        <li>Składnia, która obejmuje typy używanych nawiasów takich jak
          <strong>[]</strong>, <strong>()</strong>, <strong>{}</strong>,
          użycie białych znaków, cudzywsłowów i innych.</li>
        <li>Sposób reprezentowania obiektów, takich jak znaki, łańcuchy, listy
          i tablice.</li>
        <li>Sposób reprezentacji par klucz/wartość. Klucz jest zawsze po
          lewej stronie identyfikuje lub opisuje dane. Wartości po prawej
          stronie to same dane i mogą być znakiem, łańcuchem, liczbą, listą lub
          innym typem danych.</li> 
      </ul>
      <p>
        Systemy automatyzacji mogą wykorzystywać następujący typy danych:
      </p>
      <ul>
        <li>JavaScript Object Notation - <strong>JSON</strong></li>
        <li><strong>YAML</strong></li>
        <li><strong>XML</strong></li>
      </ul>
      <h2 id="3.14.2.apiinterface">3.14.2. Interfejs API</h2>
      <p>
        API to oprogramowanie, które umożliwia innym aplikacjom dostęp do jego
        danych lub usług. Jest to zestaw reguł opisujących, w jaki sposób jedna
        prosta aplikacja może współdziałać z inną, oraz instrukcje
        umożliwiające taką interakcje. Użytkownik wysyła żądanie API do serwera
        z prośbą o podanie określonych informacji i otrzymuje odpowiedź z
        serwera wraz z żądanymi informacjami.
      </p>
      <p>
        Możemy wyróżnić trzy rodzaje api, patrząc względem dostępności:
      </p>
      <ul>
        <li>Otwarte/publiczne interfejsy API.</li>
        <li>Wewnętzne/prywatne interfejsy API.</li>
        <li>API dla partnerów.</li>
      </ul>
      <p>
        Usługa sieci Web to usługa dostęna w Internecie za pośrednictwem sieci
        WWW. Istnieją cztery rodzaje interfejsów API dla usług internetowych.
      </p>
      <ul>
        <li><em>Simple Object Access Protocol</em> - SOAP</li>
        <li><em>Representational State Transfer</em> - REST</li>
        <li><em>eXtensible Markup Language-Remote Procedure Call</em> - XML-RPC</li>
        <li><em>JavaScript Object Notation-Remote Procedure Call</em> - JSON-RPC</li>
      </ul>
      <h2 id="3.14.3.rest">3.14.3. REST</h2>
      <p>
        REST to styl achitektury do projektowania aplikacji internetowych.
        Odnosi się do stylu architektury internetowej, która ma wiele 
        podstawowych cech i reguluje zachowanie klientów i serwerów.
        Najprościej mówiąc REST API to API, które działa w oparciu o protokół
        HTTP. Definiuje zestaw funkcji, którego programiści mogą używać do
        wykonywania żądań i odbierania odpowiedzi za pośrednictwem protokółu
        HTTP, takich jak GET i POST. Zgodność z ograniczeniami architektury
        REST jest ogólnie określana jako <em>RESTful</em>. Interfej API można
        uznać za <em>RESTful</em>, jeśli ma następujące funkcje:
        <strong>Klient-Serwer</strong>, <strong>Bezstanowość</strong>,
        <strong>Pamięć podręczna</strong>.
      </p>
      <p>
        Zasoby i usługi internetowe, takie jak interfejsy API <em>RESTful</em>,
        są identyfikowane za pomocą identyfikatora URI. <strong>URI</strong>
        to ciąg znaków, który identyfikuje określony zasób sieciowy.
      </p>
      <p>
        Przeanalizujmy sobie poniższe żądanie API:
      </p>
<pre class="code-block">
http://www.mapquestapi.com/directions/v2/route?outFormat=json&amp;key=KEY&amp;from=Warsaw,PL&amp;to=Berlin,DE
</pre>
      <p>
        W tym URI występuje: serwer API 
        (<code class="code-inline">http://www.mapquestapi.com/</code>),
        żądany zasób (<code class="code-inline">directions/v2/route</code>),
        następnie przechodzimy już do formatu właściwego zapytania. Zapytanie
        rozpoczyna się podaniem żądanego formatu danych -
        <code class="code-inline">?outFormat=json</code>, następnie podawany
        jest klucz (metoda uwierzytelniania, kontroli dostępu do API) -
        <code class="code-inline">&amp;key=KEY</code>. Na końcu podajemy
        parametry, o które chcemy zapytać - 
        <code class="code-inline">&amp;from=Warsaw,PL&amp;to=Berlin,DE</code>.
      </p>
      <p>
        Większość serwisów udostępniających API, udostępnia także dokumentację
        opisując dostępne zasoby oraz w jakis sposób uzyskać do nich dostęp.
        Natomiast do tworzenia API możemy wykorzystać takie programy jak
        <strong>Postman</strong> lub języki programowania takie jak Python.
      </p>
      <h2 id="3.14.4.toolsforconfigurationmanagement">3.14.4. Narzędzia do zarządzania konfiguracją</h2>
      <p>
        Podsiadając wiele urządzeń do skonfigurowania, możemy konfigurować je
        po kolei i spędzić nad tym trochę czasu. Poźniej możemy kontrolować
        nasze urządzenia za pomocą protokołu SNMP. Jednak jeśli przyjdzie nam
        zmienić jedną opcję na 80 przełącznikach? To znów spędzimy nad tym
        trochę czasu. Takie kolejne konfigurowanie to tradycyjny sposób
        konfiguracji i zarządzania nią.
      </p>
      <p>
        Jedna jeśli nasz sieć jest dość pokaźnych rozmiarów lub lubimy wyzwania
        możemy wykorzystać informacje zawarte w tym rozdziale i przygotować
        jedno z narzędzi automatyzacji. Na codzień takie narzędzia używane są
        np. do przygotowania środowiska do uruchomienia bądź rozwijania 
        różnego rodzaju aplikacji. Do wyboru mamy:
      </p>
      <ul>
        <li><strong>Ansible</strong></li>
        <li><strong>Chef</strong></li>
        <li><strong>Puppet</strong></li>
        <li><strong>Saltstack</strong></li>
      </ul>
      <p>
        Wykorzystują one żądania RESTful API do automatyzacji zadań i mogą
        być skalowalne na tysiące urządzeń.
      </p>
      <h2 id="3.14.summary">3.14. Podsumowanie</h2>
      <p>
        W tym rodziale poruszylimy kwestie automatyzacji oraz jej składników
        takich jak choćby interfejsy API. Dowiedzieliśmy się również w jaki
        sposób automatycznie skonfigurować wiele urządzeń. Ten temat kończy
        3 moduł oraz cały kurs CCNA. Poniżej znajdują się opisy zadań
        przygotowawczych oraz opis samego egzaminu praktycznego.
      </p>
      <p>
        P.S. Jeśli ktoś na podstawie tego materiału uważa, że zda egzamin
        certyfikacyjny. To jak go zda do niech się do mnie odezwie.
      </p>
      <p>
        Opisy egzaminów próbnych oraz egzaminu koncowego, są takie same 
        - w przypadku częsci pisemnej (testów), jak we wcześniejszych modułach
        więc ich opis jest daremny.
      </p>
      <h2 id="3.ptsa">3. Przygotowanie do egzaminu praktycznego (PTSA) - ENSA</h2>
      <p>
        Przygotowanie do egzaminu praktycznego z modułu 3, obejmowało takie
        zagadnienia jak: OSPF w konfiguracji przez interfejs, OSPF w
        konfiguracji przez polecenie <code class="code-inline">network</code>.
        Ustawienie identyfikatorów dla routerów w OSPF, ustawienie priorytetu
        routera na interfejsie dla OSPF. Ustawienie statycznej bramy domyślnej
        i rozpropagowanie jej za pomocą OSPF, ustawienie na jednym z łączy
        jednego odrębnych odstępów czasu: dla wysłania pakietów <em>hello</em>
        oraz oczekiwania na nie (<em>dead interval</em>), ustawienie wartości
        referencyjnej dla obliczania kosztów ścieżek, ustawienie stałego kosztu
        dla jedenej z scieżek oraz wyłącznie rozgłaszania pakietów <em>hello</em>
        gdzie to jest zbędne. W drugiej częsci mamy do skonfigurowania NAT
        statyczny dla jednego hosta 1:1 oraz PAT do puli adresów. W części
        trzej konfigurujemy ACL-ki: pierwsza ma zezwalać na dostęp zdalny dla
        jednej z sieci, druga chronić jedną sieć przed dostępem drugiej sieci.
        Natomiast zadaniem ostatniej jest zabronienie jednej z sieci na dostęp
        do serwera WWW w innej sieci, ale pozostawienie innego ruchu. Część
        czwarta ostatnia, chce aby ustawić na jednym routerów serwer NTP
        (serwer w sieci tego routera) oraz skopiowanie obrazu IOS na serwer
        przy użyciu TFTP.
      </p>
      <h1 id="3.finalpractice">3. Egzamin praktyczy - ENSA</h1>
      <p>
        Topologia logiczna zadania składa się z trzech routerów, dwóch
        przełączników, dwóch PC oraz dwóch serwerów. Do zadań konfiguracyjnych
        należy: zaadresowanie wszystkich interfejsów routerów oraz uruchomienie
        łączy. Serwerom należy statycznie przypisać adresy. Na routerze
        podłączonym do sieci z PC-ami, należy skonfigurować DHCP dzierżawiące
        adresy od .100 do .200, dostarczyć adres bramy, adres serwera DNS
        (jeden z serwerów) oraz odpowiednią nazwę domeny. Na tym urządzeniu
        należy skonfigurować NAT dla wszystkich hostów. Na wszystkich routerach
        należy skonfigurować OSPF, wykorzystując do numer procesu 1, sieci
        powinny być skonfigurowane za pomocą słowa kluczowego 
        <code class="code-inline">network</code>, na jednym z routerów jest
        powinien być interfejs <em>loopback</em>, emulujący łącze do sieci
        publicznej. Należy skonfigurować je jako bramę domyślną tego urządzenia
        i udostępnić tę trasę przez OSPF. Ostatnim zadaniem jest 
        skonfigurowanie ACL, które pozwolą PC-om na dostęp do usługi WWW (80)
        serwera WWW oraz usługi FTP (20/21) serwera FTP.
      </p>
      <h1>Koniec kursu CCNA</h1>
    </div>
   </body>
</html>
