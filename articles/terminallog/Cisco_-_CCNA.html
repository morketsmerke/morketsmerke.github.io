<!DOCTYPE html>
<html>
  <head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://i.ibb.co/khy45hh/mm.png">
		<link rel="stylesheet" type="text/css" href="/style.css">
		<style>
			.code-block {
				text-align: left;
			}
			ul {
				text-align: left;
			}
      p {
        text-align: justify;
      }
      .exam_tip {
        border: solid 1px black;
      }
      body {
        width: 99%;
        height: 100vh;
      }
      .main {
        width: 100%;
      }
		</style>
	</head>
	<body>
		<div class="main">
    <div id="tableOfContent">
      <h1>Cisco Systems - Cisco Certified Network Associate</h1>
      <ul class="toc">
        <li><a href="#0.introduction">0. Wstęp</a></li>
        <li><a href="#1.module1">1. Moduł 1: Wprowadzenie do sieci komputerowych - ITN</a>
          <ul class="toc">
          <li><a href="#1.1.networkingtoday">1.1. Sieci dzisiaj</a></li>
          <li><a href="#1.2.basicswitchandendpointconfig">1.2. Podstawowa konfiguracja przełącznika oraz urządzenia końcowego</a>
          <li><a href="#1.3.protocolsandmodels">1.3. Protokoły i modele</a></li>
          <li><a href="#1.partialexam">Egzamin cząstkowy</a></li>
          <li><a href="#1.4.physicalayer">1.4. Warstwa fizyczna</a></li>
          <li><a href="#1.5.numbersystems">1.5. Systemy liczbowe</a></li>
          <li><a href="#1.6.datalinklayer">1.6. Warstwa łącza danych</a></li>
          <li><a href="#1.7.ethernetswitching">1.7. Przełączanie Ethernetu</a></li>
          <li><a href="#1.8.networklayer">1.8. Wartstwa sieciowa</a></li>
          <li><a href="#1.9.adresresolution">1.9. Rozwiązywanie adresów</a></li>
          <li><a href="#1.10.basicrouterconfig">1.10. Podstawowa konfiguracja routera</a></li>
          <li><a href="#1.11.ipv4adressing">1.11. Adresacja IPv4</a></li>
          <li><a href="#1.12.ipv6adressing">1.12. Adresacja IPv6</a></li>
          <li><a href="#1.13.icmpprotocol">1.13. Protokół ICMP</a></li>
          <li><a href="#1.14.transportlayer">1.14. Warstwa transportowa</a></li>
          <li><a href="#1.15.applicationlayer">1.15. Warstwa aplikacji</a></li>
          <li><a href="#1.16.networksecurityfundamentals">1.16. Wprowadzenie do bezpieczeństwa sięci</a></li>
          <li><a href="#1.17.buildingasmallnetwork">1.17. Budowanie małej sieci</a></li>
          <li><a href="#1.examplepartialexam">Przykładowy egzamin cząstkowy - Tematy: 16-17</a></li>
          <li><a href="#1.mockexam">Przykładowy egzamin próbny - ITN</a></li>
          <li><a href="1.finalexam">Egzamin finałowy - ITN</a></li>
          <li><a href="1.ptsa">Finałowy egzamin praktyczny - Packet Tracer - ITN</a></li>
          </ul>
        </li>
      </ul>
      <p>
        Źródła:
      </p>
      <ol>
        <li>Kurs CCNAv7: Introduction to Networks - netacad.com. Dostęp do
          kursu zapewniony podczas kursów Cisco CCNA na jeden z uczelnii
          wyższych w Polsce. <em>Autor nieznany/wielu autorów na przestrzeni
          lat.</em>
        </li>
      </ol>
    <p class="footer">
        ~xf0r3m<br />
				2024; COPYLEFT; ALL RIGHTS REVERSED;
		</p>
      </div>
      <div id="content">
      <div id="contentHeader">
<pre id="divisionBaner">
            _               _
        _  | |  _       _  | |  _
    _  | | | | | |  _  | | | | | |  _
   |_| |_| | | |_| |_| |_| | | |_| |_|
           |_|             |_| 
    ____   ___   ____     ____    ___  
   / ___| |_ _| / ___|   / ___|  / _ \ 
  | |      | |  \___ \  | |     | | | |
  | |___   | |   ___) | | |___  | |_| |
   \____| |___| |____/   \____|  \___/ 
                                     
</pre>
        <p id="contentHeaderLink" class="header_link">
	    &#9760;&nbsp;<a href="https://morketsmerke.github.io">morketsmerke</a>&nbsp;&#9760;
        </p>
      </div>
      <h1 id="0.introduction">0. Wstęp</h1>
      <p>
        Pod koniec wakacji zeszłego roku w pracy (tej nowej, której szukałem
        przygotowując materiał o RHCSA), kierownik podsłał mi propozycje kursu
        z certyfikacji Cisco CCNA, która odbywała się na wydziale informatyki
        jednej z miejscowych uczelni wyższych w kraju. Pomyślałem sobie, że 
        może być
        ciekawie, ale poźniej trochę ekscytacja opadła po pierwsze, ponieważ 
        sieci nigdy nie były obiektem jakiś moich większych zainteresowań.
        Dalej nie wiem jako to się stało, że pracuje jako administrator sieci.
        Więc po dłużyszych działaniach biurokratycznych (kurs w pełni 
        finansowany
        przez pracodawce - umowa szkoleniowa - lojalka - 5500 brutto albo przez
        3 lata zostajesz w firmie), zapisałem się na kurs. Na pierwszych
        zajęciach nawet nie byłem, zmęczony byłem podróżom z i do stolicy.
        Dostałem maila od wykładowcy z dostępem do wydziałowego moodle-a oraz
        platformy netacad.com. Gdzie można było pobrać Packet Tracer, same
        wykłady prowadzone na wydziale były super, dużo gadania, dyskusji
        czy luźnych rozkmin, a i gdzieś tam miałem szanse dotknąć sprzetu
        Po trzecim temacie przyszedł czas tzw. egzaminów cząstkowych -
        zwykłych testów, które należało zaliczyć. Wyszystko ładnie pięknie, ale
        z czegoś się trzeba przygotować, nie uważam, że wykładowca nas nie
        przygotował, ale pierwszy egzamin cząstkowy, już pokazywał że wiedza
        z wykładów jest ciekawa i na pewno niesie ze sobą wiecej wartości
        merytorycznej niż to co oferuje firma Cisco.
        Same materiały zapewnione przez Cisco do nauki dla kursantów są
        wątłej jakości, tłumaczenie na język polski to ło Matko, ło Jezu.
        A prezentacje w PowerPoint w języku angielskim, potrafią nie zawierać
        przykładów, czy zawierać błędy w poleceniach lub opisy mogą niepasować
        do niektórych terminów (ale nie to, że merytorycznie coś jest nie tak,
        są po prostu zamienione w tabeli miejscami XD), same egzaminy również
        zawierają pokrętnie napisane pytania. Na przykład pytania o topologię
        hybrydową, o której nie ma ani słowa materiałach. Albo brak poprawnej
        odpowiedzi odnośnie działania zapory pakietów czy zapory stanowej.
        Także mentalnie trzeba się przygotować do tego, że chociaż by się
        nie wiadomo jak mocno starać, to i tak nie uzyskać się maksymalnej
        ilości punktów, albo kolejne ciekawa rzecz, wg. kryteriów oceniania
        kursu CCNA firmy Cisco, to pracownik, który próbuje złamać hasło innego
        pracownika jest słabością a nie atakiem. Także wiecie z czym macie
        doczynienia, dlatego I DON'T GIVE A SHIT czy zdam czy niezdam. Mi
        zostanie wiedza z kursów i miło spędzony czas na wykładach a
        pracodawcy wystarczy zaświadczenie o ukończeniu kursu wydane przez
        uniwersytet. Kiedyś nie było to możliwe, kiedyś trzeba było mieć
        wszystko zaliczone, aby iść dalej teraz już nie.
      </p>
      <p>
        Przedstawione tutaj informacje mogą nie tyle mijać się z celem, co być
        nie kompletne na dzień dzisiejszy. Celem tego kursu najwidoczniej nie
        jest nauka z zakresu sieci komputerowych (poniekąd), tylko uzyskanie
        certyfikatów, chcąc certyfikować ludzi na całym świecie trzeba utworzyć
        pewien standard, a zdający muszą zdawać zgodnie z tym standardem
        (kluczem). 
      </p>
      <h1 id="1.module1">1. Moduł 1: Wprowadzenie do sieci komputerowych</h1>
      <h1 id="1.1.networkingtoday">1.1. Sieci dzisiaj</h1>
      <p>
        W dzisiejszym świecie wszystko chce być podłączone do Internetu, czy
        korzystać z zasobów rozległych sieci. Nie zawsze tak było. Czasy się
        zmieniają, i to czy podążymy za nimi to już nasza decyzja. Każdy
        obecnie ma smartfon w kieszeni, u większości osób na ścianie wiszą
        telewizory, które służą do oglądania stricte kanałów telewizyjny a
        platform streamingowych. Czy kto kolwiek zadał sobie to pytanie jak
        to wszystko funkcjonuje chociaż raz. Raczej nie, po co sobie 
        zaprzątać tym głowe. Ten rozdział nie będzie o tym, ponieważ to 
        są materiały przygotowe przez Cisco, więc można go 
        potraktować z przymrużeniem oka.
      </p>
      <h2 id="1.1.1.networkcomponents">1.1.1. Komponenty sieciowe</h2>
      <p>
        Każdy komputer w sieci nazywany jest hostem lub urządzeniem końcowym.
        Serwery są komputerami, które dostarczają informacji urządzeniom
        końcowym, np. serwery pocztowe, serwery WWW czy serwery plików.
        Klienci to komputery, które wysyłają żądania do serwerów aby
        otrzymać odpowiednie informacje.
      </p>
      <p>
        Możliwe jest aby jedno urządzenie było jednocześnie klieten oraz
        serwerem. Jest to połączenie <em>Peer-to-Peer</em>. Tego typu
        rozwiązania są dobre do małych sieci.
      </p>
      <p>
        Po za hostem w sieciach istnieją jeszcze urządzenia pośrednie. Ich
        zadaniem jest łączyć ze sobą hosty. Do takich urządzeń możemy
        zaliczyć routery, przełączniki, zapory sprzętowe, czy access pointy.
      </p>
      <p>
        Do łączenia ze sobą hostów wykorzystuje się media. To media
        transmisyjne pozwalają na przesył informacji między komponentami
        sieciowymi. Z pośród mediów transmisyjnych możemy wyróżnić okablowanie
        miedziane - wykorzystujące impulsy elektryczne, okablowanie
        światłowodowe - wykorzysujące impulsy świetlne czy powietrze
        wykorzysujące fale radiowe oraz mikrofalowe.
      </p>
      <h2 id="1.1.2.commontypesofnetworks">1.1.2. Powszechne rodzaje sieci</h2>
      <p>
        Sieci mają różne rozmiary. Sieci domowe zazwyczaj łączą ze sobą kilka
        komputerów/urządzeń. Sieci klasy SOHO, mogą wcale nie różnić się od
        sieci domowych. Mogą być to oddziały firmy, a jedyną róznicą może być
        dobrej
        klasy łącze, aby można było bezpiecznie i bez trudu komunikować się
        z siecią w siedzibie firmy. Średnie i duże firmy mogą łączyć ze
        sobą setki jak nie tysiące komputerów w tym kilka budynków. Największe
        sieci to te o zasięgu globalnym, np. Internet.
      </p>
      <p>
        Sieci można podzielić na podstawie: zasiegu, liczby podłączonych 
        użytkowników, liczby i rodzaju dostępnych usług czy obszaru
        odpowiedzialności. Istnieją dwa rodzaje najczęściej spotykanych 
        sieci: sieci lokalne (LAN) oraz sieci rozległe (WAN). Sieci lokalne
        obejmują co najwyżej obszar kilku budynków, gdzie sieci rozległe
        mogą łączyć ze sobą naprawdę odległe sieci lokalne.
      </p>
      <p>
        Internet jest zbiorem połączonych ze sobą sieci LAN i WAN. LAN-y
        razej łączą się przez inne sieci WAN. Intenet nie należy do nikogo,
        chociaż są grupy takie jak ICANN oraz IETF, które zajmują się
        przestrzenią adresową czy rozwojem protokółów. 
      </p>
      <p>
        Intranet jest zbiorem LAN-ów oraz WAN-ów w obrębie jednej organizacji
        oznacza to również, że do tej sieci mają dostęp tylko określeni
        członkowie organizacji oraz inni, którzy mogą się zautoryzować.
        Firmy korzystają z ekstranetu aby zapewnić dostęp do wybranych zasobów
        ściśle określonym użytkownikom.
      </p>
      <h2 id="1.1.3.internetconnections">1.1.3. Połączenia z Internetem</h2>
      <p>
        Obecnie zwykli użytkownicy w domach oraz duże organizację mogą łączyć
        się z internetem w różny sposób. Każdy głównie korzysta ze sposobów na
        który pozwalają warunki technicze naszej lokalizacji oraz zasób
        naszego portfela.
      </p>
      <p>
        Użytkownicy domowi wykorzystują takie łącza jak: 
        kablówka/sieć osiedlowa, DSL, połączenia radiowe oraz połączenia sieci
        komórkowej.
      </p>
      <p>
        Organizacje mają o wiele wieksze potrzeby oraz wymagania dotyczące
        łączności internetowej dlatego też wymagane jest dobre jakości stałe
        łącze dlatego też odpowiednimi dla nich łączami będzie biznesowa wersja
        DSL, łącze dzierżawcze oraz sieć miejska, która może skupiać 
        najważniejsze ośrodki badawczo-przemysłowe w danym mieście.
      </p>
      <p>
        Dziś internet staje się podobnie niezbędnym medium jak prąd czy woda.
        Obecnie rezygnuje się z telefonów czy telewizji na rzecz własnie
        internetu. Za pomocą właśnie internetu możemy prowadzić rozmowy
        telefoniczne czy oglądać telewizje. Takie zajwisko nazywane jest
        <strong>konwergencją</strong> sieci. Sieć telewizyjna oraz sieć 
        telefonicza zostały połączone w jedną jak stał się internet.
      </p>
      <h3 id="1.1.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/1.5.7-packet-tracer---network-representation_pl-PL.pdf">Reprezentacja sieci - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/1.5.7-packet-tracer---network-representation_pl-PL.pka">Reprezentacja sieci - zadanie</a>
      </p>
      <h2 id="1.1.4.reliablenetworks">1.1.4. Niezawodność sieci</h2>
      <p>
        Architektura sieciowa odnosi się do technologii wspierających
        infrastrukturę, która przenosi dane przez sieć. Istnieją cztery
        podstawowe cechy charakterystyczne, które muszą być podwaliną każdej
        architektury sieciowej, aby móc spełnić oczekiwania użytkowników. Są
        nimi: <strong>odporność na błędy</strong>,
        <strong>skalowalność</strong>, <strong>QoS</strong> czy
        <strong>bezpieczeństwo</strong>.
      </p>
      <p>
        Sieci z odpornością na błędy ograniczają wpływ problemu po przez
        zmniejszenie dotkniętych nim urządzeń. W sieciach taką tolerancją
        błędów, może być zapewnienie połączeń nadmiarowych. Oczwywiście wymaga
        to zastosowania bardziej zaawansowanych technologii.
      </p>
      <p>
        Skalowalne sieci komputerowe, można w prosty i szybki sposób
        rozszerzyć bez wpływu na wydajność pozostałych użytkowników.
        Projektanci sieci projektują ją zgodnie ze standardami oraz powszechnie
        wykorzystywanymi protokołami, aby zapewnić jej skalowalność.
      </p>
      <p>
        OoS - ang. <em>Quality of Service</em> jest podstawowym mechanizmem
        używanym do zapewnienia niezawodności dostarczenia danych do wszystkich
        użytkowników. Za pomocą zastosowanej polityki QoS routery mogą regulować
        przesył ruchu danych czy przesyłanie głosu.
      </p>
      <p>
        Są dwa główne rodzaje bezepieczeństwa sieci jaki trzeba zapewnić:
        <strong>bezpieczeństwo infrastruktury sieciowej</strong> oraz
        <strong>bezpieczeństwo informacji</strong>. Na bezpiczeństwo sieci
        składa się fizyczne zabezpieczenie urządzeń sieciowych oraz ochronę
        przed nieuprawnionym dostępem do nich. Natomiast bezpieczeństwo
        informacji polega na zabepieczeniu informacji lub danych przesyłanych
        przez sieć. Są trzy podstawowe cele bezpieczeństwa sieci:
        <strong>poufność</strong> - tylko określeni odbiorcy mogą odczytać
        przesyłane dane, <strong>integralność</strong> - zapewnienie, że dane
        nie zostały zmienione podczas transmisji oraz
        <strong>dostępność</strong> - zapewnienie o niezawodnym
        dostępie do danych przez autoryzowanych użytkowników.
      </p>
      <h2 id="1.1.5.networktrends">1.1.5. Trendy sieciowe</h2>
      <p>
        Role sieci wymagają ciągłych zmian, ciągłego dostosowania aby nądąrzyć
        za ciągle pojawiąjcymi się na rynku urządzeniami. Możemy wyróżnić kilka
        nowych trendów, majacych wpływ na organizację:
      </p>
      <ul>
        <li><strong>Bring Your Own Device</strong> (BYOD)</li>
        <li><strong>Współpraca online</strong></li>
        <li><strong>Komunikacja wideo</strong><li>
        <li><strong>Przetwarzanie chmurowe</strong></li>
      </ul>
      <p>
        Bring Your Own Device (BYOD), ang. <em>przynieś swoje urządzenie</em>,
        pozwala użytkownikom używać ich własnych urządzenie co daje im więcej
        możliwości oraz większą elastyczność. BYOD pozwala użytkownikom
        końcowym na używanie ich własnych (ulubionych) narzędzi. BYOD oznacza
        dowolne urządzenie w posiadaniu rożnych osób, używane gdzie kolwiek.
      </p>
      <p>
        Współpraca online pozwala wspólną pracę nad wieloma projektami z
        różnymi ludźmi na odległość z pośrednictwem sieci. Do tego celu
        często wykorzystywan są takie aplikacje jak MS Teams czy Cisco Webex.
        Takie podjeście swietnie odnajduje się biznesie czy edukacji.
      </p>
      <p>
        Połączenia wideo mogą być wykonywane przez kogo kolwiek gdzie kolwiek
        jest są one poteżnym narzędziem do komunikacji z innymi. Konferencje
        wideo stały się wręcz wymogiem do efektywnej współpracy.
      </p>
      <p>
        Przetwarzanie chmurowe pozwala na przechowywanie osobistych danych na
        na serwerach w internecie. Możliwe jest również dostarczanie zasobów
        komputerów (np. w celach wirtualizacji) jak i samych aplikacji.
        Przetwarzanie chmurowe jest obsługiwane najczęsciej przez ogromne
        korporacje takie jak Amazon czy Google. Mozemy wyróżnić cztery rodzaje
        <em>chmur</em>:
      </p>
      <ul>
        <li><strong>Publiczne</strong>, z których każdy może korzystać, za
          darmo lub opłatą według zużycia zasobów.</li>
        <li><strong>Prywatne</strong>, do wykorzystania przez spcyficzne
          organizacje takie jak np. rząd.</li>
        <li><strong>Hybrydowe</strong>, łączące ze soba funkcję na przykład
          chmur prywatnych jak i tych niestandardowych.</li>
        <li><strong>Niestandardowe</strong>, tworzona dla specjalnych potrzeb
          organizacji. Może być prywatna i np. wykorzystywać zasoby chmury
          publicznej.</li>
      </ul>
      <h2 id="1.1.6.networksecurity">1.1.6. Bezpieczeństwo sieci</h2>
      <p>
        Bezpieczeństwo jest integralną częścią sieci, bez znaczenia na
        jej wielkość. Musi ono zostać zaimplentowane w taki sposób aby nie
        wpłyneło za bardzo na wymagania dotyczące łączności. Zabezpieczenie
        sieci angażuje wiele protokołów, technologii, urządzeń, narzędzi czy
        technik w celu zabepieczenia danych oraz złagodzenia zagrożeń, które
        mogą pochodzić jak najbardziej z zewnątrz ale ich źródło może być
        równie dobrze z wewnątrz organizacji.
      </p>
      <p>
        Z pośród zagrożeń zewnętrznych możemy wymień takie jak:
      </p>
      <ul>
        <li>Wirusy, robaki czy konie trojańskie</li>
        <li>Oprogramowanie typu <em>spyware</em> czy <em>adware</em></li>
        <li>Ataki typu <em>0-day</em></li>
        <li>Ataki podmiotu zagrożenia</li>
        <li>Ataki odmowy usługi</li>
        <li>Ataki kradzieży oraz fałszowania danych</li>
        <li>Kradzież tożsamości</li>
      </ul>
      <p>
        Natomiast zagrożenia wewnętrzne to między innymi:
      </p>
      <ul>
        <li>Zgubione lub ukradzone urządzenia</li>
        <li>Przypadkowe nadużycia przez pracowników</li>
        <li>Złośliwy pracownik</li>
      </ul>
      <p>
        Zabepieczenia powinny obejmować wiele warstw, składać się z większej
        ilości rozwiązań. Dla małej sieci domowej, wystarczy dobrej jakości
        program antywirusowy zainstalowany na urządzeniach końcowych oraz
        firewall blokujący nieautoryzowanych dostęp do sieci.
      </p>
      <p>
        Przy czym dla większych sieci stosuje się nieco bardziej wyrafinowane
        rozwiązania takie jak: dedykowany firewall, listy kontroli dostępu
        (ACL), systemy zapobiegania włamaniom (IPS), wirtualne sieci prywatne
        (VPN). Zrozumienie bezpieczeństa sieci rozpoczyna się od dobrego
        zrozumienie infrastruktury sieci, w tym przełączników oraz routerów.
      </p>
      <h2 id="ch1summary">Podsumowanie</h2>
      <p>
        Tym rozdziałem rozpoczynamy kurs. W ramach tego rodziału poznaliśmy
        współczene trendy sieciowe oraz to jak w obecnych czas istotne jest
        połączenie z Intenetem za pośrednictwem nawet najmniejszej sieci.
      </p>
      <h1 id="1.2.basicswitchandendpointconfig">1.2. Podstawowa konfiguracja przełącznika oraz urządzenia końcowego</h1>
      <p>
        W tym rodzdziale nie bedziemy skupiać się na konfiguracji urządzenia
        końcowego, jakby tytuł sugerował. To wydaje mi się, że każdy potrafi,
        prawda? Skupimy się na zapoznaniu z system IOS, będącym oprogramowaniem
        urządzeń firmy Cisco oraz jak wyglądają takie podstawowe czynności,
        które należy wykonać na tym urządzeniu przed już bardziej ukierunkowaną
        na konkretne urządzenie konfiguracją.
      </p>
      <h2 id="1.2.1.ciscoiosaccess">1.2.1. Dostęp do systemu Cisco IOS</h2>
      <p>
        Słowem wstępu systemy komputerowe składają się z sprzętu oraz
        oprogramowania. Aby uruchamiać specyficzne oprogramowanie potrzebujemy
        platformy programowej zapewniającej wszystkie niezbędne składniki do
        uruchomienia wybranych programów. Tym jest właśnie system operacyjny.
        Systemy operacyjne składają się z jądra, przestrzeni użytkownika oraz
        powłoki. Powłoka z kolei jest to interfejs pozwalający na
        prowadzenie interakcji z systemem operacyjnym a co za tym idzie z
        naszym sprzętem komputerowym. Powłoką może być interfejs graficzny lub
        program dający dostęp do wiersza polecenia oraz interpretujący co
        zostało w nim zapisane. Systemami składającymi się z jadra oraz powłoki
        są najczęściej systemy wbudowane takie jak Cisco IOS.
      </p>
      <p>
        Dostęp do IOS możemy uzyskać na 3 sposoby: połaczeniem konsolowym
        za pomocą kabli szeregowych połączanych do portu szeregowego
        komputera oraz do portu konsolowego urządzenia. Jeśli urządzenie jest
        przywrócone do ustawień fabrycznych to raczej może nie być innej
        możliwości. Połączenia szeregowe w przypadku urządzeń Cisco mogą być
        zestawione przy użyciu istniejącego okablowania sieciowego.
        Innym sposobem jest wykorzystanie połączeń przy użyciu protokołów
        SSH oraz Telnet. Przyczym warto mieć na uwadzę, że Telnet nie jest
        bezpiecznym protokołem, ponieważ przesyła on informacje za pomocą
        jawnego tekstu. Programów do połączenia się z urządzeniami Cisco jest
        kilka, najpopularniejszym z nich jest chyba program 
        <strong>PuTTY</strong>, zapewnia on wspracie dla wszystkich
        wymienionych rodzajów połączeń.
      </p>
      <h2 id="1.2.2.iosnavigation">1.2.2. Nawigacja po systemie IOS</h2>
      <p>
        Po połączeniu z naszym urządzeniem do dyspozycji będziemy mieć dwa
        tryby wykonywania poleceń <strong>tryb użytkownika EXEC</strong>
        znak zachęty może wyglądać wówczas tak:
      </p>
<pre class="code-block">
Router&gt;
Switch&gt;
</pre>
      <p>
        Tryb ten jest domyślnym uruchamiany zaraz po podłączeniu się do
        urządzenia o ile urządzenie nie wymaga logowania. Tryb ten zapewnia
        ograniczoną liczbę poleceń i pozwala na wydanie kilku poleceń
        monitorujących.
      </p>
      <p>
        Innym trybem jest <strong>tryb uprzywilejowany EXEC</strong>, jest 
        coś w rodzaju
        administratora urządzenia, ten tryb pozwala na zmianę trybów
        konfiguracji, w tym trybie znaki zachęty mogą wyglądać w ten sposób:
      </p>
<pre class="code-block">
Router#
Switch#
</pre>
      <p>
        W urządzeniach Cisco, mamy dostępny
        <strong>tryb konfiguracji globalnej</strong>, wykorzystywany do
        konfiguracji parametrów urządzenia. Ten
        tryb posiada dwa podtryby: <strong>tryb konfiguracji linii</strong>,
        za jego pomocą konfigurujemy dostęp do urządzenia. Drugin podtrybem
        jest <strong>tryb konfiguracji interfejsu</strong>.
      </p>
      <p>
        Po podłączeniu się do urządzenia, automatycznie przechodzimy do trybu
        użytkownika EXEC, chcąc przejść do trybu uprzywilejowanego wydajemy
        polecenie <code class="code-inline">enable</code>. W tym trybie możemy
        już skonfigurować kilka opcji, jeśli jednak interesuje nas konfiguracja
        dostępu do urządzenia (a powinna), to żeby przjeść do trybu
        konfiguracji globalnej wydajemy polecenie
        <code class="code-inline">configure terminal</code>, z tego trybu
        możemy powrócić wydając polecenie 
        <code class="code-inline">exit</code>. Przjście do konfiguracji dostępu
        wymaga polecenia <code class="code-inline">line</code> oraz podania
        trybu dostępu, który chcemy skonfigurować. Dla połączenia szeregowego
        podajemy <code class="code-inline">console 0</code> dla połączeń
        zdalnych podajemy <code class="code-inline">vty</code>, czyli konsole
        wirtualną, następnie ilość jednoczesnych połączeń dla 5 podajemy
        <code class="code-inline">0 4</code>.
      </p>
      <p>
        Poszczególne tryby możemy opuścić za pomocą polecenia
        <code class="code-inline">exit</code>, wówczas powrócimy do trybu
        poprzedniego. Jeśli chcemy zakończyć konfigurację i powrócić do
        trybu uprzywilejowanego EXEC wydajemy polecenie
        <code class="code-inline">end</code>. Warto zwrócic uwagę na to, że
        wraz ze zmienymi trybami zmieniają się znaki zachęty, więc wiemy
        gdzie jesteśmy.
      </p>
<pre class="code-block">
Switch&gt;enable
Switch#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#line console 0
Switch(config-line)#exit
Switch(config)#int vlan1
Switch(config-if)#end
Switch#
%SYS-5-CONFIG_I: Configured from console by console

Switch#
</pre>
      <h2 id="1.2.3.commandstructure">1.2.3. Struktura poleceń</h2>
      <p>
        Polecenia składają się z samego polecenia, często identyfikującego
        program, który będzie uruchamiany. Następnie występują słowa kluczowe
        oraz argumenty, często będące opcjami oraz modyfikatorami działania
        głównego polecenia (programu).
      </p>
      <p>
        IOS posiada funkcje pomocy wywoływaną za pomocą znaku zapytania
        (<strong>?</strong>). Za jego pomocą możemy dostępne w danym trybie
        polecenia, lub sprawdzić dostępne argumenty dla podanych polecen.
      </p>
      <p>
        Podczas wpisywanie poleceń możemy posłużyć się skrótami poleceń,
        podając tyle znaków, aby powłoka IOS mogła je jednoznacznie
        zidentyfikować. 
      </p>
<pre class="code-block">
Switch#con
% Ambiguous command: "con"
Switch#con?
configure  connect  
Switch#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#
</pre>
      <p>
        IOS wprowadza również kilka skrótów klawiszowych. Dobrze odnajdą się
        tutaj użytkownicy powłoki BASH, gdyż IOS jest kompatybilny z
        GNU Readline. Pod Tab-em mamy dopełnianie poleceń. W przypadku
        stronicowania (<code class="code-inline">"--More--"</code>) mamy do
        dyspozycji klawisz <em>Enter</em>, który pozwoli na wyświetlenie
        kolejnej linii stronicowanego tekstu lub <em>Spacją</em> kolejną
        stronę. Każde naciśniecie innego klawisza spowoduje zakończenie
        wyświetlania i przejście do trybu EXEC. Zakończenie wprowadzania
        konfiguracji możemy dokonąć albo za pomocą wyżej wymienionych poleceń,
        albo za pomocą skrótów takich Ctrl+z lub Ctrl+c. Do przerwania
        polecenia ping, traceroute czy odwzorowania nazw domenowych należy
        wykorzystać kombinację klawiszy <strong>Ctrl+Shift+6</strong>
      </p>
      <h3 id="1.2.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.3.7-packet-tracer---navigate-the-ios_pl-PL.pdf">Nawigacja w IOS - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.3.7-packet-tracer---navigate-the-ios_pl-PL.pka">Nawigacja w IOS - zadanie</a>
      </p>
      <h3 id="1.2.3.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/2.3.8-lab---navigate-the-ios-by-using-tera-term-for-console-connectivity_pl-PL.pdf">Nawigacja w IOS za pomocą Tera Term przez konsolę</a>
      </p>
      <h2 id="1.2.4.basicdeviceconfiguration">1.2.4. Podstawowa konfiguracja urządzeń</h2>
      <p>
        Jedno z podstawowych czynności jakie należy wykonać dokonując
        pierwszej konfiguracji urządzenia z system IOS jest zmiana jego nazwy.
        Dokonujemy tego za pomocą polecenia
        <code class="code-inline">hostname</code>, podają wybraną nazwę jako
        argument polecenia. Nazwy muszą zaczynać się od litery, nie zawierać
        spacji, muszą zakończyć się literą lub cyfrą, zawierać tylko litery,
        cyfry lub myślniki. Nazwa nie może przekraczać 64 znaków. Aby
        przywrócić domyślną nazwę należy użyć polecenia:
        <code class="code-inline">no hostname</code>.
      </p>
      <p>
        Następną czynnością jest zabezpieczenie dostępu do urządzenia, przy
        użyciu hasła. Te czynności musimy wykonać w trybie konfiguracji
        linii za równo dla konsoli szeregowej jak i konsoli wirtualnych
        wykorzystywanych przez połączenia SSH oraz Telnet. W trybie
        konfiguracji globalnej
        (<code class="code-inline">configure terminal</code>), przechodzimy
        do konfiguracji linii połączenia szergowego
        (<code class="code-inline">line console 0</code>), teraz możemy
        ustawić hasło, pamiętając o zasadach bezpiecznych haseł. Ustawiamy
        hasło (<code class="code-inline">password</code>) oraz włączamy
        dostęp do trybu EXEC za pomocą polecenia
        <code class="code-inline">login</code>. Tę samą czynność powtarzamy dla
        konsoli wirtualnych, przyczym warto pamiętać, że IOS pozwala na 
        16 jednoczesnych połączeń więc do przejścia w tryb konfiguracji linii
        wykorzystujemy następujące polecenie
        <code class="code-inline">line vty 0 15</code>
      </p>
<pre class="code-block">
Switch#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#line console 0
Switch(config-line)#password cisco
Switch(config-line)#login
Switch(config-line)#exit
Switch(config)#line vty 0 15
Switch(config-line)#password cisco
Switch(config-line)#login
Switch(config-line)#exit
</pre>
      <p>
        Hasła, które widnieją na powyższym przykładnie do najtrudniejszych
        nie należą nie mniej jednak co z tego jeśli hasło będzie trudne. Jeśli
        są one przechowywane w postaci jawnego tekstu. Aby się o tym przekonać,
        możemy wyświetlić obecną konfigurację za pomocą polecenia
        <code class="code-inline">show running-config</code>, wydanego w
        uprzywilejowanym trybie EXEC.
      </p>
<pre class="code-block">
...
line con 0
 password cisco
 login
!
line vty 0 4
 password cisco
 login
line vty 5 15
 password cisco
 login
...
</pre>
      <p>
        Hasła te możemy zaszyfrować wydając w trybie konfiguracji globalnej
        polecenie
        <code class="code-inline">service password-encryption</code>.
      </p>
<pre class="code-inline">
Switch(config)#service password-enc
Switch(config)#service password-encryption
Switch(config)#exit
Switch#
%SYS-5-CONFIG_I: Configured from console by console

Switch#show running-config
...
!
line con 0
 password 7 0822455D0A16
 login
!
line vty 0 4
 password 7 0822455D0A16
 login
line vty 5 15
 password 7 0822455D0A16
 login
...
</pre>
      <p>
        Kiedy dostęp do trybu użytkownika jest chroniony hasłem, możemy
        zabezpieczyć tryb uprzywilejowany wydając odpowiednie polecenie
        w trybie konfiguracji globalnej.
      </p>
<pre class="code-block">
Switch(config)#enable secret class
Switch(config)#exit
</pre>
      <p>
        Przy czym <code class="code-inline">class</code> jest własnie tym
        ustawionym hasłem. Ostatnią czynnością będzie ustawienie informacji
        na temat tego, że jeśli ktoś się podłączy do naszego urządzenia, to że
        nie życzymy sobie żadnego nieupoważnionego dostępu. Do tego celu
        wykorzystamy polecenie
        <code class="code-inline">banner motd # wiadomość #</code>, polecenie
        to wydajemy w trybie konfiguracji globalnej. Komunikat musi znajdować
        się między krzyżykami (<strong>#</strong>) i nie musi być to włącznie
        jedna linia (stąd znak początku i końca wiadamości).
      </p>
<pre class="code-block">
Switch(config)#banner motd # Osobom nieupowaznionym, wstep wzbroniony! #
Switch(config)#exit
</pre>
      <h2 id="1.2.5.savingconfig">1.2.5. Zapisywanie konfiguracji</h2>
      <p>
        Już we wcześniejszych przykładach wyświetlaliśmy obecnie działającą
        konfigurację. Ta konfiguracja rezyduje w pamieci RAM, która jest
        pamięcią ulotną. Jeśli urządzenia straci zasilanie i ono powróci
        to utracimy całą tą konfigurację, dlatego też urządzenia Cisco mają
        pamięć NVRAM, która jest nie ulotna. Ale to w naszej gestii jest aby
        tę konfigurację zapisać, chyba że dojdzie do sytuacji, że nie będziemy
        chcieli jej zapisać. Nie mniej jednak, aby zapisać konfirgurację w
        NVRAM należy w trybie uprzywilejowanym EXEC wydać następujące
        polecenie:
      </p>
<pre class="code-block">
Switch#copy running-config startup-config
Destination filename [startup-config]? 
Building configuration...
[OK]
Switch#
</pre>
      <p>
        Jeśli podejrzewamy, że obecna konfiguracja jest wadliwa możemy wrócić
        do konfiguracji startowej z NVRAM, wydając w trybie uprzywilejowanym
        EXEC polecenie:
      </p>
<pre class="code-block">
Switch#reload
Proceed with reload? [confirm]
</pre>
      <p>
        Przywrócenie urządzenia do ustawień fabrycznych dokonujemy za pomocą
        dwóch poleceń wydanych w trybie uprzywilejowanym EXEC.
      </p>
<pre class="code-block">
Switch#erase startup-config 
Erasing the nvram filesystem will remove all configuration files! Continue? [confirm]
[OK]
Erase of nvram: complete
%SYS-7-NV_BLOCK_INIT: Initialized the geometry of nvram
Switch#reload
Proceed with reload? [confirm]
</pre>
      <p>
        Korzystając z programu PuTTY możemy rejestrować naszą sesję połączenia
        z urządzeniem do pliku. W ten sposób możemy zrzucić sobie
        konfigurację do pliku tekstowego. Ustawienia <em>session/logging</em>.
      </p>
      <h2 id="1.2.6.configureipadressing">1.2.6. Konfiguracja adresacji IP</h2>
      <p>
        Z racji tego, że pomineliśmy konfigurację hostów z systemem Windows 10.
        Możemy przejść od razu do systemu IOS. W przypadku przełączników
        występuje coś takiego jak <strong>SVI</strong> - wirtualny interfejs
        przełącznika i to jemu nadajemy adres w przypadku tego urządzenia.
        W trybie konfiguracji globalnej przechodzimy do interfejsu <em>vlan1</em>
        następnie za pomocą polecenia
        <code class="code-inline">ip address 192.168.1.2 255.255.255.0</code>
        nadajemy mu adres IP, następnie musimy aktywować ten interfejs za
        pomocą polecenia <code class="code-inline">no shutdown</code>. Poniżej
        znajduje się przykład, pokazujący te czynności.
      </p>
<pre class="code-block">
Switch(config)#int vlan1
Switch(config-if)#ip addr 192.168.1.2 255.255.255.0
Switch(config-if)#no shutdown

Switch(config-if)#
%LINK-5-CHANGED: Interface Vlan1, changed state to up

Switch(config-if)#
Switch(config-if)#exit
</pre>
      <h3 id="1.2.6.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.5.5-packet-tracer---configure-initial-switch-settings_pl-PL.pdf">Konfiguracja ustawień początkowych przełączników - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.5.5-packet-tracer---configure-initial-switch-settings_pl-PL.pka">Konfiguracja ustawień początkowych przełączników - zadanie</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.7.6-packet-tracer---implement-basic-connectivity_pl-PL.pdf">Realizacja podstawowej łączności - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.7.6-packet-tracer---implement-basic-connectivity_pl-PL.pka">Realizacja podstawowej łączności - zadanie</a>
      </p>
      <h2 id="ch2summary">Podsumowanie</h2>
      <p>
        W tym rozdziale zapoznaliśmy z system IOS firmy Cisco, poznaliśmy
        składnie poleceń, funkcję pomocy oraz przydatne skróty klawiszowe.
        Na koniec skonfigurowaliśmy przełącznik w podstawowym stopniu.
      </p>
      <h3 id="1.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.9.1-packet-tracer---basic-switch-and-end-device-configuration_pl-PL.pdf">Podstawowa konfiguracja przełącznika i urządzenia końcowego - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/2.9.1-packet-tracer---basic-switch-and-end-device-configuration_pl-PL.pka">Podstawowa konfiguracja przełącznika i urządzenia końcowego - zadanie</a>
      </p>
      <h3 id="1.2.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/2.9.2-lab---basic-switch-and-end-device-configuration_pl-PL.pdf">Podstawowa konfiguracja przełącznika i urządzenia końcowego</a>
      </p>
      <h1 id="1.3.protocolsandmodels">1.3. Protokoły i modele</h1>
      <p>
        Za pomocą protokół oraz modeli możemy wyjaśnić w jaki sposób urządzenia
        podłączone do sieci mogą uzyskać dostęp do jej zasobów.
      </p>
      <h2 id="1.3.1.therules">1.3.1. Zasady</h2>
      <p>
        Sieci komputerowe mogą być rożne pod względem wielkości oraz złożoności.
        Nie jest wystarczające połączenie między nimi, potrzebne jest również
        ustalenie wspólnych metod komunikacji. W każdej komunikacji istnieją
        trzy elementy: źródło (nadawca), cel (odbiorca) oraz kanał (medium),
        który umożliwia komunikację między jej składnikami.
      </p>
      <p>
        Większość komunikacji zarządzana jest za pomocą protokołów. Protokoły
        są zestawem zasad, które należy przestrzegać, aby komunikacja mogła
        dojść do skutku i te zasady mogą być rożne w zależności od protokołu, a
        strony komunikacji muszą je zaakceptować.
      </p>
      <p>
        Protokoły chcąc brać udział w komunikacji sieciowej muszą spełnić takie
        wymagania jak: kodowanie wiadomości, jej formatowanie oraz
        enkapsulacja, wielkość wiadomości czy możliwości jej dostarczenia
        są istotnym czynnikiem tutaj może być to rozłożenie etapów komunikacji
        w czasie.
      </p>
      <p>
        Kodowanie jest proces zmiany formy wiadomości do celów transmisji.
        Natomiast dekodowanie jest procesem odwrotnym do kodowania. Wiadomość
        powraca do pierwotnej formy w celu interpretacji.
      </p>
      <p>
        Wysyłana wiadomość musi mieć odpowiednią formę lub strukture. Zależy
        to od medium przez jakie jest przesyłana. Wiadomości przesyłane przez
        sieci muszą zostać skonwertowane do postaci bitów. Bity te są poźniej
        zamieniane na impulsy świetlne, dźwięk czy impulsy elektryczne. 
        Odbiorca musi ten proces odwrócić, aby móc odczytać wiadomość.
      </p>
      <p>
        Jak wspomniano istotny w komunikacji może być czas, w tym takie
        zagadnienia jak <strong>kontrola przepływu</strong>, która zarządza
        prędkością transmisji. Definiuje jak dużo informacji można przesłać i
        z jaką prędkością może ona zostać dostarczona. Inną wartoscią jest
        czas odpowiedzi, który określa ile jedna ze stron może czekać na
        odpowiedź od drugiej. Kolejnym czynnikiem definiującym poniekąd czas
        jest dostęp do łącza, w którym określane jest kiedy można wysłać
        wiadomość. Zapobiega to tworzeniu kolizji - sytuacji kiedy dwóch
        nadawców zaczyna nadawać na tym samym kanale w tym samym czasie. 
        Niektóre algorytmy
        dostępu do łącza wykrywają kolizje i organizują retransmisje
        uszkodzonych danych inne posiadają mechnizmy pozwalające na ich
        uniknięcie.
      </p>
      <p>
        Istnieje kilka sposobów na dostarczenie wiadomości. Najprostszą z nich
        <strong>unikast</strong>, mamy jednego nadawcę oraz jednego odbiorcę.
        W inny przypadku wiadomość może trafić do wielu odbiorców będących
        częścią tej samej grupy - <strong>multikast</strong>. Ostatni rodzaj
        dostarczenia to wiadomość skierowana do wszystkich odbiorców - 
        <strong>broadkast</strong>.
      </p>
      <h2 id="1.3.2.protocols">1.3.2. Protokoły</h2>
      <p>
        Protokoły sieciowe składają ze zbioru reguł. Mogą one określać
        zastosowania programowe oraz sprzetowe, jak i oba. Każdy protokół
        posiada własne funkcje, format czy zasady.
      </p>
      <p>
        Urządzenia wykorzystują uzgodnione protokoły. Mogą mieć one takie
        funkcje jak: adresacja - pozwalająca na identyfikację nadawcy i 
        odbiorcy; niezawodność - gwarancje dostarczenia danych; kontrolę
        przepływu - określającą optymalną prędkość dla przesyłanych danych;
        sekwencyjność - unikalne oznaczanie danych podczas transmisji;
        detekcję błędów - określenie czy jakieś dane nie zostały uszkodzone
        podczas transmisji oraz interfejs aplikacji - pozwalający na
        komunikację aplikacji z pośrednictwem tego protokołu.
      </p>
      <p>
        W komunikacji sieciowej wymagane jest stosowanie kilku protokołów,
        Każdy znich posiada swój format danych. Takimi protokłami są Ethernet,
        Internet Protocol (IP), Transmission Control Protocol (TCP) czy
        Hypertext Transfer Protocol (HTTP)
      </p>
      <h2 id="1.3.3.protocolsuites">1.3.3. Zestawy protokołów</h2>
      <p>
        Protokoły muszą być w stanie współpracować z innymi protokołami.
        <strong>Zestawy protokołów</strong> to grupa powiązanych ze sobą
        protokołów niezbędnych do komunikacji lub zbiór reguł współpracujących
        ze sobą w celu rozwiązania problemów. Protokoły są często postrzegane
        w kategoriach warstw: warstw wyższych czy niższych, które mają
        za zadanie przenieść dane oraz dostarczyć usługi warstwom wyższym.
      </p>
      <p>
        Obecnie mamy kilka różnych zestawów protokołów. Najczęściej spotykany,
        zarzązany przez IETF - 
        <strong>Internet Protocol Suite lub TCP/IP</strong>,
        <strong>Open Systems Interconnection protocols</strong>, rozwijany
        przez organizacje takie jak ISO wraz z ITU. Pozostałe takie
        <strong>Apple Talk</strong> czy <strong>Novell NetWare</strong> nie są
        już rozwijane ani stosowane w szerszej skali.
      </p>
      <p>
        Protokoły TCP/IP operują na warstwie aplkacji, transportu, czy 
        internetu. Protokołami dostępu do łącza, a zarazem najpopularniejszymi
        dla sieci LAN są Ethernet oraz WLAN (sieć bezprzewodowa). 
      </p>
      <p>
        Protokół TCP/IP jest stosem protokołów wykorzystywanym przez sieć
        Internet i zawierającą wiele protokołów. Jest to otwarty ogólnodostępny
        standard, który może zostać użyty przez dowolnego producenta. Jest on
        oparty na standardach przyjętych przez przedsiębiorstwa sieciowe oraz
        aktualizowany przez instytucje standaryzujące w celu zapewniania
        interoperatywności.
      </p>
      <p>
        Proces komunikacji w stosie TCP/IP wygląda następująco, że przeglądarka
        internetowa enkapsuluje stronę (przy użyciu TCP/IP) i wysyła ją do
        klienta. Klient
        dekapsuluje przy użyciu stosu TCP/IP i przekazuje do przeglądarki.
      </p>
      <h2 id="1.3.4.standardsorganizations">3.4. Organizacje standaryzujące</h2>
      <p>
        Otwarte standardy zapewniają interoperacyjność, konkurencyjność i
        innowacyjność. Organizacje standaryzujące są niepowiązane z żadnym z
        producentów sprzętu, organizacjami non-profit. Powołane aby 
        rozwijać koncepcje otwartych standardów.
      </p>
      <p>
        Wśród organizacji pracujących nad standardami internetowymi możemy
        wyróżnić dwie podstawowe: <strong>Internet Engineering Task Force
        (IETF)</strong> czy <strong>Internet Engieering Research Task Force
        (IRTF)</strong> - zajmują się one rozwojem oraz utrzymaniem
        wielu kluczowych technologii internetowych w tym stosu TCP/IP. Innymi
        organizacjami zajmującymi się Internet jest <strong>Internet
        Corporation for Assigned Names and Numbers (ICANN)</strong> oraz
        <strong>Internet Assigned Numbers Authority (IANA)</strong>, te
        organizacje
        zajmują się zarądzaniem różnego rodzaju numeracją, jak np. adresy IP,
        numery portów czy nazwami domenowymi.
      </p>
      <p>
        Innym rodzajemy standardów są standardy elektroniczne czy
        komunikacjyne, Do najpopularniejszych należą:
      </p>
      <ul>
        <li><strong>Institute of Electrical and Electronics Engineers (IEEE)</strong>
          - powołane w celach utworzenia standardów dla sektorta energetycznego,
            ochrony zdrowia, telekomunikacji oraz sieci komputerowych.</li>
        <li><strong>Electronic Industries Alliance (EIA)</strong> - opracowuje
          standardy dla okablowania elektrycznego, złączy czy standardu stojaków
          oraz szaf 19-calowych, w których montowane są urządzenia sieciowe
          oraz serwery.</li>
        <li><strong>Telecomunications Industry Association (TIA)</strong> -
          Rozwija standardy w osprzęcie radiowym, stacjach bazowych telefonii
          komórkowej, urządzenia typu VoIP, komunikacji satelitarnej oraz
          wielu innych.</li>
        <li><strong>International Telecommunications Union-Telecommunication
          Standardization Sector (ITU-T)</strong> - określa standardy np.
          dla kompresji wideo, protokołu Telewizji Internetowej (IPTV) czy
          łączy szerokopasmowych takich jak DSL.</li>
      </ul>
      <h3 id="1.3.4.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/3.4.4-lab---research-networking-standards_pl-PL.pdf">Badanie standardów sieciowych</a>
      </p>
      <h2 id="1.3.5.referencemodels">1.3.5. Model odniesienia</h2>
      <p>
        Przez złożoność koncepcji wyjaśnienie oraz zrozumienie jak
        działa sieci, może być trudne. W tym celu posługujemy się modelem
        odniesienia, modelem warstwowym. Do tego celu można wykorzystać
        <strong>model ISO/OSI</strong> oraz <strong>model TCP/IP</strong>.
        Generalnie posługujemy się modelem TCP/IP, jeśli nie musimy zagłębić
        się zasady działania aplikacji. Warstwa SSL dla HTTP to ta sama
        warstwa modelu TCP/IP ale inna w modelu ISO/OSI. W nomenklatrzue
        rozwiązań firmy Cisco również używa się modelu ISO/OSI.
      </p>
      <p>
        Model odniesienia pomaga w projektowaniu protokołów, umożliwia
        współpracę producentów urządzeń, chroni przed wpływem technologii
        z innych warstw na siebie, dostarcza wspólnego języka do opisu funkcji
        oraz możliwości sieci.
      </p>
      <p>
        Model referencyjny OSI prezentuje się następująco:
      </p>
      <ul>
        <li><strong>Warstwa aplikacji</strong> - Zawiera protokoły wykorzystywane do
          komunikacji między procesami.</li>
        <li><strong>Warstwa prezentacji</strong> - Dostarcza ogólnej
          prezentacji danych przesyłanych między aplikacjami.</li>
        <li><strong>Warstwa sesji</strong> - dostarcza usług dla warstwy
          prezentacji i zarządza wymianą danych.</li>
        <li><strong>Warstwa transportowa</strong> - określa usługi dla
          segmentacji, transferu oraz ponownego złożenia danych dla
          poszczególnych połączeń.</li>
        <li><strong>Warstwa sieciowa</strong> - dostarcza usług w celu
          wymiany indywidualnych fragmentów danych poprzez sieć.</li>
        <li><strong>Warstwa łącza danych</strong> - określa metody wymiany
          ramek danych przez popularne media.</li>
        <li><strong>Warstwa fizyczna</strong> - określa znaczenie dla
          aktywacji, zarządzania i deaktywacji połączeń fizycznych.</li>
      </ul>
      <p>
        Natomiast model TCP/IP jest podobobny. Nie skupia on sie za bardzo na
        protokołach i aplikacjach oraz na warstwie fizycznej. Dlatego też z 7
        warstw zostały 4. Warstwy sesji, prezentacji oraz aplikacji zostały
        połączone w jedną warstwę aplikacji, natomiast warstwa fizyczna i
        łącza danych zostały połączone w jedną warstwę dostępu do łącza.
      </p>
      <h3 id="1.3.5.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/3.5.5-packet-tracer---investigate-the-tcp-ip-and-osi-models-in-action_pl-PL.pdf">Badanie modeli TCP/IP i OSI w działaniu - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/3.5.5-packet-tracer---investigate-the-tcp-ip-and-osi-models-in-action_pl-PL.pka">Badanie modeli TCP/IP i OSI w działaniu - zadanie</a>
      </p>
      <h2 id="1.3.6.dataencapsulation">1.3.6. Enkapsulacja danych</h2>
      <p>
        Segmentacja jest procesem rozbijania wiadmości na mniejsze jednostki.
        Multipleksacja jest procesem wysyłania wielu segmentów jednocześnie.
        Segmentacja ma dwie podstawowe zalety: zwiększa prędkość oraz 
        zwiększa wydajność.
      </p>
      <p>
        Sekwencyjnosć wiadomości jest procesem numeracji segmentów, zapewnia
        to możliwość dostarczenia wiadomości w takiej samej kolejności jak
        została wysłana.
      </p>
      <p>
        Enkapsulacja to proces, w którym protokoły dodają swoje dane, na każdym
        etapie tego procesu, PDU - <strong>jednostka danych protokołu</strong>
        (ang. <em>Protocol Data Unit</em>) ma inną nazwę aby odwzorować 
        jej funkcje. Nie ma jednej ogólnej nazwy dla PDU, chociaż stosuje w 
        mowie potocznej określenie <strong>pakiet</strong>. Są one nazywane
        powiązane protokołami stosu TCP/IP, opuszczając stos PDU nazywane są
        kolejno:
      </p>
      <ol>
        <li>Dane (strumień danych)</li>
        <li>Segment</li>
        <li>Pakiet</li>
        <li>Ramka</li>
        <li>Bity</li>
      </ol>
      <p>
        Enkapsulacja jest procesem, który jest przeprowadzany od z góry na dół.
        Górne poziomy przekazuje dane/PDU w dół do dolnych warstw, które
        obudowywują dane z góry w dane kontrolne PDU obecnej warstwy, aż do
        formy strumienia bitów. 
      </p>
      <p>
        Deenkapsulacja jest procesem odwrotnym, tutaj strumień bitów zamieniany
        jest do postacji ramki, kiedy dane wędrują w górę poszczególne warstwy
        dokonują przetwarzania swoich danych kontrolnych, a następnie usuwają
        swoje dane kontrolne i przekazują dane wyżej, aż do aplikacji.
      </p>
      <h2 id="1.3.7.dataaccess">1.3.7. Dostęp do danych</h2>
      <p>
        Obie warstwy: łacza danych oraz warstwa sieciowa, wykorzystują adresy
        aby dostaczyć dane od źródła do celu. Warstwa sieciowa wykorzystuje
        adresy IP do adresacji pakietów, w przypadku warstwy łącza danych
        wykorzystywane są adresy fizyczne kart sieciowych (adresy MAC).
      </p>
      <p>
        Pakiet IP zawiera dwa adresy IP, adres źródłowy określający twórcę
        wiadomości oraz adres docelowy określający odbiorcę.
      </p>
      <p>
        Adres protokół warstwy sieciowej dzielą się na dwie części: część
        sieciową (dla IPv4) lub prefiks (dla IPv6) oraz cześć hosta
        (dla IPv4) lub identyfikator interfejsu (IPv6). Urządzenia w tej samej
        sieci, mają takie same części sieciowe lub prefiksy.
      </p>
      <p>
        Urządzenia w tej samej sieci Ethernet, do adresacji ramek wykorzystają
        już właściwe dla adresy MAC przypisane do fizycznych kart sieciowych.
        Jeśli odbiorca znajduje się w innej sieci, to wówczas adres MAC nadawcy
        ulegnie zmianie, na adres MAC routera, tak aby odbiorca wiedział gdzie
        ma odesłać odpowiedź.
      </p> 
      <p>
        Ciekawie jest przypadku warstwy sieciowej, to jeśli odbiorca pakietu
        nie należy do naszej sieci wówczas pakiet IP zostanie zaadresowany
        docelowym adresm IP odbiorcy, ale ramka zostanie zaadresowana adresem
        <strong>bramy domyślnej</strong> - routera, który zapewnia nam dostęp
        do innej sieci. Każdy z hostów zawiera informacje jak ma adresować
        pakiety IP i przez jakie interfejsy (karty sieciowe) je wysłać.
        Brama domyślna jest hostem do którego należy przesłać pakiety, kiedy
        host nie wie gdzie ma je przesłać. Jest to trasa ostatniej szansy.
        Router przekazując ten pakiet już do sieci docelowej lub na swoją
        bramę przepakuje go w nową ramkę, opatrzoną w adresy fizyczne
        nadawcy (swojego interfejsu WAN) oraz odbiorcy. Ten pakiet może przejść
        kilka takich etapów zanim trafi do odbiorcy. Podobnie jest z
        odpowiedzią.
      </p>
      <h3 id="1.3.7.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/3.7.9-lab---install-wireshark_pl-PL.pdf">Instalacja programu Wireshark</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/3.7.10-lab---use-wireshark-to-view-network-traffic_pl-PL.pdf">Wykorzystanie programu Wireshark do badania ruchu sieciowego</a>
      </p>
      <h2 id="ch3summary">Podsumowanie</h2>
      <p>
        W tym rozdziale poznalismy w jaki sposób przebiega komunikacja i jakie
        warunki trzeba spełnić. Poznaliśmy protokoły, ich stosy oraz
        organizacje standaryzujące. Dowiedzielismy czym są modele odniesienia
        i doczego służą. Zapoznalismy się z enkapsulacją danych oraz jak
        faktycznie wygląda dostęp do danych.
      </p>
      <h1 id="1.partialexam">Egzamin cząstkowy</h1>
      <p>
        Po omówieniu 3 rozdziału spotkamy się z przedsmakiem egzaminu końcowego
        mianowicie egzaminem cząstkowym obejmującym od 2 do 3 tematów. W
        większości przypadków będą to trzy tematy. Egzamin składa się z pytań
        jednokrotnego oraz 2 lub 3-krotnego wyboru oraz pytań polegających
        na przypasowaniu definicji do pojęcia - oczywiście jest to pojęcie
        względne, ponieważ nie zawsze definicje oraz pojęcia faktycznie nimi
        będą. Taki przypadek możemy spotkać na podstawie przypisania opisu
        do konkretnego adresu. Egzaminy cząstkowe łączą test teoretyczny z
        zadaniem praktycznym do wykonania w Packet Tracerze. Na całość mamy
        60 minut. Liczba pytań wacha się od 30 do 35 pytań.
      </p>
      <p>
        Wszystkie egzaminy zdajemy na platformie
        <a href="netacad.com">netacad.com></a>. Mamy możliwość jednego
        podejścia oraz jednej poprawki przy czym poprawkę musi umożliwić nam
        prowadzący kurs. Do wyboru są dwa języki: ojczysty oraz język
        angielski. Z językiem ojczystym jak jest każdy wie. Przy czym warto
        dodać, że końcowy egzamin praktyczny jest wyłącznie w języku
        angielskim.
      </p>
      <h1 id="1.4.physicalayer">1.4. Warstwa fizyczna</h1>
      <p>
        Warstwa fizyczna skupia w sobie wiele technologii związanych z
        fizycznym podłączeniem hostów oraz standardów tych połączeń.
      </p>
      <h2 id="1.4.1.purposeofthephysicallayer">1.4.1. Przeznaczenie wartstwy sieciowej</h2>
      <p>
        Aby w ogóle komunikacja sieciowa mogła zajść potrzebne są połączenia
        fizyczne między jej stronami. W zależości od konfiguracji sieci
        połączenia mogą być przewodowe lub bezprzewodowe. Podłączenie do sieci
        uzyskujemy za pomocą urządzeń kart sieciowych wbudowanych w nasze
        urządzenia, oczywiście nie wszystkiego rodzaju połaczenia fizyczne
        mają taka samą wydajność.
      </p>
      <p>
        Warstwa fizyczna znajmuje się transportem bitów przez media sieciowe,
        odbiera ona ramkę z warstwy łącza danych koduje ją za pomocą serii
        sygnałów, które są następnie transmitowane za pomocą lokalnego medium.
        Warstwa fizyczna kodując i dekodując ramkę, kończy proces enkapsulacji
        lub rozpoczyna proces deenkapsulacji.
      </p>
      <h2 id="1.4.2.physicallayercharacteristics">1.4.2. Charakterystyka warstwy fizycznej</h2>
      <p>
        Standardy zastosowane w sprzęcie sieciowym są zarządzane przez wiele
        organizacji takich jak: ISO, EIA/TIA, ITU-T, ANSI, IEEE.
      </p>
      <p>
        Standardy warstwy fizycznej operują na dwóch płaszczyznach:
        kompnentów fizycznych, kodowania oraz sygnałów. Komponenty takie jak
        urządzenia sprzętowe, media czy różnego rodzaju wtyczki są
        odpowiedzialne z transmisję sygnału reprezentującego bity. Karty
        sieciowe, złacza, wtyczki czy same przewody są uwzględnione w
        standardach warstwy fizycznej.
      </p>
      <p>
        Kodowanie ma celu dostosowanie strumienia bitów do formatu
        rozpoznawalnego przez następne urządzenia w sieci poprzez użycie
        przewidywalnych schematów, które mogą być przez nie rozpoznane.
        Kodowanie obejmuje takie metody jak: Manchester, 4B/5B czy 8B/10B.
      </p>
      <p>
        Sygnały natomiast są sposobem reprezentacji bitów (wartości 1 oraz 0)
        w medium transmisyjnym. Metoda wybranej syganlizacji może być bardzo
        różna i często jest uzależniona oraz wykorzystywanego medium.
      </p>
      <p>
        Szerokość pasma jest możliwością nośną pasma. Dla cyfrowych szerokości
        pasma mierzona jest na podstawie ilości danych, które mogą zostać
        przesłane z jednego miejsca w drugie w określonej ilości czasu. Jak
        dużo bitów można przesłać w przeciągu jednej sekundy 
        (<strong>bps</strong>, <em>bits per second</em>). Właściwosci medium,
        wykorzystane technologie czy prawa fizyki mają wpływ na dostępną
        szerokość. Z szerokością pasma są związane pewne pojęcia.
      </p>
      <ul>
        <li><strong>Opóźnienia</strong> (ang. <em>latency</em>) - ilość czasu
          wraz opóźnieniami potrzebna danym do pokonania trasy z jedne do
          drugiego punktu.</li>
        <li><strong>Przepustowość</strong> (ang. <em>Throughput</em>) - miara
          transferu bitów przez medium transmisji w określonym odstępie czasu.</li>
        <li><strong>Przepustowość na poziomie aplikacji</strong>
          (ang. <em>Goodput</em>) - miara użytecznych danych przesłanych w
          w danej jednostce czasu.</li>
      </ul>
      <h2 id="1.4.2.coppercabling">1.4.2. Okablowanie miedziane</h2>
      <p>
        Okablowanie jest najczęściej stosowanym rodzajem okablowania w sieciach
        obecnie, jest ono tanie i łatwe do instalacji. 
      </p>
      <p>
        Posiada ono również swoje wady takie jak osłabienie sygnału wynikające
        z zadługiego pojedynczego odcinka przewodu oraz wrażliwość na róznego
        rodzaje zakłócenia elektromagnetycze w tym przesłuchy. 
      </p>
      <p>
        Ze względu na to, że okablowanie miedziane jest tak popularne pojawiły
        się rozwiązania powyższych problemów takich jak: wytyczne pojedynczego
        odcinka kabla, ekranowanie przewodów wraz uziemieniem skręcenie ze sobą
        poszczególnych przewodów w pary eliminując przesłuchy.
      </p>
      <p>
        Rodzaje kabli miedzianych:
      </p>
      <ul>
        <li><em>Unshielded Twisted-Pair Cable</em> - Kabel UTP</li>
        <li><em>Shielded Twisted-Pair Cable</em> - Kabel STP</li>
        <li><em>Coaxial Cable</em> - Kabel koncetryczny</li>
      </ul>
      <p>
        Kable UTP są najczęsciej spotykami przewodami sieciowymi, są one
        najczęściej zakończone za pomocą wtyku <strong>RJ-45</strong>,
        najczęściej łączą hosty z urządzeniami pośrednimi, jakimi jak
        przełączniki.
      </p>
      <p>
        Kable UTP składają się z zewnętrznej izolacji chroniącej kabel przed
        uszkodzeniami zewnętrznymi oraz skręconych par przewódów
        (skręcenie ma zadanie zniwelować przesłuchy) w kolorowych izolacjach
        mających na celu identyfikację każdego z przewodów, każdej z żył.
      </p>
      <p>
        Kable STP są rozszerzeniem kabli UTP o dodatkowe środki
        przeciwdziałające zakłóceniom, jak za folia aluminiowa otaczająca
        poszczególne pary czy siatka miedziana otaczająca wszystkie przewody.
      </p>
      <p>
        Ostatnim rodzajem kabli miedzianych są kable koncentryczne
        wykorzystywane do antent sieci bezprzewodowych oraz kablowych
        technologiach dostęp do Internetu, takich jak DOCSIS. Taki table
        składa się z zewnętrznej grubszej izolacji, siatki miedzianej
        niewelującej zakłócenia, plastikowej elastycznej izolacji przewodnika
        oraz przewodnika.
      </p>
      <h2 id="1.4.3.utpcabling">1.4.3. Okablowanie UTP</h2>
      <p>
        Kabel UTP składa się z 4 par oznaczonych kolorami przewodów skrecony
        ze soba wewnątrz giętkiej plastikowej izolacji. Kable UTP nie posiadają
        żadnej dodatkowej ochrony przez zakłóceniami. Zastosowane w kablach
        UTP takie rozwiązania jak <strong>znoszenie</strong>, każdy przewód w
        parze ma inną polaryzację, przez co skręcone ze sobą skutecznie znoszą
        zakłócenia generowane przez siebie czy wariacja w
        w ilości skręceń na ok. 30cm zapobiera przesłuchą powodowany przez
        inne pary przewodów pomagają w niwelowaniu przesłuchów. 
      </p>
      <p>
        Kable UTP podlegają standaryzacji, którą zarządza organizacja EIA/TIA.
        Definiują ona standarad TIA/EIA-568 w którym znajdują się takie
        zagadnienia jak: Typ kabla, jego długość, rodzaje wykorzystywanych
        wtyczek, metody terminacji przewódu (w tym instalacji) sposoby
        testowania. Parametrami elektrycznimi kabli UTP zajęła się organizacja
        IEEE i do dyspozycji mamy takie kategorie jak: kategoria 3,
        kategoria 5 lub 5e czy kategoria 6.
      </p>
      <p>
        Terminując kable, mamy dyspozycji dwa standardy oraz dwa rodzaje
        takiego zarobionego przewodu. Mianowicie standardy takie jak
        TIA/EIA T568B oraz T568A definiują ułożenie kolorowych przewodów we
        wtyczce. Obecnie standardem jest T568B, T568A wyszedł z użycia jednak
        przydaje się jego znajomość gdy musimy za pomocą sieci spiąć ze sobą
        dwa komputery. W wyżej wymienionych standardardach możemy ułożyć
        przewody w następujący sposób:
      </p>
      <ul>
        <li><strong>T568A</strong> -
          <ol>
            <li>biało-zielony</li>
            <li>zielony</li>
            <li>biało-pomarańczowy</li>
            <li>niebieski</li>
            <li>biało-niebieski</li>
            <li>pomarańczowy</li>
            <li>biało-brązowy</li>
            <li>brązowy</li>
          </ol></li>
        <li><strong>T568B</strong> - 
          <ol>
            <li>biało-pomarańczowy</li>
            <li>pomarańczowy</li>
            <li>biało-zielony</li>
            <li>niebieski</li>
            <li>biało-niebieski</li>
            <li>zielony</li>
            <li>biało-brązowy</li>
            <li>brązowy</li>
          </ol>
        </li>
      </ul>
      <p>
        Dwie możliwości zrobienia wtyczek, dają nam dwa rodzaje kabli:
      </p>
      <ul>
        <li><strong>Kabel prosty</strong> - zakończony z obu stron zgodnie ze
          jednym standardem. Obecnie wykorzystywany zgodnie ze standardem jest
          T568B, kabel wykorzystywany do większości połączeń.</li>
        <li><strong>Kabel krosowy</strong> - zakończony przy użyciu różnych
          standardów. Dzis może zostać wykorzystany do połączenia
          bezpośredniego, pomiędzy dwoma komputerami lub dwoma takimi samymi
          urządzeniami Cisco.</li>
      </ul>
      <h2 id="1.4.5.fiberopticcabing">1.4.5. Okablowanie światłowodowe.</h2>
      <p>
        Okablowanie światłowodowe nie jest tak popularne jak UTP, ze względu
        na drogi osprzęt oraz trudności w instalacji. Jest wstanie przesyłać
        dane na długie dystanse oraz z dużą szybkością, całkowicie odporne na
        zakłócenia elektromagnetyczne. Światłowody służa przewodzenia implusów
        świetlnych pomiędzy dwoma ich końcami z minimalną utratą sygnału, są
        zrobione z cienkich włókien bardzo czystego szkła, do zakodowania
        bitów w impulsy światła wykorzystują diody laserowe lub diody led.
      </p>
      <p>
        Światłowody dzielą sie na jedno i wielomodowe. W budowie różnią się
        w średnicy rdzenia, w światłowodzie jednomodowym jest on o wiele
        cieńszy, gdyż będzie on obsługiwać tylko jeden promień świetlny.
        Wykorzystanie światłowodów jednomodowych jest również dużo droższe, ale
        przesyłaja dane z ogromną prędkością na długi dystans. W światłowodach
        wielomodowych zachodzi zjawisko dyspersji, czyli rozpraszania się
        światła, dlatego też światłowody wielomodowe są stosowane na
        ograniczony dystans, ale dla wielu firm jest on zupełnie wystarczający.
      </p>
      <p>
        Z okablowaniem światłowodowym możemy spotkać się kilku rożnych
        rodzajach firm:
      </p>
      <ul>
        <li><strong>Sieci dużych firm</strong> - wykorzystanie światłowodu jako
          sieć szkieletowa w celu połączanie infastruktury.</li>
        <li><strong>Technologia FTTH</strong> - Usługa szerokopasmowego
          połączenia dla domów oraz małych firm.</li>
        <li><strong>Sieci długodystansowe</strong> - sieci łączące kraje czy
          większe miasta.</li>
        <li><strong>Podwodne światłowody morskie</strong> - swiatłowody o
          dużej przepustowości do połączeń transoceanicznych.</li>
      </ul>
      <p>
        Okablowanie światłowodowe jest wykorzystywane głównie jako sieć
        szkieletowa łączaca ze soba punkty dostępowe w wewnątrz budynku czy
        między budnkami na większym terenie.
      </p>
      <h2 id="1.4.6.wirelessmedia">1.4.6. Medium bezprzewodowe</h2>
      <p>
        Działanie sieci bezprzewodowych opiera się na nośności bitów danych
        z wykorzystaniem sygnałów elektromagnetycznych na częstotliwości
        radiowej lub mikrofalowej. Sieci tego typu zwiększają mobilność, jednak
        nie bez wad. 
      </p>
      <p>
        Głównymi problemami sieci bezprzewodowych jest zasięg, który może
        ograniczać nam dostęp za pośrednictwem tego medium. Kolejnym czynnikiem
        mogą być zakłócenia, które może powodować wiele urządzeń.
        Bezpieczeństwo jest również cechą decydującą, nawet jeśli nasza sieć
        działa na niewielkim obszarze, to napastnik może wyposażyć się w taki
        sprzęt który pozwoli mu zebranie kilku istotnych informacji. Dość
        istotną sprawą jest samo działanie sieci bezprzewodowej, urządzenia
        podłączone do takiej sieci współdzielą to samo łącze, więc jesli
        będzie ich stosunkowo dużo to przepustowość może spaśc dość znacząco.
      </p>
      <p>
        Organizacja IEEE wraz z inną instytucją standaryzjąca sporządziła
        serię standardów dla sieci bezprzewodowych. Opisują one miedzy
        innymi: metody kodowania sygnałów, częstotliwość oraz moc nadawania,
        odbiór sygnału oraz dekodowanie transmisji czy wytyczne dotyczące
        anten. Takim standardami są:
      </p>
      <ul>
        <li><strong>WiFi (IEEE 802.11)</strong> - technologia Wireless LAN</li>
        <li><strong>Bluetooth (IEEE 802.15)</strong></li>
        <li><strong>WiMAX (IEEE 802.16)</strong></li>
        <li><strong>Zigbee (IEEE 802.15.4)</strong></li>
      </ul>
      <p>
        Ogólnie to podłączenie sie do sieci WLAN może wymagać takich urzązeń
        jak punkt dostępowy, umożliwiający dostęp użytkownikom WLAN-u do sieci
        kablowej oraz karty sieciowe sieci bezprzewodowej. Przy zakupie
        sprzetu bezprzewodowego należy pamiętać aby ten sprzęt był kompatybilny
        ze sobą, często wystarczy zgodność obu wyżej wymienionych urządzeń
        z jednym ze standardów sieci bezprzewodowej.
      </p>
      <p>
        Przy rozważaniu wdrożenia sieci bezprzewodowej, trzeba również
        uwzględnić dla niej odpowiednią politykę bezpieczeństwa.
      </p>
      <h3 id="1.4.6.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/4.6.5-packet-tracer---connect-a-wired-and-wireless-lan_pl-PL.pdf">Łączenie przewodowych oraz bezprzewodowych sieci LAN - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/4.6.5-packet-tracer---connect-a-wired-and-wireless-lan_pl-PL.pka">Łączenie przewodowych oraz bezprzewodowych sieci LAN - zadanie</a>
      </p>
      <h3 id="1.4.6.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/4.6.6-lab---view-wired-and-wireless-nic-information_pl-PL.pdf">Wyświetlanie informacji o przewodowych i bezprzewodowych kartach sieciowych</a>
      </p>
      <h2 id="ch4summary">Podsumowanie</h2>
      <p>
        W tym rodziale rozpoczeliśmy analizowac model sieciowy ISO/OSI.
        Zapoznalismy się z funkcjami warstwy fizycznej. Scharakteryzowaliśmy
        każde medium jakie możemy spotkać w sieci.
      </p>
      <h1 id="1.5.numbersystems">1.5. Systemy liczbowe</h1>
      <p>
        Z systemami liczbowymi, spotykamy się na co dzień licząc lub
        wykorzystując jego cyfry. Ludzie naturalnie wykorzystują bowiem system
        dzięsiętny, które podstawą jest liczba 10 oraz znaki od 0-9. W
        przypadku komputerów, wykorzystywane jest ich znacznie więcej a takimi
        podstawowymi są: system binarny oraz system heksadecymalny oba te
        systemy znajdują swoje zastosowanie w sieci.
      </p>
      <h2 id="1.5.1.binarynumbersystem">1.5.1. Binarny system liczbowy</h2>
      <p>
        Binarny system liczbowy składa się z 1 oraz 0 nazywanych bitami.
        Adresy protokołu IP zapisem poniękąd binarnym, adres składa się z
        ciągu 32-bitów podzielonych na cztery sekcje zwane oktetami. Każdy
        oktet składa się 8 bitów lub jednego 1 bajtu. Jednak ludzie w celu
        uproszczenia sobie nieco pracy wykorzysują zapis dziesiętny,
        konwertując poszczególne oktety. Dlatego też oktety adresów IP 
        posiadają zakres wartości od 0 do 255.  
      </p>
      <p>
        Binarny system liczbowy podobnie do systemu dziesiętnego jest systemem
        pozycyjnym. Pozycyjność polega na tym, że cyfry reprezentują wartości
        na podstawie pozycji, na której się znajdują w sekwencji cyfr (liczbie).
        Spójrzmy na poniższy przykład, prostą liczbą dzięsiętną, którą możemy
        rozpatrzyć pod kątem pozyjności może być: 1234.
      </p>
<pre class="code-block">
1 x 10^3 (1000) = 1000
  +
2 x 10^2 (100)  = 200
  +
3 x 10^1 (10)   = 30
  +
4 x 10^0 (1)    = 4
</pre>
      <p>
        Podobnie jest z cyframi binarnymi, tak jak tutaj brano po uwagę potęgę
        wykładnika jakim jest liczba 2. Rozważmy sobie przykład liczby:
        10110010.
      </p>
<pre class="code-block">
1 x 2^7 (128) = 128
  +
0 x 2^6 (64)  = 0
  +
1 x 2^5 (32)  = 32
  +
1 x 2^4 (16)  = 16
  +
0 x 2^3 (8)   = 0
  +
0 x 2^2 (4)   = 0
  +
1 x 2^1 (2)   = 2
  +
0 x 2^0 (1)   = 0
              = 178
</pre>
      <p>
        Analizując pozycyjność cyfr binarnych, przypadkiem dowiedzieliśmy się
        w jaki sposób możemy dokonąć konwersji wstecznej z cyfr binarnych na
        postać dziesiętną.
      </p>
      <p>
        Konwersji liczb dziesiętnych możemy dokonać w na dwa sposóby. Jednym
        z nich może być metoda pisemna. Polega ona na dzieleniu liczby przez
        dwa do momentu uzyskania 0, przyczym wiemy, że nie wszystkie liczby
        dzielą się na dwie równe częsci. Ta pozostałosc to reszta z dzielenia
        i przeważnie w wyniku dzielnia przez dwa jej wartość nie będzie
        wynosić więcej niż 1. Dlatego też reszta z dzielenia albo będzie
        występować (wówczas, będzie wynosić 1) albo jej nie będzie ponieważ
        cyfra podzieli się równo. Czy ten schemat nam coś przypomina. Tak,
        reszta z dzielenia to nasza wartość binarna. Ale tutaj jest pewien
        haczyk.
      </p>
<pre class="code-block">
178 / 2 = 89 | 0
89  / 2 = 44 | 1
44  / 2 = 22 | 0  /\
22  / 2 = 11 | 0  ||
11  / 2 = 5  | 1  ||
5   / 2 = 2  | 1  ||
2   / 2 = 1  | 0   
1   / 2 = 0  | 1
</pre>
      <p>
        Otóż wartości reszty z dzielnia są odczytywane z dołu do góry.
        178<sub>DEC</sub> = 10110010<sub>BIN</sub>.
      </p>
      <p>
        Inny sposóbem jest próba oszacowania. Bierzemy na 178 i szukamy
        nawiększej potęgi dwójki mniejszej od naszej liczby w tym przypadku
        jest 128.
        Następnie sprawdzamy czy nasza liczba 
        jest większa bądź równa 128. No tak. Zatem zapisujemy skranie po
        lewej
        stronie 1 i odejmujemy od naszej liczby bazowej 128 (178-128) pozostaje
        nam 50 itd. tak jak na przykładzie.
      </p>
<pre class="code-block">
178 &gt;= 128 = 1
178 - 128 = 50
50 &gt;= 64 = 0
50 &gt;= 32 = 1
50 - 32 = 18
18 &gt;= 16 = 1
18 - 16 = 2
2 &gt;= 8 = 0
2 &gt;= 4 = 0
2 &gt;= 2 = 1
2 - 2 = 0
0 &gt;= 1 = 0

10110010
</pre>
      <p>
        Postać binarna zamienianej liczby powstaje z wyników warunków
        logicznych jeśli przyjmiemy, że <em>Tak</em> to 1 a <em>Nie</em> to 0.
        Ta metoda pozwala na przeliczanie liczb w pamięci. Metodę odwrotnej
        konwersji już poznalismy przy poznawania pozycyjności.
      </p>
      <h2 id="1.5.2.hexadecimalnumbersystem">1.5.2. System szesnastkowy</h2>
      <p>
        System heksadecymalny w przypadku sieci może przydzać się do
        zrozumienia IPv6. System ten wykorzysuje jako bazę 16 cyfr 0-9 oraz
        od A-F. Jedna cyfrę heksadecymalną możemy wyrazić za pomocą 4 binarnych
        bitów. System ten jest wykorzystywany tak jak wcześniej wspomniano do
        IPv6 oraz adresów fizycznych.
      </p>
      <p>
        Chcąc skonwertować liczbę dziesiętna na heksadecymalną, możemy posłużyć
        się metodą pisemną tylko zamiast 2 użyć liczby 16. Raczej nie bedzie
        takie potrzeby aby to robić. Innym rodzajem konwersji możebyć
        przeliczenie z systemu binarnego na szesnastkowy. Tutaj nie trzeba
        nic przeliczać, wystarczy odwołać się do tabelki o poniżej.
      </p>
<pre class="code-block">
0000 = 0
0001 = 1
0010 = 2
0011 = 3
0100 = 4
0101 = 5
0110 = 6
0111 = 7
1000 = 8
1001 = 9
1010 = A
1011 = B
1100 = C
1101 = D
1110 = E
1111 = F
</pre>
      <p>
        Jeśli mamy przeliczyć cyfrę dziesiętna to możemy zrobić to bezpośrednio
        przez metodę pisemną lub pośrednio, zamienić ją na system binarny bo
        taki jest prosty do przeliczenia a następnie zgodnie z tablą powyżej
        zamienić 8 bitów binarnych na dwie cyfry heksadecymalne dające
        żądana liczbę. Pamiętamy że nasze 178 to 10110010 to chcąc zamienić tę
        liczbę na system szesnastkowy możey zrobić to tak:
      </p>
<pre class="code-block">
178 = 1011 0010
       B     2
178 = B2

B = 1011
2 = 0010
B2 = 10110010 = 178
</pre>
      <h2 id="ch5summary">Podsumowanie</h2>
      <p>
        W tym jakże, krótkim rozdziale poznaliśmy dwa podstawowe system
        liczbowe wykorzystywane także w sieciach. Nauczyliśmy się konwersji
        z systemu 10 na binarny oraz z systemu binarnego na szesnastkowym i
        odwrotnie. Konwersja systemów a w szczególności z dziesiętnego na
        binarny będzie nam potrzebna do podziału sieci na podsieci oraz
        metody VLSM.
      </p>
      <h1 id="1.6.datalinklayer">1.6. Warstwa łącza danych</h1>
      <p>
        Warstwa łącza danych jest pierwszą warstwą, w której możemy spotkać się
        jaką komunikacją logiczną. Sztandarowym protokołe tej warstwy jest
        Ethernet a podstawową jednostką przesyłanych danych jest ramka.
      </p>
      <h2 id="1.6.1.purposeofdatalinklayer">1.6.1. Przeznaczenie warstwy łącza danych</h2>
      <p>
        Warstwa łącza danych jest odpowiedzialna za komunikację pomiędzy
        kartami sieciowymi, pozwala warstwą wyższym na dostęp do medium
        fizycznego oraz enkapsuluje pakiety warstwy 3 w ramki warstwy drugiej
        oraz dokonuje detekcji błędów i odrzuca uszkodzone ramki.
      </p>
      <p>
        Standardy IEEE 802 LAN/MAN określają typ sieci (Ethernet, WLAN, WPAN
        itd.). Warstwa łącza danych składa się z dwóch podwarstw:
        <strong>Logical Link Control</strong> (LLC) oraz
        <strong>Media Access Control</strong> (MAC). Podwarstwa LLC zapewnia
        komunikację pomiędzy oprogramowaniem sieciowym z warstw wyższych a
        sprzętem z warstwy niższej, natomiast podwastwa MAC odpowiedzialna jest
        za enkapsulację danych oraz dostęp do łącza fizycznego.
      </p>
      <p>
        Pakiety wymieniane między hostami, mogą doświadaczać wielu zmian
        na poziomie warstw niższych, dla porównania jeśli router odbierze
        ramkę to musi ją za akceptować na swojej karcie sieciowej, następnie
        zdekapsulować aby uzyskać potrzebne mu dane. Po wykonaniu czynności
        pakiet jest enkapsulowany ponownie w nową ramkę i przekazany za pomocą
        medium transmisjnego do następnej sieci. 
      </p>
      <p>
        Protokoły warstw łacza danych zostały zdefiniowane przez takie
        organizacje inżynieryjne jak: <em>Institute of Electrical and Electronic
        Engineers</em> (<strong>IEEE</strong>),
        <em>International Telecomunications Union</em> (<strong>ITU</strong>),
        <em>International Organizations for Standarization</em> 
        (<strong>ISO</strong>)
        <em>American National Standards Institute</em> (<strong>ANSI</strong>).
      </p>
      <h2 id="1.6.2.topologies">1.6.2. Topologie</h2>
      <p>
        Toplogia sieciowa jest układ między urządzenia sieci oraz połączeniami
        występującymi między nimi. Rozróżniamy dwa rodzaje topologi:
      </p>
      <ul>
        <li><strong>Fizyczna</strong> - przedstawiająca fizyczne połaczenia
          miedzy urządzeniami, np. użyte medium transmisji czy rodzaj 
          podłączenia między nimi.</li>
        <li><strong>Logiczna</strong> - przedstawiająca połaczenia wirtualne,
          interfejsy czy adresację IP.</li>
      </ul>
      <p>
        W sieciach rozległych możemy wyróżnić kilka topologi fizycznych takich
        jak:
      </p>
      <ul>
        <li><strong>Point-to-point</strong> - najprostsza i naczęsciej
          spotykana topologia WAN. Składa się ona ze stałego połączenia
          pomiędzy dwoma punktami końcowymi.</li>
        <li><strong>Hub and spoke</strong> - podobna do topologii gwiazdy
          gdzie centralne urządzenie pośrednicy pomiędzy połączeniami
          <em>point-to-point</em>.</li>
        <li><strong>Mesh</strong> - topologia dostarcza wysoki stopień
          dostępności usług, ale wymaga aby system były ze sobą połączone
          na zasadzie każdy z każdym.</li>
      </ul>
      <p>
        Urządzenia końcowe takie jak komputery czy laptopy są podłączone
        do sieci lokalnych najczęsciej wykorzystujących topologię gwiazdy oraz
        topologię gwiazdy rozszerzonej (topologię hybrydową). Topologie tego
        typu są łatwe w
        instalacji oraz w rozwiązywaniu problemów, przy tym bardzo
        skalowalne. Na początkach instnienia sieci, były jeszcze dwie
        topologie: magistrali oraz pieścienia, ale nie odnalazływ sie one
        we współczesnych warunkach.
      </p>
      <p>
        W sieciach komputerówych komunikacja jednoczesna komunikacja z drugą
        stroną może odbywać się albo na zasadzie <strong>half-duplex</strong>,
        gdzie w jednym czasie może nadawać lub odbierać tylko jeden host. Tego
        typu komunikacja zachodzi np. w sieciach bezprzewodowych, albo 
        na zasadzie <strong>full-duplex</strong>, gdzie hosty mogą nadawać
        i odbierać informacje jednocześnie w tym samym czasie, tego typu
        transmisja zachodzi w sieciach Ethernet opartych na przełączniku.
      </p>
      <p>
        Jeśli działamy w trybie <em>half-duplex</em>-u, to musimy określić
        metodę dostępu do łącza. W technologiach Ethernet istnieją dwa
        algorytmy, które badają dostęp do łącza są nimi
        <strong>CSMA/CD</strong> wykorzystywany w starym Ethernecie opartym
        na topologi magistrali, gdzie komputery łączył jeden wspólny kabel.
        Kolejnym mechanizmem stosowanym w sieciach bezprzewodowych jest
        modyfikacja wyżej wymienionego <strong>CSMA/CA</strong>.
      </p>
      <p>
        Kiedy w starym algorytmie CSMA/CD, wykrywało się kolizje
        (moment, gdy dwie stacje nadają jednocześnie), to w przypadku sieci
        bezprzewodowych wprowadzono ich unikanie. Funkcja unikania kolizji,
        polega na tym, że jeśli stacja nadaje to nadaje jednocześnie informacje
        o tym ile czasu porzebuje na transmisje. Pozostałe hosty dostają te
        informacje i wstrzymują się z nadawaniem do upłynięcia zadeklarowanego
        czasu.
      </p>
      <h2 id="1.6.3.datalinkframe">1.6.3. Ramka łącza danych</h2>
      <p>
        Dane enkapsulowane przez warstwę łącza danych wraz z nagłówkiem oraz
        <em>stopką</em> tworzą <strong>ramkę</strong>. Ramka składa się
        z nagłówka, danych oraz <em>stopki</em>, w zależności od użytego
        protokołu tej warstwy pola nagłówka oraz zawartość <em>stopki</em>
        może się różnić, podobnie może być ilością danych kontrolnych.
        Pola przeciętnej ramki prezentują się następująco:
      </p>
      <ul>
        <li><strong>Początek oraz koniec ramki</strong> - pola kontrolne
          mające za zadanie wskazać początek oraz koniec ramki.</li>
        <li><strong>Adresacja</strong> - pola zawierające adres źródłowy i
          docelowy.</li>
        <li><strong>Typ</strong> - pole zawierające wskazanie protokołu
          warstwy wyższej.</li>
        <li><strong>Kontrola</strong> - pole zawierające informacje, służace
          mechanizmom kontroli przepływu ruchu.</li>
        <li><strong>Dane</strong> - pole zawierające ładunek, najcześciej
          PDU warstwy wyższej.</li>
        <li><strong>Detekcja błędów</strong> - pole wykorzystywane w detekcji
          błędów.</li>
      </ul>
      <p>
        W większość wyżej wymieniony pól znajduje się w nagłówku, ale
        detekcja błędów oraz koniec ramki znajdują się w <em>stopce</em>.
      </p>
      <p>
        Adresy warstwy drugiej, nazwywane również fizycznymi, znajdują się
        wewnątrz nagłówka ramki i są wykorzystywane tylko i wyłącznie do
        dostarczenia jej lokalnie (w obrębie sieci lokalnej). Jeśli wymagane
        jest przezkazanie ramki dalej do inne sieci, to te adresy muszą
        zostać zmienione.
      </p>
      <p>
        Topologie logiczne oraz fizyczne media często mają wpływ na wybór
        określonego protokołu warstwy wyższej. A jest z czego wybierać:
      </p>
      <ul>
        <li>Ethernet</li>
        <li>802.11 WLAN</li>
        <li>Point-to-point (PPP)</li>
        <li>High-Level Data Link Control (HDLC)</li>
        <li>Frame-Relay</li>
      </ul>
      <p>
        Każdy z tych protokołów posiada swoje mechnizmy kontroli dostepu
        do medium, dla określonych topologi logicznych.
      </p>
      <h3 id="ch6summary">Podsumowanie</h3>
      <p>
        W tym rozdziale poznaliśmy podstawowe zagadnienia związane z drugą
        warstwą - warstwą łącza danych. Ten rozdział również rozpoczyna jej
        bardziej szczegółowe omawianie oraz wstęp do technologi Ethernet i
        przełączników.
      </p>
      <h1 id="1.7.ethernetswitching">1.7. Przełączanie Ethernetu</h1>
      <p>
        W tym rozdziale zapoznamy się ze szczegółami technologii Ethernet,
        potrzebnymi do zrozumienia działania takiego urządzenia jak
        przełączniki. Poznamy również meteody przełączania jakie możemy
        spotkać w dostępnych na rynku przełącznikach.
      </p>
      <h2 id="1.7.1.ethernetframe">1.7.1. Ramka Ethernet</h2>
      <p>
        Ethernet operuje w warstwie fizycznej oraz łącza danych, opisują go
        dwa standardy IEEE 802.2 oraz 802.3.
      </p>
      <p>
        Standardy rodziny 802 wykorzystywane w sieciach LAN/MAN w tym i
        Ethernet wykorzystują dwie podwarstwy warstwy łącza danych.
        <strong>LLC</strong>, której zadaniem jest umieszczenie w ramce
        Ethernet informacji o wykorzystywanym protokole warstwy sieciowej dla
        tej ramki. Drugą podwarstwą jest <strong>MAC</strong> odpowiedzialna
        za enkapsulacje danych, kontrolę dostępu do łącza oraz adresacje w
        warstwie łącza danych.
      </p>
      <p>
        Podwarstwa MAC jest odpowiedzialna za enkapsulację danych oraz dostęp
        do łącza danych. Jesli chodzi o samą enkapsulację to podwarstwa MAC
        zajmuje się <strong>ramką Ethernet</strong> - jej wewnętrzną strukturą;
        <strong>adresacją Ethernetu</strong> - ramki muszą zawierać adresy MAC
        źródła oraz hosta docelowego, aby dostarczyć je z jedenj karty
        sieciowej do drugiej; <strong>detekcją błędów Ethernetu</strong>
        ramki zawierają w <em>stopce</em> pole FCS
        <em>Frame Check Sequence</em> wykorzystywane do detekcji błedów.
      </p>
      <p>
        W ramach kontroli dostępu do łącza Ethernet, podwarstwa MAC zawiera
        specyfikację dla różnych standardów komunikacyjnych Ethernetu przez
        różnego rodzaju łącza takie jakie okablowanie miedziane lub 
        światłowody. Stary Ethernet wykorzystywał topologę magistrali lub
        koncentrator, które są współdzielonym medium działającym w trybie
        <em>half-duplex</em>. Ethernet przez tego typu łącza wymagał
        mechanizmów badania dostępności łącza oraz detekcji błędów. Temu
        służył algorytm CSMA/CD (ang. <em>Carrier Sense Multiple
        Access/Colision Detection</em>). Obecnie Ethernet wykorzystuje
        przełączniki przez co komunikacja może odbywać się w trybie
        <em>full-duplex</em> i nie ma potrzebny stosowania mechanizmu CSMA/CD
        ponieważ ta magistrala przy starym Ethernecie jest teraz jednym
        kablem łączącym kartę sieciową z portem przełącznika.
      </p>
      <p>
        Jeśli chodzi o pola ramki Ethernet to najpierw warto sobie powiedzieć,
        że minimalną wielkością ramki mogą być 64B a maksymalną 1518B.
        Preambuła nie jest wliczana do ramki jeśli chodzi o jej wielkość.
        Wszelkie ramki mniejsze niż 64B są uważane za ramki uszkodzone i
        automatycznie odrzucane. Ramki przekraczające górną granice wielkości
        uważane są za ramki typu <em>jumbo</em>. Ramki przekraczające rozmiary
        lub mniejsze niż minimalny rozmiar, są zazwyczaj uznawane za rezulat
        kolizji lub niechciany sygnał. Przez odbiorców mogą być uznane za
        nieprawidłowe. Większe ramki są akceptowane do technologi FastEthernet
        w góre. 
      </p>
      <h3 id="1.7.1.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/7.1.6-lab---use-wireshark-to-examine-ethernet-frames_pl-PL.pdf">Używanie programu Wireshark do badania ramek Ethernet</a>
      </p>
      <h2 id="1.7.2.ethernetmacadress">1.7.2. Adres MAC Ethernetu</h2>
      <p>
        Adres MAC składa się z 48 bitów zapisanych za pomocą 12 cyfr systemu
        heksadecymalnego, 6 par po 2 cyfry. Dwie cyfry heksadecymalne to 1
        bajt. Poprzedzającje zera są również zapisywane, aby każda z grup
        miała te 8 bitów. Cyfry heksadecymalne mogą być czasem zapisywane 
        z przedrostkiem <strong>0x</strong> lub z przyrostkiem
        <strong>H/h</strong>. 
      </p>
      <p>
        Ethernet był projektowany z myślą o tym, że urządzenia sieciowe 
        są podłączone do współdzielonego medium (magistrali) i adresacja MAC
        pozwala na identyfikacje takiego hosta. Ze tego powodu wszyskie
        adresu MAC muszą być unikatowa w obrębie całej sieci. W tym celu
        każdy z dostawców sprzętu działającego w sieci Ethernet muszą
        zarejestować się w IEEE aby uzyskać 6 cyfrowy (heksadecymalnych) kod
        nazwany <strong>unikalnym indentyfikatorem organizacji</strong>
        (<strong>OUI</strong>). Każdy adres MAC składa się z kodu OUI
        przypisanego do producenta sprzętu oraz pozostałych 6 cyfr
        przypisanych przez producenta do konkretnej sztuki produktu.
      </p>
      <p>
        Przetwarzanie ramek ma swój początek już na komputerze źródłowym.
        Każda ramka zawiera adres źródłowy oraz adres docelowy. Kiedy
        karta sieciowa odbierze taką ramkę porówna jej adres docelowy MAC z
        z adresem swojej kartym, jeśli adres jest taki samy oznacza to, że
        ramka jest przeznaczona dla tego hosta. Ramka dekapsulowana i
        przekazana do warstw wyższych. Obecnie większość urządzeń wykorzystuje
        Ethernet, więc tego typu przetwarzanie danych jest podstawą
        wszlakiej komunikacji w sieci. Warto wspomnieć o tym, że karty sieciowe
        akceptują rownież ramki typu broadkast oraz multikast tych grup, do 
        których ten host należy.
      </p>
      <p>
        W Ethernecie różne adresy MAC są wykorzystywane do transmisji unikast,
        broadkast oraz multikast w warstwie drugiej. Adres MAC unikastowy
        jest wykorzystywany do transmisji między pojedynczymi hostami w sieci.
        Adresy MAC są powiązane z adresami warstwy sieciowej, są one uzyskiwane
        za pomocą protokołów ARP (dla IPv4) lub ND (IPv6). Przy tych wszystkich
        rodzajach adresów, a co za tym idzie rodzajach transmisji adresem
        źródłowym zawsze adres unikastowy.
      </p>
      <p>
        Ramkę ethernetową transmisji broadkast odbierze każdy host
        znajdujący się w tej samej sieci Ethernet LAN. Broadkastowy adres MAC
        składa się wyłącznie z samych cyfr <strong>F</strong>. Przez
        przełączniki jest on przekazywany na wszystkie porty poza tym z którego
        ta ramka została przysłana. Oczywiście transmisja broadkast w
        Ethernecie zawiera w sobie pakiet IP z tym samym rodzajem transmisji,
        oznacza to, że dane zawarte w tej transmisji zostaną przetworzone
        przez wszystkie host w tej sieci lokalnej (domenie rozgłoszeniowej),
        które ten pakiet otrzymają.
      </p>
      <p>
        Przypadek transmisji multikast w Ethernet jest trochę bardziej
        skomplikowany. Taką ramkę odbiorą hosty, które należą do tej samej
        grupy. Transmisja multikast w Ethernet jest powiązana z rodzajem tego
        typu transmisji w protokole IP, dla wersji 4 mamy adres (początek):
        <strong>01-00-5E</strong>, a dla wersji 6 <strong>33-33</strong>.
        Innym rodzajem multikastu w Ethernecie jest protokół STP, nie jest
        on protokołem warstwy 3, a drugiej i zawiera swój adres docelowy
        typu multikast. Transmisje multikast opuszczają przełącznik w ten sam
        sposób co transmisja broadkast, chyba że urządzenie skonfigurowano
        inaczej (mechanizm <em>multicast snooping</em>), transmisja ta nie
        jest przekazywana przez router, chyba że został poinstuowany aby
        trasować pakiety multikast. Ze względu na to, że adresy multikast
        reprezentują grupe hostów, mogą zostac użyte tylko i wyłącznie jako
        adres docelowy, adresem źródłowym musi być adres unikast. Tak jak
        w przypadku transmisji unikast oraz broadkast, transmisja multikast
        wymaga odpowiadających adresom Ethernet, adresów IP.
      </p>
      <h3 id="1.7.2.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/7.2.7-lab---view-network-device-mac-addresses_pl-PL.pdf">Odczytywanie adresów MAC urządzeń sieciowych</a>
      </p>
      <h2 id="1.7.3.macaddresstable">1.7.3. Tablica adresów MAC</h2>
      <p>
        Ethernetowy przełącznik warstwy drugiej dokonuje swoich decyzji o
        przełączaniu na podstawie adresu MAC, który jest zapisany w tablicy
        adresów MAC przełącznika, na podstawie informacji tam zapisanych
        przełącznik wie na jaki port należy przesłać dane, adresowane do
        komputera o takim adresie MAC. W momecie włączenia urządzenia jego
        tablica nie zawiera żadnych wpisów i musi się ich nauczyć. Tablica
        MAC często nazwyana jest CAM (ang. <em>content addressable memory
        table</em>).
      </p>
      <p>
        Nauka adresów MAC przez przełącznik, czy też uzupełnienie tablicy
        polega na badaniu każdej przychodzącej do urządzenia, ramki w celu
        uzyskania nowych informacji. Badany jest przede wszystkim adres
        źródłowy oraz port, na którym te dane dotarły do przełącznika, 
        następnie
        te informacje są konfrontowane z tabelą jeśli taki adres MAC pod takim
        portem nie występuje wówczas te dane są dopisywane lub poprawiane w
        zależności od tego czy w przeciągu czasu ważności wpisów w tablicy MAC
        ruch sieciowych przechodził przez ten port. W przeciwnym wypadku
        wpis jest odświerzany co powowduje, że jego czas jego ważności
        został zresetowany. W przypadku większości przełączników czas wazności
        wpisów w tablicy to 5 minut. W przypadku przepięcia hosta do innego
        portu, w tablicy we wpisie z adresem zostanie zamieniony port, pod
        którym ten MAC może występować.
      </p>
      <p>
        W przypadku przekazywania ramek, działa to w sposób analogiczny, tylko
        przełącznik zamiast zapisywać odczytuje informacje z tablicy MAC. Jeśli
        adres docelowy jest unikastowy, to jest on sprawdzany w tablicy, w celu
        ustalenia portu docelowego przełącznika dla docelowego hosta. Jeśli
        wpis zostanie odnaleziony, to ramka zostaje przezkazna na ten port.
        W przeciwnym wypadku zostanie on przekazany na wszystkie porty poza tym
        źródłowym (z którego trafił do przełącznika). Podobnie przełącznik
        zachowuje się w przypadku transmisji broadkast oraz multikast.
      </p>
      <h3 id="1.7.3.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/7.3.7-lab---view-the-switch-mac-address-table_pl-PL.pdf">Przeglądanie tablicy adresów MAC przełącznika</a>
      </p>
      <h2 id="1.7.4.switchspeedsandforwardingmethods">1.7.4. Przepustowość przełącznika oraz metody przekazywania.</h2>
      <p>
        Przełączniki używają jednej z poniższych metod przełączania danych
        danych między portami.
      </p>
      <ul>
        <li><strong>Przełączanie <em>store-and-forward</em></strong> - w tej
          metodzie przełącznik musi otrzymać całą ramkę, następnie oblicza
          jej CRC. Jeśli CRC jest prawidłowe, wówczas dochodzi do przełączania
          znanego z poprzednie podrozdziału.</li>
        <li><strong>Przełączanie <em>cut-through</em></strong> - tutaj
          przełącznik nie czeka całą ramkę, wystarczy mu odczytać adres
          docelowy, aby dokonać przełączenia.</li>
      </ul>
      <p>
        Zaletą metody <em>store-and-forward</em> jest możliwosc wykrycia błędów
        zanim ramką zostanie przekazana dalej. Jeśli błąd zostanie wykryty
        przełącznik odrzuci ramkę. Odrzucanie uszkodzonych ramek pozwala
        zredukować żużycie przepustowści na przesyłanie uszkodzonych ramek.
        Metoda <em>store-and-forward</em> jest również wymaga przez 
        metody priorytetyzacji ruchu takie jak QoS.
      </p>
      <p>
        Metoda przełączania <em>cut-through</em> przełącza dane zanim w całości
        dotrą do przełącznika, jego bufor jest na tyle duży, że może odczytać
        docelowy adres MAC i na podstawie tego dokonuja przełącznia. Ta
        metoda występuje w dwóch wariantach:
      </p> 
      <ul>
        <li><strong>Przełączanie <em>fast-forward</em></strong> - ta metoda
          przełączania oferuje najmniejsze opóźnienia. Jeśli zostaną
          przekazane uszkodzone ramki, to zostaną one odrzucone przez
          docelową kartę. Jest to domyślny wariant dla metody
          <em>cut-through</em>.</li>
        <li><strong>Przełączanie <em>fragment-free</em></strong> - jest
          kompromis między <em>cut-through</em> oraz <em>store-and-forward</em>.
          Przełacznik pobiera i sprawdza pierwsze 64 bajty ramki przed
          przełączeniem. W większości sieci błedy są do wykrycia już tych
          pierwszych 64 bajtach ramki, przez co przełącznik może mieć pewność,
          że te ramki są całe i można je przekazać dalej.</li>
      </ul>
      <p>
        Wspominając o sposobach przełączania, warto również omówić pamięć
        bufora w przełączniku. Bufor jest wykorzystywany gdy port docelowy
        może być zbyt zajęty, żeby przyjmować kolejne ramki, do dyspozycji mamy:
      </p>
      <ul>
        <li><strong>Pamięc portów</strong> - Ramki są przechowywane w kolejkach
          powiązanych z portami wejściowymi oraz wyjściowymi. Ramka jest
          przekazywana na port wyjściowy tylko wtedy gdy ramki przed nią
          zostały poprawnie przesłane. Mozliwe jest opóźnienie transmisji
          wszystkich ramek w pamięci przez pojedyńczą ramkę, ze względu na
          obciążenie portu docelowego. Opóźnienia występują nawet wtedy gdy
          inne ramki mogą zostać przesłane na otwarte porty docelowe.</li>
        <li><strong>Pamięć współdzielona</strong> - przechowuje wszystkie
          ramki we ogólnym buforze pamieci współdzielonym ze wszystkimi portami
          przełącznika, ilość pamięci potrzebna dla konkretnego portu jest
          przydzielana dynamicznie. Ramki w buforze dynamicznie powiązane z 
          portami docelowymi. Pakiet może nadejść z jednego portu i być
          przekazywany do innego to niezostanie on przeniesiony do innej
          kolejki.</li>
      </ul>
      <p>
        Buforowanie w pamięci współdzielonej pozwala na transmisję większych
        ramek z mniejszymi stratami. Jest ważne dla przełączania asymetrycznego,
        które pozwala na różne prędkości danych na różnych portach.
        Dzięki czemu większa przepustowość może zostać przypisana do
        niektórych portów, np. porty serwerów.
      </p>
      <p>
        Dwoma najbardziej podstawowymi ustawieniami przełącznika są
        przepustowość (przełączniki mogą działać w standardach wstecznych
        Eternetu) oraz <em>duplex</em> (możliwość nadawania i odbierania
        danych w tym samym momencie). Do dyspozycji mam
        <strong>full-duplex</strong> - oba urządzenia końcowe mogą nadwać
        i odbierać dane jednocześnie lub <strong>half-duplex</strong> - tylko
        jedna ze stron może nadawać w tym czasie.
      </p>
      <p>
        Prawdopodobnie nie będzie trzeba konfigurować tych ustawień. Tym
        zajmuje się mechnizm autonegocjacji, urządzenia miedzy sobą ustalają
        najlepsze ustawienia dla warunków fizycznych. Gigabitowy Ethernet
        do działania wymaga <em>full-duplex</em>-u.
      </p>
      <p>
        Nie pasujący <em>duplex</em> jest przyczną większości problemów z
        z wydajnościa w sieciach Ethernetowyc 10/100Mbps. Przyczyna tych
        problemów może być ustawienie portu przełącznika w <em>half-duplex</em>
        natomiast druga strona ma ustawiony <em>full-duplex</em>, dzieje się
        tak gdy połączenie między tymi stronami zostanie zresetowane a 
        autonegocjacja nie będzie wstanie ustalić takie samej konfiguracji
        dla obu stron lub gdy zmienimy konfigurację na jednym urządzeniu i
        zapomnimy to zrobić na drugim urządzeniu. Najlepszą praktyką to albo
        włączyć na obu autonegocjację, albo na obu wyłączyć. Można
        również ustawić na portach przełącznika na stałe <em>full-duplex</em>.
      </p>
      <p>
        Połaczenia między urządzeniami mogą wymagać różnego rodzaju połączeń.
        mowa tutaj o kablach prostych oraz o kablach skrosowanych. Zazwyczaj
        połączenia między routerami wymagają kabli skrosowanych jak połączenia
        bezpośrednie między dwiema stacjami. Obecnie mało kto pamiętam o tym
        ponieważ mamy do dyspozycji funkcję <strong>Auto-MDIX</strong>, która
        mimo połączenia urządzeń za pomocą prostych przewodów, dokona
        skrosowania już wewnatrz interfejsu. W sprzętach marki Cisco,
        a szczególnie w przełącznikach ta funkcja jest raczej włączona, ale
        to może być różnie (w zależności jak stare jest to urządzenie). Więc 
        warto
        zawsze używać wymaganych przewodów lub też możemy spróbować włączyć
        tę funkcję za pomocą polecenia: <code class="code-inline">mdix auto</code>
        w trybie konfiguracji interfejsu.
      </p>
      <h2 id="ch7summary">Podsumowanie</h2>
      <p>
        W tym rodziale przybliżliśmy sobie szczegóły technologii Ethernet,
        poznaliśmy adres MAC oraz tablice MAC przełączników. Dowiedzieliśmy
        też jakie są metody przełączania oraz podstawowe ustawienia
        przełącznika.
      </p>
      <h1 id="1.8.networklayer">1.8. Wartstwa sieciowa</h1>
      <p>
        Warstwa sieciowa dostarcza usługi pozwalające na wymianę danych między
        hostami. Podstawowym jej protokołem jest protokół IP zarówno w wersji
        4 jak i 6. Warstwa sieciowa odpowiada adresacje urządzeń końcowych,
        enkapsulację, routing oraz deenkapsulacje.
      </p>
      <h2 id="1.8.1.networklayecharacteristics">1.8.1. Charakterystyki warstwy sieciowej</h2>
      <p>
        Protokół IP enkapsuluje segmenty z wartstwy transportowej, nie ma 
        znaczenia czy użyjemy wersji 4 czy 6 protokołu IP, na ten segment
        nie będzie to miało wpływu. Pakiet IP będzie analizowany przez
        wszystkie urządzenia warstwy 3 (lub mogące w niej działać) na swojej
        drodze do punktu docelowego. Generalnie to adres protokołu IP nie
        powinny się zmienić na drodze między hostem źródłowym a hostem
        docelowym, wyjątkiem od tej reguły jest mechanizm NAT. Protokół IP
        opisywany jest jako bezpołączeniowy, niezależny od medium transmisyjnego
        oraz najlepszej możliwości.
      </p>
      <p>
        Protokół IP jest bezpołączeniowy. IP nie ustanawia żadnego połączenia
        ze stroną docelową przed wysłaniem pakietu, nie potrzeba żadnych
        informacji kontrolnych. Host docelowy otrzyma pakiet kiedy on nadejdzie,
        nie ma żadnych wcześniejsych powiadomień. Jeśli wymagane jest
        połączenie, wówczas jest to powierzane warstwie wyższej, warstwie
        transportowej, a konkretnie protokołowi TCP.
      </p>
      <p>
        Protokół IP jest uznawana za protokół najlepszej możliwości porzez
        zmniejszenie narzutu spowodowanego brakiem mechnizmów retransmisji,
        nie ma potwierdzeń o tym, że pakiet dotarł. IP nawet na nie,
        nie oczekuje. Protokół również nie ma informacji na temat czy
        host w ogóle funkcjonuje i otrzymuje wysłane do niego pakiety.
      </p>
      <p>
        Ze względu na to, że protokół IP jest protokołem najlepszej możliwości
        uznawany jest za nierzetelny. Jednak te funkcje nie sprawdzają się w
        każdym możliwym przypadku, dlatego też brak ich w protokole IP, który
        w obenych czasach musi obsłużyć 99% ruchu w sieci. Protokół IP jest
        protokołem niezależnym od medium transmisjynego oznacza to, że
        może on przesyłać dane przez dowolne połączenie między dwoma hostami.
        Przyczym wprowadza on pojęcie <strong>MTU</strong>
        (<em>Maximum Transmission Unit</em>). Ten protokół utrzymuje
        informacje o tym jakie MTU ma ustawić od warstwy łącza danych. Innym
        mechanizmem protokołu IP jest <strong>fragmentacja</strong>, pozwala
        ona dzielić pakiety na mniejsze części, na przykład gdy nasza 
        technologia WAN ma mniejsze MTU.
      </p>
      <h2 id="1.8.2.ipv4packet">1.8.2. Pakiet IPv4</h2>
      <p>
        Protokół IP wersji 4 jest podstawowym protokołe komunikacyjnym w
        warstwie sieciowej, a sam nagłówek jest dość istotny w całej
        transmisji. Zapewnia, że pakiet zostanie wysłany do właściwego
        odbiorcy, zawiera w swoich polach wiele informacji ważnych dla
        przetwarzania pakietów. Informacje z nagłówka wykorzystują wszystkie
        urządzenia mogące przetwarzać dane z warstwy sieciowej. W nagłówku IP
        mimo wszystko najważniejszą informacją są pola a zawierające adresy,
        dość ciekawy polem tutaj jest pole <em>Protocol</em>, gdyż może mieć
        więcej niż jedną funkcję. Poniżej znajduje się bardziej szczegółowy
        opis poszczególnych pól:
      </p>
      <ul>
        <li><strong>Wersja</strong> - 4-bitowe pole zawierające wersję IP w tym
          przypadku: <em>0100</em> = 4.</li>
        <li><strong>Zróżnicowane usługi</strong> - pole wykorzystywane przez
          QoS, może mieć rózne oznaczenie: DS, DiffServ lub IntServ czy ToS
          <em>Type of Service</em>.</li>
        <li><strong>Suma kontrolna nagłówka</strong> - pole wykorzystywane do
          detekcji uszkodzeń nagłówka.</li>
        <li><strong>Pole TTL</strong> - licznik skoków w warstwie 3. Kiedy
          zostanie wyzerowane router odrzuci pakiet.</li>
        <li><strong>Protokoł</strong> - wskazuje na protokół, którego dane
          są niesione w tym pakiecie, np.: ICMP, TCP czy UDP.</li>
        <li><strong>Adres źródłowy IPv4</strong> - adres IPv4 hosta wysłającego
          pakiet.</li>
        <li><strong>Adres źródłowy IPv6</strong> - adres IPv4 hosta docelowego.</li>
      </ul>
      <h2 id="1.8.3.ipv6packet">1.8.3. Pakiet IPv6</h2>
      <p>
        Protokół IPv4 posiada swoje ograniczenia. Pierwszym z nich jest
        wyczerpanie się adresów IP w swojejwersji, inna przeszkodą może być 
        brak
        bezpośrednich połaczeń, obecnie łączymy się z pośrednictwem adresów
        prywatnych oraz NAT-u, a użycie mechnizmu NAT powoduje potrzebę zmiany
        nagłówków, co może powodować opóźnienia oraz zwiększać złożoność sieci.
      </p>
      <p>
        Remedium na powyższe ograniczenia jest globalne wdrożenie IPv6.
        IPv6 zwiększa długość adresu z 32-bitów do 128 przez co ich ilość
        zwiększa o bardzo duża liczbę (340 x 10^36), gdzie adresów IPv4 mamy
        lekko powyżej 4 miliardy. Zmniejsza się również nagłówek pakietu,
        zostaje pozbawiony kilku pól. Ze względu na ilość operowalnych adresów
        nie ma potrzeby stosowania NAT-u. 
      </p>
      <p>
        Sam nagłówek IPv6 został uproszczony, ale nie zmniejszony. Nagłówek
        IPv6 ma długość 40B, wiele z pól zostało zostało usuniętych aby
        zwiększyć wydajność. Ponizej znajduje się opis poszczególnych pól
        nagłówka IPv6.
      </p>
      <ul>
        <li><strong>Wersja</strong> - wersja protokołu 4 bity dla IPv6 to:
          <em>0110</em>.</li>
        <li><strong>Klasa ruchu</strong> - pole dla QoS.</li>
        <li><strong>Etykieta przepływu</strong> - 20-bitowe pole informujące
          urządzenia, aby przetwarzały pakiety z tą samą wartością tego pola
          w ten sam sposób.</li>
        <li><strong>Długość ładunku</strong> - 16-bitowe pole określa długość
          danych niesionych przez ten pakiet.</li>
        <li><strong>Następny nagłówek</strong> - wskazuje na protokół
          warsty wyższej, której dane niesie.</li>
        <li><strong>Limit skoków</strong> - licznik skoków w warstwie sieciowej</li>
        <li><strong>Adres źródłowy IPv6</strong> - 128-bitowy adres źródłowy.</li>
        <li><strong>Adres docelowy IPv6</strong> - 128-bitowy adres docelowy.</li>
      </ul>
      <p>
        Dodatkowo pakiety IPv6 mogą zawierać rozszerzenie nagłówka, które może
        zawierać dodatkowe informacji warstwy sieciowej takie jak fragmentacja,
        informacje odnośnie bezpieczeństwa czy wsparcie dla mobilności. To
        rozszerzenie jest opcjonalne i umiesczone jest między danymi a
        nagłówkiem. W przeciwieństwie do IPv4 routery IPv6 nie fragmentują
        pakietów.
      </p>
      <h2 id="1.8.4.howhostsroutes">1.8.4. W jaki sposób host przesyła pakiety</h2>
      <p>
        Każdy host posiada w swojej konfiguracji TCP/IP tablicę routingu.
        Pakiety przez niego wygenerowane mogą być wysłane do siebie po przez
        adres pętli zwrotnej: <em>127.0.0.1</em> (IPv4), <em>::1</em> (IPv6);
        do hostów lokalnych znajdujących się w tej samej sieci czy też do
        hostów zdalnych znajdujących się poza naszą siecią lokalną.
      </p>
      <p>
        To host źródłowy decyduje o tym czy adres docelowy jest adresem
        lokalnym czy też pochodzącym z poza sieci. W zależności od wersji
        protokołu są dwie metody. Host konfrontuje swój adres oraz maskę
        obliczając adresy sieciowe (adres sieci i broadcast) z adresem
        docelowym w przypadku IP w wersji 4. W przypadku IP w wersji 6, host
        wykorzystuje adres sieci oraz prefix przedstawiony mu przez najbliższy
        router. Ruch lokalny opuszcza kartę sieciową hosta i jest przetwarzany
        przez urządzenia pośredenie, takie jak przełączniki. Jeśli ruch jest
        ewidentnie adresowany na zewnątrz, jest on kierowany do prosto do bramy
        oczywiści z pośrednictwem urządzeń po drodze do routera.
      </p>
      <p>
        Urządzenia warstwy 3, takie jak routery lub przełączniki L3 mogą być
        domyślną bramą dla hostów w sieci lokalnej. Cechami domyślnej bramy
        są na pewno: adres IP urządzenia/interfejsu musi znajdować się w tej
        samej sieci lokalnej, urządzenia tego typu przyjmują ruch z sieci
        lokalnej i kierują ją po za nią, mogą trasować ruch do innych sieci.
        Jeśli hosty w sieci nie posiadają skonfigurowanej bramy lub jej adres
        adres jest niepoprawny nie będą wstanie przesyłać danych poza sieć.
      </p>
      <p>
        Host adres bramy może mieć zapisany w swojej konfiguracji statycznie
        lub otrzymać go wraz z dzierżawą adres IP z serwera DHCP, w przypadku
        protokołu IPv6 adres bramy może zostać otrzymany z komunikatów
        <em>router advertisement</em> (RA) lub skonfigurowany ręcznie.
      </p>
      <p>
        Za pomocą poleceń <code class="code-inline">netstat -r</code> dla
        (systemy MS Windows) czy <code class="code-inline">ip route</code>
        (dystrybucje Linuksa). Możemy wyświetlić tablicę routingu zapisaną
        na systemie hosta.
      </p>
<pre class="code-inline">
󱩊 xf0r3m@laptop-026253a/ ~/󰯆 ip route
default via 192.168.8.1 dev enp0s31f6 proto dhcp src 192.168.8.133 metric 100 
192.168.8.0/24 dev enp0s31f6 proto kernel scope link src 192.168.8.133 metric 100 
</pre>
      <h2 id="1.8.5.introductiontorouting">1.8.5. Wprowadzenie do routingu</h2>
      <p>
        Załóż czysto hipotetycznie, że chcemy przesłać pakiet do sieci obok,
        co sie stanie? Taki pakiet jeśli osiągnie router, ponieważ nasz host
        wysłał tę ramkę do bramy domyślnej, to router sprawdzi adres docelowy
        i wzależności czy posiada trasę do tego hosta, to wyśle go na pierwszy
        router w tej trasie, lub jeśli sieć docelowa jest wpięta do tego samego
        routera zostanie przekazana na interfejs obsługjący tę sieć. Router
        dokonuje tych decyzji opierając się o zapisaną w swojej pamięci tablicę
        routingu.
      </p>
      <p>
        W routerach możemy spotkać trzy rodzaje tras w ich tablicach.
      </p>
      <ul>
        <li><strong>Podłączone bezpośrednio</strong>
          (ang. <em>Directly Connected</em>) - te trasy są dodwane domyślnie
          bazując na aktywnych interfejsach i powiązanych z nimi adresach.</li>
        <li><strong>Zdalne</strong> (ang. <em>Remote</em>) - trasy
          bez połączenia bezpośrednie (niepodłączone lokalnie), router nauczył
          się ich albo przy użyciu dynamicznych protokółów routingu lub
          zostały mu one zapisane ręcznie przez administratora
          (trasy statyczne)</li>
        <li><strong>Trasa domyślna</strong> - trasa wykorzystywana w momencie,
          gdy nie ma innej pasującej do adresu docelowego.</li>
      </ul>
      <p>
        Cechami tras statycznych są: potrzeba ręcznej konfiguracji, potrzeba
        ręcznego dostosowania do zmienającej się topologii sieci. Trasy
        statyczne mogą być dobrym wyborem dla małych sieci. Za pomocą tras
        statycznych mimo wykorzystywania protokołów dynamicznych ustala się
        bramy domyślne dla routerów.
      </p>
      <p>
        W przypadku routingu dynamicznego, routery same odnajdują sieci,
        aktualizują informacje, wybierają najlepsze ścieżki czy dostosowują się
        do topologii. Dynamiczny routing może być wykorzystywany do
        współdzielnia statycznej trasy bramy domyślnej.
      </p>
      <p>
        W systemach Cisco IOS, szczególnie na routerach możemy zobaczyć dość
        obszerną informacje podobną do tej przedstawionej na poniższym
        przykładzie. Nie będzie ona tak obszerna jak w tym przypadku. Nie
        mniej warto się jednak zapoznać z oznaczeniami poszczególnych tras.
      </p>
<pre class="code-block">
route-views&gt;show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area 
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2
       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2
       ia - IS-IS inter area, * - candidate default, U - per-user static route
       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP
       a - application route
       + - replicated route, % - next hop override, p - overrides from PfR

Gateway of last resort is 128.223.51.1 to network 0.0.0.0

S*    0.0.0.0/0 [1/0] via 128.223.51.1
      1.0.0.0/8 is variably subnetted, 3781 subnets, 17 masks
B        1.0.0.0/24 [20/0] via 12.0.1.63, 12:59:24
B        1.0.4.0/22 [20/0] via 114.31.199.16, 12:59:24
B        1.0.5.0/24 [20/0] via 114.31.199.16, 12:59:24
...
</pre>
      <p>
        Zatem:
      </p>
      <ul>
        <li><strong>L</strong> - podłączony bezpośrednio adres IP interfejsu.</li>
        <li><strong>C</strong> - sieć podłączona bezpośrednio.</li>
        <li><strong>S</strong> - trasa statyczna.</li>
        <li><strong>O</strong> - protokół OSFP.</li>
        <li><strong>D</strong> - protokół EIGRP.</li>
        <li><strong>R</strong> - protokół RIP.</li>
        <li><strong>B</strong> - protokół BGP.</li>
      </ul>
      <p>
        Chcąc przypasować te oznaczenia do wspomniany wcześniej rodzajów wpisów
        w tablicy routingu routera to:
      </p>
      <ul>
        <li>Podłączone bezpośrednio (ang. <em>Directly Connected</em>) -
          <strong>C</strong> i <strong>L</strong>.</li>
        <li>Trasy zdalne (ang. <em>Remote Routes</em>) - 
          <strong>O</strong>, <strong>D</strong>, <strong>R</strong>
          <strong>B</strong>.</li>
        <li>Trasy domyślne (ang. <em>Default routes</em>) - 
          <strong>S*</strong>.</li>
      </ul>
      <h2 id="ch8summary">Podsumowanie</h2>
      <p>
        Tym rozdziałem rozpoczeliśmy omawianie warstwy sieciowej.
        Poznaliśmy jej główny protokół jakim jest protokół IP oraz nagłówki
        pakietów zarówno dla wersji 4 jak i 6. Dowiedzieliśmy się jak
        działa trasowanie oraz jakie są jego rodzaje oraz charakterystyki
        metody statycznej oraz dynamicznej. 
      </p>
      <h1 id="1.9.adresresolution">1.9. Rozwiązywanie adresów</h1>
      <p>
        Chcąc wysłać jakieś informacje przez sieć, nasz komputer musi w jakiś
        sposób zaadresować jakoś te pakiety z danymi. Pierwszą warstwą jaka
        będzie wymgać adresu jest warstwa sieciowa, tam potrzeba adresu IP,
        który może zostać uzyskany za pomocą system DNS. Następna warstwą jak
        wymaga adresu jest wartstwa fizyczna/łącza danych oraz
        rozpowszechniony na większość sieci protokół Ethernet, który wymaga
        adresów MAC (adresów fizycznych), kiedy pakiet IP jest enkapsulowany
        w ramkę Ethernet  wymagana
        jest zamiana adresów IP na adresy MAC i temu służą dwa tematy tego
        rozdziału: <strong>ARP</strong> oraz
        <strong>IPv6 Neighbor Discovery</strong>.
      </p>
      <h3 id="1.9.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.1.3-packet-tracer---identify-mac-and-ip-addresses_pl-PL.pdf">Identyfikacja adresów MAC i IP - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.1.3-packet-tracer---identify-mac-and-ip-addresses_pl-PL.pka">Identyfikacja adresów MAC i IP - zadanie</a>
      </p>
      <h2 id="1.9.1.arp">1.9.1. Protokół ARP</h2>
      <p>
        Protokół ARP jest wykorzystywany do określenia adresu MAC dla adresów
        IP lokalnych urządzeń w sieci. Protokół ten ma dwie zasadnicze
        funkcje zmianę adresów IPv4 na adresy MAC oraz utrzymania mapowań
        adresów w tabeli.
      </p>
      <p>
        Kiedy host musi wysłać ramkę przeszukuje swoją tablicę ARP w
        poszukiwaniu pasującego adres MAC do docelowego adresu IPv4, jeśli
        host docelowy znajduej się w tej samej sieci. Jeśli znajduje się w
        innej wówczas host będzie szukać w tablicy ARP adresu bramy.
        Pasujący adres zostanie użyty jako adres docelowy w ramce Ethernet.
        Jeśli nie uda się odnaleźć adresu MAC, to wówczas host wyśle zapytanie
        ARP.
      </p>
      <p>
        Wpisy w tabeli ARP znajdują się tam tylko przez określony czas, po jego
        upłynięciu wpis zostaje wymazany. Ilość tego czasu zależy od systemu
        operacyjnego, mimo to administrator ma możliwość ręcznego usunięcia
        wpisu z tablicy ARP.
      </p>
      <p>
        Na urządzeniach z systemami IOS tablice ARP możemy sprawdzić za pomocą
        polecenia: <code class="code-inline">show ip arp</code>. Na natomiast
        w urządzeniach z system MS Windows tablice ARP możemy wyświetlić
        za pomocą polecenia <code class="code-inline">arp -a</code>.
      </p>
      <p>
        Pakiety ARP są przesyłane przez hosty nie mal przez wszystkie hosty w
        sieci, a wiele transmisji ARP na raz może powodować spadki wydajności
        całej sieci. Warto też wspomnieć, że odpowiedzi ARP mogą być fałszowane
        przez atakującego przeprowadzającego atak zatruwanie tablicy ARP,
        jednak przełączniki klasy Enterprise zawierają funkcję ochronne przed
        tego typu atakami.
      </p>
      <h3 id="1.9.1.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.2.9-packet-tracer---examine-the-arp-table_pl-PL.pdf">Badanie tablicy ARP - scenaiusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.2.9-packet-tracer---examine-the-arp-table_pl-PL.pka">Badanie tablicy ARP - zadanie</a>
      </p>
      <h2 id="1.9.2.ipv6neighbordiscovery">1.9.2. Protokół IPv6 Neighbor Discovery</h2>
      <p>
        Protokół IPv6 <em>Neighbor Discovery</em> dostarcza nam takich funkcji
        jak rozwiązywanie adresów, znajdowanie routerów oraz
        usługi przekierowań. Cały ten protokół jest częścią protokołu ICMPv6
        i wykorzystuje jego konkretne rodzaje komunikatów takie jak
        <em>Neighbor Solicitation</em> (NS) i <em>Neigbor Advertisement</em>
        (NA) wykorzystywane do wymiany informacji między urządzeniami, np.
        takich jak rozwiązywanie adresów. Innymi komunikatmi są
        <em>Router Solicitation</em> (RS) oraz <em>Router Advertisement</em>
        (RA) służące do wymiany informacji pomiędzy hosta a routerami te
        komunikaty biorą udział w zapytaniach o adres routera oraz o
        rozgłoszeniu informacji o istniejącym w sieci routerze. Pozostałymi
        komunikatami są informacje o przekierowaniach, są one używane przez
        routery do wyboru lepszego następnęgo skoku.
      </p>
      <p>
        Wykorzystujące IPv6 urządzenia wykorzystują komunikaty ND w celu
        uzyskania adresów MAC dla znanych adresów IPv6. W odpowiedzi uzyskują
        adres MAC żądanego urządzenia, przyczym odpowiedzi wysyłane są
        na specjalny adres Ethernetowy oraz adres multikastowy IPv6.
      </p>
      <h3 id="1.9.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.3.4-packet-tracer---ipv6-neighbor-discovery_pl-PL.pdf">Wykrywanie sąsiadów IPv6 - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/9.3.4-packet-tracer---ipv6-neighbor-discovery_pl-PL.pka">Wykrywanie sąsiadów IPv6 - zadanie</a>
      </p>
      <h2 id="ch9summary">Podsumowanie</h2>
      <p>
        W tym jakże krótkim rodziale poznaliśmy w jaki sposób rozwiązywane są
        adresy IPv4 jak i IPv6 na adresy warstwy niższej - adresy MAC.
      </p>
      <h1 id="1.10.basicrouterconfig">1.10. Podstawowa konfiguracja routera</h1>
      <p>
        Kontynuując poznawanie warstwy sieciowej pora poznać kilka poleceń, a
        ze względu, że to warstwa 3 czy to modelu OSI czy TCP/IP, to będzie to
        router - urządzenie, które w tej warswie poniękąd rezyduje.  
      </p>
      <h2 id="1.10.1.configinitroutersettings">1.10.1. Konfiguracja podstawowych ustawień routera</h2>
      <p>
        Prze rozpoczęciem właściwej konfiguracji interfejsów sieciowych czy
        routing warto pochylić się na takimi rzeczami jak określenie jego
        nazwy, wybór ewentualnej metody dostępu zdalnego do jego konsoli oraz
        zabepieczenie dostępu do niego hasłem. Zaczniemy od czynności, którą
        wykonuje się bardzo łatwo a może mieć dość duże znaczenie. Mianowicie 
        od konfiguracji, nazwy urządzenia.
      </p>
      <p>
        Do zmiany urządzenia służy polecenie <strong>hostname</strong>,
        polecenie to wydajemy w trybie globalnej konfiguracji:
      </p>
<pre class="code-block">
Router(config)#hostname R1
R1(config)#
</pre>
      <p>
        Następnym ważnym elementem jest zablokowanie możliwości przejścia w
        tryb uprzywilejowany przez osoby do tego nieupoważnione, dokonujemy
        tego za pomocą polecenia
        <code class="code-inline">enable secret <em>hasło</em></code>
        w trybie konfiguracji globalnej:
      </p>
<pre class="code-block">
R1(config)#enable secret 2up3r74jn3Has!0
R1(config)#
</pre>
      <p>
        Teraz zabezpieczymy dostęp do trybu EXEC użytkownika, dokonamy tego
        za pomocą kilku poleceń, na początku musimy przejść do konfiguracji
        połączenia konsolowego, dokonujemy tego w trybie konfigracji globalnej
        za pomocą poniższego polecenia:
        <code class="code-inline">line console 0</code>, następnie ustawiamy
        hasło dostępu za pomocą polecenia
        <code class="code-inline">password <em>hasło</em></code> oraz wymuszamy
        logowanie za pomocą polecenia
        <code class="code-inline">login</code>
      </p>
<pre class="code-block">
R1(config)#line console 0
R1(config-line)#password 1234User!
R1(config-line)#login
R1(config-line)#end
</pre>
      <p>
        Jeśli zabezpieczyliśmy konsole to warto zabezpieczyć, również dostęp
        zdalny (na tym etapie, zrobimy to w podstawowym stopniu, w rozdziale
        poświęconym bezpieczeństwu, zrobimy to tak jak należy). Konfigurację
        rozpoczynamy od przejścia w trybie konfiguracji globalnej do trybu
        konfiguracji konsoli wirtualnych, w tym poleceniu należy wskazać
        również ile jest możliwych jednoczesnych połączeń, do konfiguracji
        konsoli wirtualnych, przechodzimy za pomocą poniższego polecenia:
        <code class="code-inline">line vty 0 4</code>, następnie identycznie
        jak w przypadku połączenia konsolowego ustawiamy hasło:
        <code class="code-inline">password <em>hasło</em></code> oraz
        wymuszamy logowanie: <code class="code-inline">login</code>
        Dodatkowym polecenie jakie należy wydać jest wybranie protokołu
        zdalnego dostępu, do dyspozycji mamy <em>Telnet</em> oraz SSH. Wybór
        raczej jest prosty, a dokonujemy go za pomocą poniższego:
        <code class="code-inline">transport input ssh</code> 
      </p>
<pre class="code-block">
R1(config)#line vty 0 4
R1(config-line)#password 1234User!
R1(config-line)#login
R1(config-line)#transport input ssh
R1(config-line)#end
</pre>
      <p>
        Odnośnie tej ilość jednoczesnych połączeń to odpowiadają za to te
        cyfry w pierwszym wierszu przykładu, w tym przypadku pozwoliśmy na
        5 jednoczesnych połączeń.
      </p>
      <p>
        Wpisane przez nas hasła za pomocą polecenia
        <code class="code-inline">password</code>, są niestety przechowyane
        czystym tekstem, jeśli wyświetlimy sobie obecną konfigurację. Jednak
        za pomocą polecenia:
        <code class="code-inline">service password-encryption</code> wydanego
        w trybie konfiguracji globalnej możemy włączyć szyfrowanie haseł.
      </p>
<pre class="code-block">
R1(config)#service password-encryption 
R1(config)#
</pre>
      <p>
        Ostatnią czynnością, jaką należy wykonać na tym etapie jest
        ustawienie informacji, tzw. baneru informującego o głównie o tym
        nieautoryzowany dostęp jest zabroniony. Dokonać tego możemy za pomocą
        polecenia: <code class=="code-inline">banner motd</code> następnie
        umieszczając między krzyżykami (<strong>#</strong>) rzeczoną
        informacje. Polecenie to wydajemy w trybie konfiguracji globalnej.
      </p>
<pre class="code-block">
R1(config)#banner motd # Nieautoryzowany dostep jest zabroniony! #
R1(config)#
</pre>
      <p>
        Teraz przed logowaniem każdy zobaczy taki napis i to nieważne czy
        przez konsole czy SSH. Na chwile obecną konfiguracja naszego urządzenia
        znajduje się w pamięci RAM. A wiemy jako to jest z pamięcią RAM, tak
        więc aby zapisać nasza konfigurację do NVRAM-u. Musimy wydać poniższe
        polecenie:
        <code class="code-inline">copy running-config startup-config</code>
        w trybie uprzywilejowanym EXEC.
      </p>
<pre class="code-block">
R1(config)#end
R1#copy running-config startup-config 
Destination filename [startup-config]? 
Building configuration...
[OK]
R1#
</pre>
      <h3 id="1.10.1.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.1.4-packet-tracer---configure-initial-router-settings_pl-PL.pdf">Konfiguracja ustawień początkowych routera - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.1.4-packet-tracer---configure-initial-router-settings_pl-PL.pka">Konfiguracja ustawień początkowych routera - zadanie</a>
      </p>
      <h2 id="1.10.2.configif">1.10.2. Konfiguracja interfejsów i polecenia podgladu</h2> 
      <p>
        Mając zapisaną początkową konfigurację routera w pamięci NVRAM możemy
        przejść do konfiguracji interfejsów routera, na początku zanim jednak
        skonfigurujemy jakiś interfejs musimy dowiedzieć się jakie są dostępne
        na urządzeniu. Do tego może nam posłużyć polecenie:
        <code class="code-inline">show ip interface brief</code> w trybie
        uprzywilejowanym EXEC.
      </p>
<pre class="code-block">
R1#show ip interface brief
Interface              IP-Address      OK? Method Status                Protocol 
FastEthernet0/0        unassigned      YES unset  administratively down down 
FastEthernet0/1        unassigned      YES unset  administratively down down 
Vlan1                  unassigned      YES unset  administratively down down
R1#
</pre>
      <p>
        Przy okazji tego narzędzia warto wspomnieć dlaczego są dwie kolumny z
        napisem <code class="code-inline">administratively down</code> oraz
        <code class="code-inline">down</code>. Pierwsza kolumna
        <code class="code-inline">Status</code> mówi nam jaki jest status
        faktyczny interfejsu, jeśli wartość tego pola jest jak na przykładzie
        oznacza to interfejs jest wyłączony przez administatora. W przypadku
        kolumny <code class="code-inline">Protocol</code> oznacza, że protokół
        warstwy niższej nie odpowiada - po drugiej stronie nic nie ma.
      </p>
      <p>
        Więcej szczegółów na temat interfejsów możemy uzyskać za pomocą
        polecenia: 
        <code class="code-inline">show interfaces <em>interfejs</em></code>
      </p>
<pre class="code-block">
R1#show interfaces FastEthernet0/0
FastEthernet0/0 is administratively down, line protocol is down (disabled)
  Hardware is Lance, address is 0060.472c.e901 (bia 0060.472c.e901)
  MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Full-duplex, 100Mb/s, media type is RJ45
  ARP type: ARPA, ARP Timeout 04:00:00, 
  Last input 00:00:08, output 00:00:05, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/75/0 (size/max/drops); Total output drops: 0
  Queueing strategy: fifo
  Output queue :0/40 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     0 packets input, 0 bytes, 0 no buffer
     Received 0 broadcasts, 0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort
     0 input packets with dribble condition detected
     0 packets output, 0 bytes, 0 underruns
     0 output errors, 0 collisions, 1 interface resets
     0 babbles, 0 late collision, 0 deferred
     0 lost carrier, 0 no carrier
 --More-- 
</pre>
      <p>
        Warto pamiętać o tym poleceniu, powieważ zwraca kilka przydatnych
        statystyk. Po odświerzeniu informacji, jak wyświetlać informacje o
        interfejsach, możemy przejść do ich konfiguracji. Konfiguracja
        nie będzie szczególnie różnić się od konfiguracja wirtualnego
        interfejsu <em>Vlan1</em> znanego z konfiguracji przełącznika. Dodamy
        jedynie polecenie konfigurjące adres IPv6.
      </p>
      <p>
        A więc jeśli chcemy skonfigurować dajmy na to interfejs 
        <em>FastEthernet0/0</em>
        to w trybie konfiguracji globalnej wydajemy polecenie:
        <code class="code-inline">interface FastEthernet0/0</code>, wówczas
        nasz znak zachęty powinien pokazać nam, że zmieniliśmy tryb. Następnie
        należy dodać opis dlatego interfejsu, za pomocą polecenia:
        <code class="code-inline">desc</code>. Teraz możemy dodawać nasze
        adresy IP, kolejno dla IPv4 poleceniem:
        <code class="code-inline">ip addr <em>adres</em> <em>maska-dziesietnie</em></code>
        oraz dla IPv6 poleceniem:
        <code class="code-inline">ipv6 addr <em>adres</em>/<em>prefix</em></code>
        na koniec podnosimy (uruchamiamy) ten interfejs poleceniem:
        <code class="code-inline">no shutdown</code>.
      </p>
<pre class="code-block">
R1(config)#interface FastEthernet0/0
R1(config-if)#desc WAN
R1(config-if)#ip addr 209.165.200.225 255.255.255.252
R1(config-if)#ipv6 addr 2001:db8:acad:10::1/128
R1(config-if)#no shutdown

R1(config-if)#
%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up
</pre>
      <p>
        Po wydaniu polecenia <code class="code-inline">no shutdown</code>,
        otrzymaliśmy na konsoli informacje o tym, że interfejs się 
        uruchomił. Aby sprawdzić nasze ustawienia możemy wydać ponownie
        polecenia <code class="code-inline">show ip interface brief</code>,
        <code class="code-inline">show ip interface FastEthernet0/0</code> oraz
        dla IPv6
        <code class="code-inline">show ipv6 interface FastEthernet0/0</code>.
      </p>
<pre class="code-block">
R1(config-if)#end
R1#
R1#show ip interface brief
Interface              IP-Address      OK? Method Status                Protocol 
FastEthernet0/0        209.165.200.225 YES manual up                    down 
FastEthernet0/1        unassigned      YES unset  administratively down down 
Vlan1                  unassigned      YES unset  administratively down down
R1#
R1#show interfaces FastEthernet0/0
FastEthernet0/0 is up, line protocol is down (disabled)
  Hardware is Lance, address is 0060.472c.e901 (bia 0060.472c.e901)
  Description: WAN
  Internet address is 209.165.200.225/30
  MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, loopback not set
  Full-duplex, 100Mb/s, media type is RJ45
  ARP type: ARPA, ARP Timeout 04:00:00, 
  Last input 00:00:08, output 00:00:05, output hang never
  Last clearing of "show interface" counters never
  Input queue: 0/75/0 (size/max/drops); Total output drops: 0
  Queueing strategy: fifo
  Output queue :0/40 (size/max)
  5 minute input rate 0 bits/sec, 0 packets/sec
  5 minute output rate 0 bits/sec, 0 packets/sec
     0 packets input, 0 bytes, 0 no buffer
     Received 0 broadcasts, 0 runts, 0 giants, 0 throttles
     0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort
     0 input packets with dribble condition detected
     0 packets output, 0 bytes, 0 underruns
     0 output errors, 0 collisions, 1 interface resets
 --More--
R1#
R1#show ipv6 interface FastEthernet0/0
FastEthernet0/0 is up, line protocol is down
  IPv6 is tentative, link-local address is FE80::260:47FF:FE2C:E901 [TEN]
  No Virtual link-local address(es):
  Global unicast address(es):
    2001:DB8:ACAD:10::1, subnet is 2001:DB8:ACAD:10::1/128 [TEN]
  Joined group address(es):
    FF02::1
  MTU is 1500 bytes
  ICMP error messages limited to one every 100 milliseconds
  ICMP redirects are enabled
  ICMP unreachables are sent
  ND DAD is enabled, number of DAD attempts: 1
  ND reachable time is 30000 milliseconds
</pre>
      <p>
        Zanim przejdziemy dalej, warto omówić sobie oznaczenia interfejsów
        w nomenklaturze Cisco, oprócz natywnego protokołu używanego przez ten
        interfejs typu FastEthernet itd. mamy takie cyferki odzielone
        ukośnikami <code class="code-inline">FastEthernet0/0</code>. W
        urządzeniach Cisco można dodawać interfejsy na specjalnych kartach, te
        karty umieszcza się w <em>slotach</em> urządzenia i ten <em>slot</em>
        to może być jedna z cyfr. Następną cyfrą może być moduł, póki co do
        głowy przychodzą mi tylko wkładki SFP, gdzie może być więcej modułów
        w slocie, lub też moduł przełącznika może być podzielon na dwa
        podmoduły - kiedy druga wartość może by inna niż 0. Ostatnią cyfrą
        jest numer portu. Tak więc maksymalnie mogą być trzy cyfry w oznaczeniu
        interfejsu np. <em>GigabitEthernet0/1/0</em>.
      </p>
      <p>
        Innym przydatnym przydatnym poleceniem przy konfiguracji router może
        być wyświetlenie tablicy routingu za równo dla IPv4 jak IPv6.
      </p>
<pre class="code-block">
R1#show ip route
Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

     209.165.200.0/30 is subnetted, 1 subnets
C       209.165.200.224 is directly connected, FastEthernet0/0

R1#
R1#show ipv6 route
IPv6 Routing Table - 2 entries
Codes: C - Connected, L - Local, S - Static, R - RIP, B - BGP
       U - Per-user Static route, M - MIPv6
       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary
       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect
       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2
       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2
       D - EIGRP, EX - EIGRP external
C   2001:DB8:ACAD:10::1/128 [0/0]
     via ::, FastEthernet0/0
L   FF00::/8 [0/0]
     via ::, Null0
R1#
</pre>
      <h2 id="1.10.3.routerdefaultgatewayconfig">1.10.3. Konfiguracja bramy domyślnej na routerze</h2>
      <p>
        Kiedy wysyłamy pakiet do sieci, której nasz router nie obsługuje
        wysyła on ten pakiet dalej do swojej bramy domyślnej. Identycznie
        robią nasze domowe routery. Bez adresu bramy domyślnej dostęp do
        Internetu byłby niemożliwy. Aby skonfigurować bramę na routerze Cisco
        w trybie konfiguracji globalnej wydajemy polecenie:
        <code class="code-inline">ip default-gateway <em>adres bramy</em></code> 
      </p>
<pre class="code-block">
R1(config)#ip default-gateway 209.165.200.254
R1(config)#
</pre>
      <h3 id="1.10.3.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/build-a-switch-and-router-network.pksz">Podłączanie routera do sieci LAN</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.3.5-packet-tracer---troubleshoot-default-gateway-issues_pl-PL.pdf">Rozwiązywanie problemów z bramą domyślną - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.3.5-packet-tracer---troubleshoot-default-gateway-issues_pl-PL.pka">Rozwiązywanie problemów z bramą domyślną - zadanie</a>
      </p>
      <h2 id="ch10summary">Podsumowanie</h2>
      <p>
        W tym rozdziale poznalismy podstawową konfigurację routera Cisco w tym:
        początkowe ustawienia, konfigurację interfejsów oraz wyświetlenie ich
        stanu ze szczegółami i konfigurację domyślnej bramy.
      </p>
      <h3 id="1.10.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.4.3-packet-tracer---basic-device-configuration_pl-PL.pdf">Podstawowa konfiguracja urządzenia - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/10.4.3-packet-tracer---basic-device-configuration_pl-PL.pka">Podstawowa konfiguracja urządzenia - zadanie</a>
      </p>
      <h3 id="1.10.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/10.4.4-lab---build-a-switch-and-router-network_pl-PL.pdf">Budowanie sieci w oparciu o przełącznik i router</a>
      </p>
      <h1 id="1.11.ipv4adressing">1.11. Adresacja IPv4</h1>
      <p>
        Protokół IPv4
        ten ma tyle lat, że chyba każdy powinien znać podstawy jego działania.
        Dla nas w tej wartstwie może i najważniejszą rzeczą jest adres IPv4
        potocznie nazywany poprostu adresem IP. Adres ten jest unikalny i
        jednoznacznie wskazuje na hosta w sieci. W tym rozdziale zapoznamy się
        tym adresem i dowiemy się jak liczy się takie adresy oraz dzieli ich
        pulę na podsieci.
      </p>
      <h2 id="1.11.1.ipv4structure">1.11.1. Struktura adresów IPv4</h2>
      <p>
        Adres IPv4 jest długości 32-bitów oraz ma hierarchiczną budowę, na
        którą składa się część sieciowa oraz część hostów. Przy określaniu
        tych części warto przyjrzeć się temu adresowi w postaci binarnej.
        Ważna również jest w tym przypadku <strong>maska podsieci</strong>.
      </p>
      <p>
        Chcąc poznać poszczególne części adresu IP należy skonfrontować jego
        zapis binarny z maską, wówczas występujące na masce 1, oznaczają
        część sieciową, a 0 oznaczają część hosta. Taki proces nazywa się
        <em>ANDing</em>-iem.
      </p>
      <p>
        Prefiksem możemy nazwać maskę zapisaną za pomoca liczby występującej
        na niej bitów o wartości 1. Taki prefiks zapisujemy za przy użyciu
        ukośnika (<strong>/</strong>, notacji ukośnika). 
      </p>
      <p>
        Adres sieci, czyli adres wskazujący na początek zakresu naszego
        adresów możemy uzyskać za pomocą przeprowadzenia logicznej operacji
        <strong>AND</strong> (mnożenia, mnożymy bity adresu IP hosta, przez
        bity maski.
      </p>
<pre class="code-block">
   192    .    168    .     10    .     10
1100 0000 | 1010 1000 | 0000 1010 | 0000 1010
   255    .    255    .    255    .     0
1111 1111 | 1111 1111 | 1111 1111 | 0000 0000
---------------------------------------------- AND
1100 0000 | 1010 1000 | 0000 1010 | 0000 0000
   192    .    168    .     10    .     0
</pre>
      <p>
        Na każdą sieci przypada przypadają adresy dwa adresy, których nie
        można użyć do adresowania hostów. Jeden z nich adres sieci poznalismy
        przed chwilą. Drugim jest adres <em>broadcast</em>, adres ten 
        reprezentuje wszystkie hosty w danej podsieci, wskazuje on także koniec
        puli adresowej. W zapisie binarnym wyróznia się on tym, że w części
        hostowej ma on same jedynki.
      </p>
      <h2 id="1.11.2.ipv4castsadresses">1.11.2. Adresy IPv4 Unicast, Broadcast oraz Multicast</h2>
      <p>
        Adresem unikastowym IPv4 możemy nazwać dowolny adres hosta w sieci IP,
        w przypadku adresów unikastowych transmisja odbywa się od jednego
        nadawcy do jednego odbiorcy. Przy czym transmisja Broadcast polega
        na przesłaniu wiadomości z jednego źródła do wszystkich hostów w sieci
        Adres broadcast dla IPv4 jest <em>255.255.255.255</em>. Transmisja
        może odbyć do wybranej grupy hostów, do tego służą adresy multikast,
        adresem, zarezerwowany do tworzenia grup multikastowych, jest zakres
        adresów od 224.0.0.0 do 239.255.255.255. Adresy te służą tylko temu
        celowi i nie powinny być wykorzystywane w innych celach.
      </p>
      <h2 id="1.11.3.typesofipv4addresses">1.11.3. Rodzaje adresów IPv4</h2>
      <p>
        Adresy IP można podzielić na publiczne, które mogą być trasowane
        pomiędzy różnymi sieciami łącząc je ze sobą. Są również adresy
        prywatne, które są wyłącznie do użytku wewnątrz sieci i nie są one
        routowalne. To za pomocą adresów prywatnych, adresujemy nasze hosty
        w sieci. Do dyspozycji mamy trzy klasy w zależności od wielkości
        naszej sieci.
      </p>
      <ul>
        <li><strong>10.0.0.0/8</strong> - 10.0.0.0 - 10.255.255.255</li>
        <li><strong>172.16.0.0/12</strong> - 172.16.0.0 - 172.31.255.255</li>
        <li><strong>192.168.0.0/16</strong> - 192.168.0.0 - 192.168.255.255</li>
      </ul>
      <p>
        Aby hosty zaadresowane adresami z klas prywatnych mogły uzyskać dostęp
        do internetu, potrzebna jest zamiana tych adresów na adresy publiczne.
        Za to odpowiada funkcja <strong>NAT</strong> - Network Address
        Translation. Ta funkcja najcześciej załączona jest na routerze
        brzegowym podłączonym do Internetu.
      </p>
      <p>
        Protokół IP w wersji 4 wyróżnia kilka zakresów adresów specjalnych
        jednym z nich są <strong>adresy pętli zwrotnej</strong> - pozwalają
        na komunikację ze samym sobą oraz sprawdzenie poprawności działania
        stosu TCP/IP. Zakres tych adresów to 127.0.0.0/8 
        (127.0.0.1 - 127.255.255.254), zazwyczaj będziemy spotykać tylko jeden
        adres tego typu - 127.0.0.1. Drugą grupą są adresy typu
        <strong>Link-local</strong>, 169.254.0.0/16
        (169.254.0.1 - 169.254.255.254), te adresy są wykorzystywane przez
        automatyczną adresację adresów IP prywatnych (tzw. APIPA),
        jest
        mechanizm pozwalający na adresowanie interfejsów sieciowych w przypadku
        gdy serwer DHCP jest niedostępny.
      </p>
      <p>
        Cała przestrzeń adresowa IP w wersji 4 jest podzielona na klasy, które
        zawierają poszczególne zakresy adresów, zatem mamy:
      </p>
      <ul>
        <li>Klasa A (0.0.0.0/8 - 126.0.0.0/8)</li>
        <li>Klasa B (128.0.0.0/16 - 191.255.0.0/16)</li>
        <li>Klasa C (192.0.0.0/24 - 223.255.255.0/24)</li>
        <li>Klasa D (224.0.0.0 - 239.0.0.0)</li>
        <li>Klasa E (240.0.0.0 - 255.0.0.0)</li>
      </ul>
      <p>
        Klasowy podział został zastąpiony poprzez adresowanie bezklasowe, przez
        co zakresy w klasach A, B i C mogą okazać się już nie aktualne.
      </p>
      <p>
        Podziałem adresów IP zajmuje się organizacja IANA, podzieliła ona bloki
        adresów na 5 oddziałów regionalnych. Te oddziały regionalne są
        odpowiedzialne przydzielanie adresów do ISP oraz do innych organizacji.
        Za Polskę oraz Europę odpowiada organizacja <strong>RIPE ncc</strong>.
      </p>
      <h2 id="1.11.4.networksegmentation">1.11.4. Segmentacja sieci</h2>
      <p>
        Wiele protokołów wykorzystuje transmisje broadkast oraz multikast.
        Przełączniki rozporowadzają transmisje broadkast na wszystkie swoje
        interfejsy po za tym, z którego ten ruch został otrzymany. Routery
        zatrzymuje te transmisje i nie propagują ich dalej. Routery dzielą
        sieci na domeny rozgłoszeniowe ograniczając wymienione wcześniej
        transmisje tylko do określonych domen.
      </p>
      <p>
        Duże domeny rozgłoszeniowe mogą być problematyczne ponieważ wiele
        hostów, może generować wiele transmisji broadkastowych, co
        wpływa negatywnie na sieć. Rozwiązaniem tego problemu może być
        podzielenie duzych sieci na mniejsze podsieci z wykorzystaniem
        routerów.
      </p>
      <p>
        Podział dużej sieci na mniejsze podsieci, obniża wielkość nadmiarowego
        ruchu i poprawia wydajnosć sieci. Pozwala na zastosowanie odbrębnych
        polityk bezpieczeństwa dla odrębnych podsieci. Podsieci zmniejszają
        liczbę urządzeń, które mogą generować dużo transmisji broadkast lub
        multikast.
      </p>
      <h2 id="1.11.5.ipv4subnets">1.11.5. Podsieci protokołu IPv4</h2>
      <p>
        Sieci IP jesteśmy w wstanie bez trudu podzielić na mniejsze podsieci
        wykorzystując do tego <strong>oktety</strong>. Adres IP ma długość
        32-bitów i jest podzielony na 4 oktety, których zakres
        jest od 0 do 255. W postaci binarnej te wartości można zapisać za
        pomocą 8 bitów. W zależności od tego jak dużej sieci potrzebujemy możem
        przesuwać tę granicę między częścią sieciowa a częścią hostową w
        lewo lub w prawo. Nieznając innych metod najprościej jest przesunąć
        tę granicę o całe 8-bitów. Przez co możemy podzielić taki zakres
        adresów IP: <em>172.16.0.0/16</em> na 256 podsieci po 254 hosty.
        Przesuwając maskę o 8 bitów w prawo. 
      </p>
<pre class="code-block">
172.16.0.0/16:
1. /24 172.16.0.0 - 172.16.0.255: 172.16.0.1 - 172.16.0.254
2. /24 172.16.1.0 - 172.16.1.255: 172.16.1.1 - 172.16.1.254
3. /24 172.16.2.0 - 172.16.2.255: 172.16.2.1 - 172.16.2.254
4. /24 172.16.3.0 - 172.16.3.255: 172.16.3.1 - 172.16.3.254
5. /24 172.16.4.0 - 172.16.4.255: 172.16.4.1 - 172.16.4.254
6. /24 172.16.5.0 - 172.16.5.255: 172.16.5.1 - 172.16.5.254
...
</pre>
      <p>
        Oczywiście sieć z maską 24-bitową, można dzielić dalej, aby jak
        najlepiej wykorzystać ilość przydzielonych nam adresów. Dzieląc tą
        podsieć na mniejsze fragmenty. Poniżej znajdują się table, które mogą
        pomóc nam podzielić czy to sieci 24-bitową czy 16.
      </p>
      <p>
        <img src="https://i.ibb.co/2kSsTfg/tabela-s27.png" alt="tabela-s27" border="0">
      </p>
      <p>
        <img src="https://i.ibb.co/VLpLC54/tabela-s32.png" alt="tabela-s32" border="0">
      </p>
      <p>
        Przy podziale podsieci, niekoniecznie o całe 8 bitów, warto sobie wziąć
        pod uwagę zasadę, że ile bitów zabieramy (przekazujemy je na część
        sieciową) - X to mamy 2^X podsieci. Jeśli mamy ilość podsieci to należy
        podzielić ilość hostów z wyjściowej klasy przez ilość podsieci. Te
        rozważania mogą nam być potrzebne do rozważań na temat adresacji oraz
        w przypadku VLSM.
      </p>
      <h3 id="1.11.5.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.5.5-packet-tracer---subnet-an-ipv4-network_pl-PL.pdf">Podział sieci IPv4 na podsieci - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.5.5-packet-tracer---subnet-an-ipv4-network_pl-PL.pka">Podział sieci IPv4 na podsieci - zadanie</a>
      </p>
      <h2 id="1.11.6.subnetmeetrequirements">1.11.7. Podział na podsieci a wymagania</h2>
      <p>
        W przedsiębiorstwach możemy spotkać różne wymagania. Jednym z nich
        może być to że firma posiada dwie podsieci, jedna z nich jest siecią
        lokalną natomast druga to DMZ (wydzielona sieć dla serwerów, w tej
        sieci urządzenia mogą wykorzystywać adresy publiczne). To wówczas dla
        tej sieci lokalnej możemy wykorzystać pule adresów prywatnych a DMZ,
        niech korzysta z adresów publicznych.
      </p>
      <p>
        Sprawa zaczyna się komplikować, gdy dostajemy już jakieś wytyczne.
        Posiadamy klasę adresów <em>172.16.0.0/22</em>, co daje 1022 hosty.
        Firma posiada 5 lokalizacji, każda z nich ma mieć dostep do Internetu.
        Największa sieć w tych pięciu lokalizacji będzie miała nie więcej niż
        40 hostów. Potrzebne jest zatem 10 podsieci, o wielkości nie mniejszej
        niż 40 hostów, dla naszych potrzeb wystarczy maska o długości 26-bitów
        da to po 62 hosty na sieć, a na każdą z lokalizacji będziemy co
        najmniej dwie podsieci. Jedna podsieci będzie adresować hosty natomiast
        druga połaczenie do ISP. Mamy zatem
      </p>
<pre class="code-block">
Lokalizacja 1:
Do ISP: 172.16.0.0/26
LAN: 172.16.0.64/26

Lokalizacja 2:
Do ISP: 172.16.0.128/26
LAN: 172.16.0.192/26
#Tutaj wyczerpują się 254 hosty dla 172.16.0, dlatego trzeba przejść o jeden
#dalej na 172.16.1.

Lokalizacja 3:
Do ISP: 172.16.1.0/26
LAN: 172.16.1.64/26

Lokalizacja 4:
Do ISP: 172.16.1.128/26
LAN: 172.16.1.192/26

Lokalizacja 5:
Do ISP: 172.16.2.0/26
LAN: 172.16.2.64/26
</pre>
      <p>
        Wmiarę prosty sposób połączyliśmy te lokalizacje, tylko jest
        jednen mały szczegół. Trochę szkoda adresów na połączenie do ISP, 62
        adresy na połaczenie dwóch hostów.
      </p>
      <h3 id="1.11.6.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/11.6.6-lab---calculate-ipv4-subnets_pl-PL.pdf">Obliczanie podsieci IPv4</a>
      </p>
      <h2 id="1.11.7.vlsm">1.11.7. VLSM</h2>
      <p>
        W podanej topologii wymagane jest 7 podsieci (cztery LAN-y oraz 3 WAN-y),
        Największą siecią jest sieć w budynku D ma 28 hostów. Do tego celu
        wybieramy maskę /27, ona da 8 podsieci po 30 hostów IP. Jednak w
        ogólnym rozrachunku, zmarnujemy 84 adresy. Tak więc tradycjne podejście
        nie jest zbyt wydajne. Rozwiązaniem może być <strong>VLSM</strong>,
        który pozwoli nam na podział już podzielonej podsieci. Dzięki VLSM
        możemy dla tych trzech WAN-ów zastosować maskę /30, co da nam tylko
        dwa hosty w tej podsieci, reszta pozostanie do wykorzystania. Takie
        krótkie sieci warto wydzielać od końca, np. żeby adres broadcast całej
        puli był np. adresem broadcast tej podsieci i te mniejsze wydzielać,
        kolejno cofając się po puli.
      </p>
      <h2 id="1.11.8.structureddesign">1.11.8. Projekt strukturalny</h2>
      <p>
        Planowanie sieci IP jest istotnym elementem opracowywania skalowalnego
        rozwiązania dla sieci przedsiębiorstwa. W celu określenia schematu
        adresacji musimy zdobyć wiedzę na temat tego ile potrzebujemy
        podsieci oraz określenie ilości hostów w każdej z nich. Trzeba
        równiez przestudiować zapotrzebowanie na ruch sieciowych organizacji
        oraz określić w jaki sposób te podsieci będą mieć strukturę. Trzeba
        pod uwagę wziąć segmentaryzacje sieci oraz zapotrzebowanie na 
        adresy IP dla różnych urządzeń (jak np. serwery lub
        urządzenia sieciowe) oraz pule VLAN-ów.
      </p> 
      <h3 id="1.11.8.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.7.5-packet-tracer---subnetting-scenario_pl-PL.pdf">Praktyka projektowania i wdrażania VLSM - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.7.5-packet-tracer---subnetting-scenario_pl-PL.pka">Praktyka projektowania i wdrażania VLSM - zadanie</a>
      </p>
      <h2 id="ch11summary">Podsumowanie</h2>
      <p>
        W tym rozdziale poznaliśmy strukturę adresów IP, ich rodzaje oraz
        czym jest broadcast, unicast oraz multicast. Poznaliśmy zakresy
        adresów publicznych, prywatnych oraz tych specjalnych. Dowiedzieliśmy
        się jakie dzielić domeny rozgłoszeniowe oraz zakresy adresów IP na
        podsieci. Na koniec nauczyliśmy się jak korzystać VLSM, aby oszczędzać
        adresy podczas podziału.
      </p>
      <h3 id="1.11.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.9.3-packet-tracer---vlsm-design-and-implementation-practice_pl-PL.pdf">Projektowanie i stosowanie adresacji VLSM - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/11.9.3-packet-tracer---vlsm-design-and-implementation-practice_pl-PL.pka">Projektowanie i stosowanie adresacji VLSM - zadanie</a>
      </p>
      <h3 id="1.11.lab">Laboratorium</h3>
      <p>
        <a href=https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/11.10.2-lab---design-and-implement-a-vlsm-addressing-scheme_pl-PL.pdf"">Projektowanie i wdrażanie schematu adresacji VLSM</a>
      </p>
      <h1 id="1.12.ipv6adressing">1.12. Adresacja IPv6</h1>
      <p>
        Obecnie sieci komputerowe opierają się na podwójnym stosie. Nasze
        komputery są konfigurowane zarówno przy użyciu IPv4 oraz IPv6.
        IPv6 nie jest nowym wynalazkiem, ma już kilka lat. Jedną z przeszkód
        dlaczego używamy IPv4 zamiast IPv6 jest fakt, że protokół IP ma już
        coś około 40 lat. Pakiet mknąc przez przestrzeń może napotkać 
        naprawdę różny sprzęt i dostosowanie się usługodawców internetowych do
        IPv6 jest tak główną przeszkodą do odejścia od IPv4 i zmiany głównego
        protkołu internetowego. W tym rozdziale spróbujemy przybliżyć sobie
        jak wygląda adresacja IPv6. Odpowiemy również na pytanie czy ja muszę
        rzeczywiście pisać te wszystkie cyfry?
      </p>
      <h2 id="1.12.1.ipv4issues">1.12.1. Problemy IPv4</h2>
      <p>
        Adresy IPv4 są nawyczerpaniu. IPv6 jest następcą IPv4. IPv6 ma
        o wiele większą przestrzeń adresową niż IPv4. Implementacja IPv6
        posiada wiele ulepszeń i znosi wiele ograniczeń IPv4. Pula adresowa
        przeznaczona dla krajów europejskich wyczerpała się we wrześniu 2012
        roku. Wszystkie obecnie nowoprzydzielane pule są zaporzyczeniami z
        puli przeznaczonej dla kontynentu afrykańskiego.
      </p>
      <p>
        Organizacja IETF stworzyła wiele protokołów oraz narzędzi mających
        pomóc administratorom w migracji ich sieci na IPv6. Opracowane techniki
        migracji można opisać za pomocą trzech kategorii:
      </p>
      <ul>
        <li><strong>Podwójny stos</strong> - urządzenie używają obu stosów
          jednocześniej.</li>
        <li><strong>Tunelowanie</strong> - metoda przenoszenia pakietów IPv6
          przez sieć IPv4. Pakiet IPv6 jest enkasulowany w pakiecie IPv4.</li>
        <li><strong>Translacja</strong> - mechnizm NAT64 (taki NAT tylko dla
          IPv6) pozwala na komunikowanie się urządzeń używających IPv6 z
          urządzeniami korzystającymi z IPv4.</li>
      </ul>
      <p>
        Warto dodać, że tunelowanie powinno być wykorzystywane tylko tam gdzie
        jest to niezbędne. Naszym celem powinno być zapewnienie domyślnej
        komunikacji z pośrednictwem protokołu IPv6.
      </p>
      <h2 id="1.12.2.ipv6representation">1.12.2. Reprezentacja IPv6</h2>
      <p>
        Adres IPv6 mają długość 128-bitów, zapisywane są za pomocą liczb
        systemu heksadecymalnego (szesnastkowego). Zapis adresu nie jest
        wrażliwy na wielkość znaków, cyfry reprezentujące liczby od 10 (A) do 
        15 (F), można zapisać małymi lub wielkimi literami. Preferowanym
        formatem zapisu jest <code class="code-inline">x:x:x:x:x:x:x:x</code>,
        gdzie każdy <code class="code-inline">x</code> jest czterema cyframi
        heksadecymalnymi, jeden taki <em>x</em> jest również nazywany
        nieoficjalnie <em>hekstetem</em>. Poniżej znajdują się przykładowe
        adresu IPv6.
      </p>
<pre class="code-block">
2001:0db8:0000:1111:0000:0000:0000:0200
2001:0db8:0000:00a3:abcd:0000:0000:1234
</pre>
      <p>
        Powyższy zapis jest niewygodny, wymaga więcej czasu na jego zapisanie
        na stacji roboczej. Dlatego też wymyślono dwie zasady za pomocą,
        których możemy skracać zapis tego typu adresów. Zasady operają się
        na cyfrze 0. Pierwszą z nich jest <strong>ponięcie wiodącego zera</strong>
      </p>
      <p>
        Zatem jeśli mamy na początku hekstetu cyfrę 0, to możemy ją pominąć,
        a hosty same ją poźniej uzupełnią, tak aby każdy hekstet mam 4 znaki.
        Po zastosowaniu tej metody powyższe przykłady wygłądały by nastepująco.
      </p>
<pre class="code-block">
2001:db8:0:1111:0:0:0:200
2001:db8:0:a3:abcd:0:0:1234
</pre>
      <p>
        Zapis jest już krótszy i w pełni poprawny. Drugą zasadą jest
        wykorzystanie <strong>podwójnego dwukropka (::)</strong>. Ta zasada
        mówi, że możemy zastąpić następujące po sobie hekstety zer, podwójnym
        dwukropkiem. Ta zasada ma jednak ograniczenia, otóż może zostać w
        jednym adresie użyta tylko raz. Tak więc nasze adresy możemy zapisać
      </p>
<pre class="code-block">
2001:db8:0:1111::200
2001:db8:0:a3:abcd::1234
#lub jeśli zmodyfikujemy 4 hekstet z 00a3 na 0000, to wówczas taki adres
#możemy zapisać tak:
2001:db8:0:0:abcd::1234
#albo
2001:db8::abcd:0:0:1234
</pre>
      <h2 id="1.12.3.ipv6adresstypes">1.12.3 Typy adresów IPv6</h2>
      <p>
        Istnieją trzy kategorie adresów IPv6, są to m. in.:
      </p>
      <ul>
        <li><strong>Unicast</strong> - adres unikalny dla każdego hosta
          używającego IPv6.</li>
        <li><strong>Multicast</strong> - adres wykorzystywany do wysłania
          jednego pakietu IPv6 do wielu urządzeń.</li>
        <li><strong>Anycast</strong> - dowolny unikastowy adres IPv6, który
          może być przypisany do wielu urządzeń. Pakiet wysłany pakiet na ten
          adres zostanie przekierowany do urządzeń, które go posiadają.</li>
      </ul>
      <p>
        W przeciwieństwie do IPv4 w IPv6 nie ma czegoś takiego jak adres
        <em>broadcast</em>, jednak że istnie adres multikastowy kierowanych
        do wszystkich hostów, co w rezultacie daje takie same efekty.
      </p>
      <p>
        Prefiks oraz jego długość wykorzystywane są do wskazywania sieciowej
        części adresu IPv6. Przedstawiany jest jak maska IPv4 w notacji CIDR.
        Prefiks może mieć długośc od 0 do 128. Jednak rekomendowaną długością
        prefiksu dla sieci LAN oraz innych są 64-bity (/64). Jest to wręcz
        standard, ze względu na ty, że metoda SLAAC (będzie opisana poźniej),
        wykorzystuje pozostałe 64-bity na identyfikator interfejsu użytkownika.
        Użycie takie prefiksu, łatwia podział na podsieci oraz poźniejsze nimi
        zarządzanie.
      </p>
      <p>
        W przeciwieństwie do IPv4, urządzenia korzystające z IPv6 mają po dwa
        adresy przypisane do interfejsów. Pierwszym z nich jest
        <strong>Global Unicast Address (GUA)</strong> - adres ten jest podobny
        do publicznego adresu IPv4, jest unikalny w skali świata oraz
        osiągalny z Internetu. Drugim adresem jest
        <strong>Link-local Address (LLA)</strong> - jest on wymagany przez
        wszystkie urządzenia, które korzystają z IPv6 i sa wykorzystywane 
        do komunikacji tylko w sieci lokalnej przez co są nie routowalne.
      </p>
      <p>
        IPv6 posiada unikalne adresy lokalne (zakres od fc00::/7 do fdff::/7),
        (<em>Unique Local Adress</em>) 
        które posiadają pewne podobnieństwa do adresów prywatnych IPv4, ale
        również istnieje znaczące różnice. Tego rodzaju adresy sa używane do
        adresacji wewnątrz organizacji lub pomiędzy ograniczoną ich
        liczbą. Urządzenia wykorzystujące te adresy nigdy nie będą mieć
        dostępu do innych sieci za ich pośrednictwem. Unikalne adresy lokalne
        nie są ani routowalne, ani zamieniane na adresy globalne IPv6.
      </p>
      <p>
        Niektóre organizacje korzystały sieci prywatnych IPv4, aby ukryć swoje
        sieci przed zagrożeniami z Internetu, jednak to nigdy nie było 
        motywacją do stoswania adresów ULA w IPv6. 
      </p>
      <p>
        Adresami unikastowmi o zasiągu globalnym są tzw. adresy
        <em>Global Unicasts Address</em> - GUA. Tego typu adresy są swojego
        rodzaju adresy publiczne osiagne z Internetu. Obecnie przypisane
        są tylko adresy GUA rozpoczynające sie od 2000::/3, przydzielone
        (zarezerowane) zostały tylko 
        trzy bity. Przy tych trzech bitach można rozpisać tylko 2 cyfry
        2 oraz 3. Zatem obecny zakres GUA rozpoczyna się od 2000 a kończy 3fff.
      </p>
      <p>
        Adresy GUA posiadają określoną strukturę. Składa się on z globalnego
        prefiksu routing, który może być prefiksem, siecią lub pulą adresów.
        Ten prefiks routingu jest przydzielny organizcjom lub klientom przez
        ISP. Następną cześcią adresu jest identyfikator podsieci, znajduje się
        między globalnym prefiksem a identyfikatorem interfejsu. Identyfikator
        podsieci wykorzystywany identyfikacji podsieci wewnątrz organizacji.
        Ostatnią cześcią adresu jest identyfikator interfejsu, jest to część
        adresu odpowiedzialna za identyfikację hosta. Identyfikator hosta ma
        długość 64-bitów, dlatego też rekomendowane jest aby stosować
        64-bitowe prefiksy.
      </p>
      <p>
        IPv6 pozwala na przypisanie hostom adresów składajacych się z samych
        0 lub z samych 1, jednakże adres składajacy się z samych 0 jest
        zarezwowany jako adres <em>anycast</em> <em>Subnet-Router</em> i 
        powinnien być przypisany tylko do routera.
      </p>
      <p>
        Ostatnim typem adresu IPv6 jest <em>Link-local address</em> - LLA.
        Ten pozwala na komunikację wewnątrz tej samej podsieci. Pakiet
        zaadresowane przez LLA nie są routowalne. Każdy interfejs sieciowy
        działający przy użyciu IPv6 musi mieć skonfigurowane LLA, jesli nie
        jest przypisane, urządzenie przypisze je sobie samo, automatycznie.
        Prefiksem dla adresów LLA jest
        <code class="code-inline">fe80::/10</code>
      </p>
      <h2 id="1.12.4.guaandllastaticconfig">1.12.4. Statyczna konfiguracj GUA oraz LLa</h2>
      <p>
        Chcąc skonfigurować ręcznie adres IPv6 GUA, 
        w systemie IOS po przejściu do konfiguracji
        wybranego intefejsu wydajemy poniższe polecenie: 
      </p>
<pre class="code-block">
Router(config-if)# ipv6 address 2001:db8:acad:1::1/64
</pre>
      <p>
        Następnie podnośimy interfejs za pomocą polecnia
        <code class="code-inline">no shutdown</code>. Gotowe.
      </p>
      <p>
        W przypadku konfiguracji stacji roboczych, to konfiguracja wygląda
        podobnie do konfiguracji IPv4, tylko zamiast "Protokoł Internetowy
        w wersji 4" wybieramy "Protokoł Internetowy w wersji 6". Jeśli
        podajemy adres bramy, to najlepszą praktyką jest ustawienie adresu
        LLA routera.
      </p>
      <p>
        Konfigurując LLA na jednym z interfejsów w systemie IOS korzystamy
        z tego samego polecenia. Nie podajemy przy tego rodzaju adresie
        prefiksu. To specjalny adres, który go nie wymaga. Dodajemy również
        specjalne słowo kluczowe: <em>link-local</em>.
      </p>
<pre class="code-inline">
Router(config-if)# ipv6 address fe80::1:1 link-local
</pre>
      <p>
        Konfigurując LLA dla każdego z interfejsów routera warto pamiętać o tym
        aby były one unikalne (wymagane jest aby były unikalne w obrębie
        jednej podsieci).
      </p>
      <h2 id="1.12.5.dynamicaddressingforipv6gua">1.12.5. Dynamiczne adresowanie GUA w IPv6</h2>
      <p>
        Urządzenia mogą uzyskąć adres GUA dynamicznie wykorzystując do tego
        komunikaty ICMP w wersji 6. Host może wysłać zapytanie o router
        (komunikat RS <em>Router Solicitation</em>). W informacji zwrotnej w
        postaci (komunikatu RA <em>Router Advertisment</em>) od routera, host
        dowiaduje się w jaki sposób może uzyskać GUA oraz otrzymuje kilka
        dodatkowych informacji takich jak:
      </p>
      <ul>
        <li>Prefix sieci oraz jego długość.</li>
        <li>Adres domyślnej bramy.<li>
        <li>Adresy DNS oraz nazwę domenowa.</li>
      </ul>
      <p>
        Komunikat RA dostarcza trzy metody dla konfiguracji GUA:
      </p>
      <ul>
        <li>SLAAC</li>
        <li>SLAAC z bezstanowym serwerem DHCPv6</li>
        <li>Stanowy serwer DHCPv6 (bez SLAAC)</li> 
      </ul>
      <p>
        Metoda SLAAC pozwala na skonfigurowanie GUA bez usługi DHCPv6.
        Urządzenia uzyskują informacje do konfiguracji GUA z komunikatów RA
        protokołu ICMP. Prefix również znajdujący się w komunikatach RA
        jest również używany do generowania identyfikatora interfejsu czy to
        w przypadku metody EUI-64 lub metody losowej.
      </p>
      <p>
        W przypadku metody SLAAC i bezstanowego serwera DHCPv6, komunikat RA
        instruuje klientów aby wykorzystali mechnizm SLAAC to utworzenia
        GUA. LLA routera, które jest adresem źródłowym pakiety RA zostaje
        zapisany jako adres bramy. Używa się bezstanowego serwera DHCPv6 do
        uzyskania takich informacji jak adres DNS oraz nazwę domenową.
      </p>
      <p>
        Ostatnią metodą jest poinstruowanie przez pakiet RA do użycia
        stanowego serwera DHCPv6. Stanowe DHCPv6 jest podobne do DHCP dla
        IPv4. Urządzenie automatycznie otrzymuje GUA, długość prefiksu oraz
        adresy serwerów DNS z serwera DHCPv6. Komunikat RA sugeruje aby
        urządzenia użyły adresu źródłowego komunikatu RA, którym jest
        LLA jako adresu bramy oraz serwera DHCPv6 do uzyskania innych
        informacji
      </p>
      <p>
        Nie zależnie czy w RA będzie sugerowane SLAAC czy SLAAC z uzyciem
        bezstanowego DHCPv6, klient musi wygenerować identyfikator interfejsu.
        Taki identyfikator jest tworzony za pomocą metody EUI-64 lub za pomocą
        wygenerowanych losowo 64-bit liczb. 
      </p>
      <p>
        Instytucja IEEE określa EUI (<em>Extended Unique Identifier</em>) lub
        jego zmodyfikowaną wersję EUI-64, która polega na utworzeniu
        identyfikatora umieszczając 16-bitową wartość heksadecymalną <em>fffe</em>
        w środku adresu MAC interfejsu, korzystającego z tej metody, oraz
        odwróceniu w siódmego bitu adresu MAC z wartości binarnej 0 na 1.
      </p>
      <p>
        Alternatywną metodą jest wygenerowanie 64-bitów liczb heksadecymalnych
        zamiast generowania identyfikatora za pomocą metody EUI-64. Tak dzieje
        się w wszystkich współczesnych systemach MS Windows.
      </p>
      <p>
        Aby zapewnić unikalnosć adresów, hosty mogą użyć mechanizmu DAD
        (<em>Duplicate Address Detection</em>). Jest to podobne do protokołu
        ARP, żądanie o swój adres. Jeśli odpowiedź nie nadejdzie to oznacza,
        że adres jest unikatowy.
      </p>
      <h2 id="1.12.6.dynamicaddressingforipv6lla">1.12.6. Dynamiczna adresacja LLA w IPv6</h2>
      <p>
        Wszystkie interfejsy IPv6 muszą mieć przypisane LLA
        (<em>Link-local Address</em>). Podobnie do GUA, LLA może zostać
        przypisane dynamicznie. Jak pamiętamy LLA składa się z prefiksu
        <em>fe80::/10</em>, pozostałe bity są dopełniane zerami. Następnie
        występuje identyfikator interfejsu (zazwyczaj jest 64-bity liczb
        heksadecylmanych).
      </p>
      <p>
        Systemy operacyjne z rodziny Windows do konfiguracji IPv6 domyślnie
        wykorzysują utworzone przez SLAAC GUA oraz dynamicznie przydzielone
        LLA. W przypadku systemów IOS LLA jest generowane nawet wtedy gdy
        adres GUA nie jest skonfigurowany. Adres LLA w systemach firmy Cisco
        jest generowany przy użyciu EUI-64.
      </p>
      <h3 id="1.12.6.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.6.6-packet-tracer---configure-ipv6-addressing_pl-PL.pdf">Konfiguracja adresacji IPv6 - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.6.6-packet-tracer---configure-ipv6-addressing_pl-PL.pka">Konfiguracja adresacji IPv6 - zadanie</a>
      </p>
      <h2 id="1.12.7.multicasts">1.12.7. Adresy typu multicast IPv6</h2>
      <p>
        Multikastowe adresy IPv6 posiadają prefiks ff00::/8. Istnieją dwa
        rodzaje adresów multikastowych:
      </p>
      <ul>
        <li>adres multikastowy <em>Well-Known</em>,</li>
        <li>adres multikastowy <em>Solicited-node</em>.<li>
      </ul>
      <p>
        Warto zwrócić na to uwagę, że adresy multikastowe mogą być jedynie
        używane jako adresy docelowe, a nie źródłowe. 
      </p>
      <p>
        Adresy <em>Well-known</em> są adresami już przypisanymi i
        zarezerowanymi dla predefiniowanych grup urządzeń. Istnieje dwie
        powszechne grupy przypisanych adresów multikastowych:
      </p>
      <ul>
        <li><strong>ff02::1 grupa multikastowa <em>All-nodes</em></strong> - 
          Jest grupa, do której należą wszysktie hosty korzystające z IPv6.
          Pakiet wysłany do tej grupy zostanie odebrany i przetworzony przez
          wszystkie interfejsy w sieci</li>
        <li><strong>ff02::2 grupa multikastowa <em>All-routers</em></strong> -
          Grupa wszystkich routerów obsługujących routing unikastowy w dla IPv6
          (router, żeby mógł dołączyć do tej grupy musi być skonfigurowany
          poprze wydanie poniższego polecenia):
<pre class="code-block">
Router(config)# ipv6 unicast-routing
</pre>
         
        </li>
      </ul> 
      <p>
        Adres multikastowy dla <em>solicited-node</em> jest podobny do adresu
        <em>all-nodes</em>. Adres <em>solicited-node</em> jest mapowany do
        specjalnego adresu multikastowego <strong>Ethernet</strong>. Przez to
        karty sieci <em>Ethernet</em> są wstanie odfiltrować taki pakiet
        sprawdzając adres docelowy zanim trafi do przetwarzania przez IPv6
        w celu ustalenia czy host, do którego ten pakiet trafił jest hostem
        dla niego docelowym.
      </p>
      <h3 id="1.12.7.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/12.7.4-lab---identify-ipv6-addresses_pl-PL.pdf">Identyfikacja adresów IPv6</a>
      </p>
      <h2 id="1.12.8.subnetsofipv6">1.12.8. Podsieci protokołu IPv6</h2>
      <p>
        Protokół IPv6 posiada już zaprojektowaną możliwość podziału większych
        sieci na podsieci. Adres GUA posiada wydzielone pole na 
        <strong>identyfikator podsieci</strong> (<em>subnet ID</em>)
        wykorzystywane przy tworzeniu podsieci. Identyfikator podsieci znajduje
        się między globalnym prefiksem routingu, a identyfikatorem
        interfejsu.
      </p>
      <p>
        Załóżmy, że otrzymaliśmy globalny prefiks routingu o wartości:
        <code class="code-inline">2001:db8:acad::/48</code>, wraz 16-bitami
        identyfikatora podsieci to daje nam 65,535 podsieci. Globalny prefiks
        pozostaje dla wszystkich tych podsieci, inkrementacji natomiast będzie
        ulegać jedynie kolejny po nim hekstet.
      </p>
<pre class="code-block">
2001:db8:acad:0000::/64
2001:db8:acad:0001::/64
2001:db8:acad:0002::/64
2001:db8:acad:0003::/64
2001:db8:acad:0004::/64
2001:db8:acad:0005::/64
2001:db8:acad:0006::/64
2001:db8:acad:0007::/64
2001:db8:acad:0008::/64
2001:db8:acad:0009::/64
2001:db8:acad:000a::/64
2001:db8:acad:000b::/64
2001:db8:acad:000c::/64
...
2001:db8:acad:ffff::/64
</pre>
      <p>
        Posieciami IPv6 w praktyce operujemy tak samo jak w przypadku podsieci
        IPv4. Dla każde z nich potrzebujemy osobnego interfejsu na routerze.
      </p>
      <h3 id="1.12.8.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.9.1-packet-tracer---implement-a-subnetted-ipv6-addressing-scheme_pl-PL.pdf">Implementacja schematu adresowania podsieci IPv6 - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/12.9.1-packet-tracer---implement-a-subnetted-ipv6-addressing-scheme_pl-PL.pka">Implementacja schematu adresowania podsieci IPv6 - zadanie</a>
      </p>
      <h2 id="ch12summary">Posumowanie</h2>
      <p>
        W tym rodziale zostaliśmy zaznajomieni z protokołe IPv6 zobaczyliśmy
        jak wygląda taki adres IPv6 i w jaki sposób można go zapisać.
        Poznaliśmy rodzaje adresów tego protokołu oraz nauczyliśmy się
        konfigurować statyczne adresy GUA oraz LLA. Przedstawiono nam
        techiniki dynamicznego uzyskiwania adresu GUA oraz LLA. Na koniec
        dowiedziliśmy się jakie są adresy multikastowe dla IPv6 oraz
        zapoznaliśmy się z podziełem sieci IPv6 na podsieci.
      </p>
      <h2 id="1.12.lab">Laboratorium</h2>
      <p>
        <a href=https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/12.9.2-lab---configure-ipv6-addresses-on-network-devices_pl-PL.pdf"">Konfiguracja adresów IPv6 urządzeń sieciowych</a>
      </p>
      <h1 id="1.13.icmpprotocol">1.13. Protokół ICMP</h1>
      <p>
        Protokół ICMP jest protokołem diagnostyczno-kontrolnym, wspomagający
        protokoł IP. Przez użytkowników może zostać wykorzystany do sprawdzenia
        połączenia z siecią oraz weryfikacji trasy wysyłanych pakietów.
      </p>
      <h2 id="1.13.icmpmessages">1.13.1. Komunikaty protokołu ICMP</h2>
      <p>
        Protokoł ICMP dostarcza informacji o problemach związanych z
        przetwarzaniem pakietów IP w określonych warunkach.
      </p>
      <p>
        ICMP w wersji 4 posiada głównie funkcjonalność sygnalizacyjną na IPv4.
        Natomast w przypadku IPv6 funkcjonalność protokołu ICMPv6
        rozszerzono o dodatkowe role.
      </p>
      <p>
        Oczywiśćie ICMP dla IPv6 dalej pozostaje protokołem sygnalizacyjnym.
        Obie wersje protokółu wspierają podstawowe komunikaty takie
        jak:
      </p>
      <ul>
        <li>Osiągalność hosta</li>
        <li>Nieosiągalność celu lub usług</li>
        <li>Wyczerpanie czasu</li>
      </ul>
      <p>
        Warto zaznaczyć, że nie ze wszystkich sieci otrzymamy odpowiedź,
        ponieważ w wielu z nich protokół ICMP jest blokowany przy użyciu
        zapory, ze względów bezpieczeństwa.
      </p>
      <p>
        Do badania osiągalności hosta, można wykorzystać komunikat 
        ICMP <strong>Echo</strong>. Jeden z hostów wysyła do drugiego
        żądanie <em>Echo</em> (<em>request</em>), jeśli ten drugi host jest
        osiągalny to odpowie przy użyciu komunikatu odpowiedzi <em>Echo</em>
        (<em>reply</em>)
      </p>
      <p>
        W przypadku mierzenia osiagalności celów oraz usług sprawa trochę
        bardziej skomplikowana. Komunikat ICMP może zawierać specjalny
        kod, który wskaże nam dlaczego pakiety nie mogą dotrzeć.
      </p>
      <p>
        Dla IPv4 są to kolejno:
      </p>
      <ul>
        <li><strong>0</strong> - sieć jest nieosiągalna</li>
        <li><strong>1</strong> - host jest nieosiągalny</li>
        <li><strong>2</strong> - protokół jest nieosiągalny</li>
        <li><strong>3</strong> - port jest nieosiągalny</li>
      </ul>
      <p>
        Natomiast dla IPv6 są to kolejno:
      </p>
      <ul>
        <li><strong>0</strong> - brak trasy do celu</li>
        <li><strong>1</strong> - komunikacja z celem została zablokowana przez
          administratora (np. na komunikację nie pozwala firewall)</li>
        <li><strong>2</strong> - poza zakresem adresu źródłowego</li>
        <li><strong>3</strong> - adres nieosiągalny</li>
        <li><strong>4</strong> - port nieosiągalny</li>
      </ul>
      <p>
        Innym rodzajem komunikatu jest upłynięcie czasu. Jak możemy pamiętać
        z budowy nagłówka pakietu IPv4, to zawiera on pole TTL, każde
        przejście pakietu przez router obniża tą wartość o 1, aż do jej
        wyzerowania. W momecie wyzerowania pola TTL, dla np. naszego
        żądania <em>Echo</em>, możemy otrzymać komunikat o tym, że pole TTL
        zostało wyzerowane w trakcie przesyłu pakietu
      </p>
      <p>
        Protokół ICMP dla IPv6 został zaktualizowany, a jego funkcjonalność
        została rozszerzona na 4 nowe rodzaje komunikatów jako część
        protokołu <em>Neighbor Discover Protocol</em>.
      </p>
      <p>
        Nowe komunikaty dzielą się na wymieniane między hostem a routerem,
        to jest:
      </p>
      <ul>
        <li><strong>Zapytanie o router</strong> - <em>Router Solicitation</em>
          (RS)</li>
        <li><strong>Ogłaszanie się routera</strong> -
          <em>Router Advertisement</em> (RA)</li>
      </ul>
      <p>
        Jak i na te wymienie między hostami, to jest:
      </p>
      <ul>
        <li><strong>Zgłoszenie się hosta</strong> -
          <em>Neighbor Solicitation</em> (NS)</li>
        <li><strong>Ogłoszenie się hosta</strong> -
          <em>Neighbor Advertisement</em> (NA)</li>
      </ul>
      <p>
        ICMPv6 zawiera jeszcze inne komunikaty, ale są one np. podobne do 
        komunikatu przekierowania (<em>redirect</em>) wykorzystywanego IPv4.
      </p>
      <p>
        Komunikaty RA w IPv6 są wysyłane przez router co 200 sekund, aby
        dostarczyć informacje do wszystkich obsługujących IPv6 urządzeń.
        Poza adresami routera przekazywany jest prefix i jego długość, adresy
        DNS czy nazwa domenowa. Komunikaty RA są wykorzystywane do konfiguracji
        bramy domyślnej dla hostów, które są ustawione na samodzielną
        konfigurację.
      </p>
      <p>
        Routery odpowiedzą za pomocą komunikatu RA na otrzymany komunikat RS.
        Hosty wysyłają RS w celu określenia informacji na temat adresacji
        protokołu IPv6.
      </p>
      <p>
        Urządzenia, które mają skonfigurowane IPv6 pod GUA lub Local-Link,
        mogą używać mechanizmu <strong>DAD</strong>
        (<em>Duplicate Adress Detection</em>) w celu upewnienia się o
        unikalności adresu. W celu sprawdzenia unikalności swojego adresu
        host wysyła komunikat NS, ustawiając swój adres jako adres docelowy.
        Jeśli jeden z hostów będzie mieć taki adres, wówczas odpowie na tem
        pakiet komunikatem (NA).
      </p>
      <p>
        W przypadku IPv6 protokół ICMP w wersji 6, przejął rozwiązywanie
        adresów IP na adresy MAC. Host, który potrzebuje adresu MAC innego
        hosta wysła do niego komunikat NS. W odpowiedzi host odpowiada
        komunikatem NA zawierającym adres MAC stacji, która go wysłała.
      </p>
      <h2 id="1.13.2.pingandtraceroutetests">1.13.2. Testy ping oraz traceroute</h2>
      <p>
        Polecenie <strong>ping</strong> jest narzędziem testowym zarówno dla
        IPv4 i IPv6. Polega ono na wysłaniu kilku komunikatów 
        <em>echo requests</em> i oczekiwaniu na <em>echo reply</em>
        wyswietlając każdą odpowiedź. Na koniec zwracane jest podsumowanie
        zawierające m. in. uśredniony czas wszystkich odpowiedzi. Polecenia
        ping mogą wyglądać różnie w zależności od systemu.
      </p>
<pre class="code-block">
#MS Windows:
C:\Users\xf0r3m\Desktop&gt;ping 192.168.8.1

Pinging 192.168.8.1 with 32 bytes of data:
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64
Reply from 192.168.8.1: bytes=32 time&lt;1ms TTL=64

Ping statistics for 192.168.8.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

#Dystrybucja Linuksa - immudex:
󱩊 xf0r3m@laptop-45f33b2/ ~/󰯆 ping 192.168.8.1
PING 192.168.8.1 (192.168.8.1) 56(84) bytes of data.
64 bytes from 192.168.8.1: icmp_seq=1 ttl=64 time=0.591 ms
64 bytes from 192.168.8.1: icmp_seq=2 ttl=64 time=0.643 ms
64 bytes from 192.168.8.1: icmp_seq=3 ttl=64 time=0.524 ms
64 bytes from 192.168.8.1: icmp_seq=4 ttl=64 time=0.793 ms
^C
--- 192.168.8.1 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3078ms
rtt min/avg/max/mdev = 0.524/0.637/0.793/0.099 ms

#Cisco IOS - przełącznik (ver. 15.2):
Switch#ping 192.168.8.1

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.8.1, timeout is 2 seconds:
.!!!!
Success rate is 80 percent (4/5), round-trip min/avg/max = 0/0/0 ms
</pre>
      <p>
        Polecenie ping możemy zastosować kilku scenariuszach aby uzyskać kilka
        odpowiedzi. Jeśli chcemy sprawdzić czy nasz stos sieciowy działa
        poprawnie możemy zpingować swój adres pętli zwrotnej:
        <code class="code-inline">ping 127.0.0.1</code>. Pozytywna odpowiedź
        oznacza, że nasz host może funkcjonować we wszystkich współczesnych
        sieciach. Drugim testem jaki możemy wykonać jest ping na adres bramy
        domyślnej, pozwoli nam to ustalić czy nasz konfiguracja IP jest
        prawidłowa. Szczególnie przydatne, gdy konfigurowaliśmy nasz interfejs
        ręcznie
        bez użycia serwera DHCP. Jeśli odpowiedź na ten test będzie pozytywna
        to oznacza, to że nasz host ma możliwość komunikacji w sieci, do
        której jest podpięty. Ostatnim trzecim testem jest sprawdzenie
        dostępności jakiegoś hosta w Internecie lub w drugiej sieci. Takie
        działania może mieć na celu upewnienie się, że mamy dostęp Internetu
        oraz, że nasz router jest skonfigurowany jeśli obsługuje on więcej niż
        dwie sieci.
      </p>
      <p>
        Innym z narzędzi pozwalających nam testować możliwości połączenia. Jest
        <strong>traceroute</strong> w systematch takich jak Windows może
        nosić nazwę <em>tracert</em>. Nie koniecznie może być przedatne
        zwykłym użytkownikom, ale jeśli administrator ma kilka routerów, to
        za pomocą tego narzędzia sprawdzić możliwości komunikacji miedzy
        odległymi sieciami. Działa ono w oparciu o komunikat 
        <em>Time exceeded</em> manipulując wartością TTL. Na początku nadawca
        wysyła pakiet IP z zawartością ICMP do docelowego hosta
        ustawia TTL na jeden i przesyła do bramy. Brama zmniejsza TTL i
        odsyła do klienta komunikata <em>time exceeded</em>, nam na ekranie
        pojawia się pierwszy skok. Następnie nadawca zwiększa TTL o 1 i
        wysyła ponownie i tak dalej, aż osiągnie cel podany podczas wydawania
        polecenia lub liczba skoków osiągnie 30. Zamiast nazw hostów (routerów)
        lub ich adresów IP zobaczymy gwiazdki (<strong>*</strong>), wówczas
        oznaczna to, że wysłany pakiet został utracony lub host nie jest
        w stanie (np. ze względów bezpieczeństwa) opowiedzieć za pomoca
        komunikatu <em>time exceeded</em>.
      </p>
      <p>
        W przypadku nagłówków pakietów IPv6 nie mamy doczynienia z polem TTL, a
        z polem <em>Hop Limit</em>.
      </p>
      <h3 id="1.13.2.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.6-packet-tracer---verify-ipv4-and-ipv6-addressing_pl-PL.pdf">Weryfikacja adresacji IPv4 i IPv6 - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.6-packet-tracer---verify-ipv4-and-ipv6-addressing_pl-PL.pka">Weryfikacja adresacji IPv4 i IPv6 - zadanie</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.7-packet-tracer---use-ping-and-traceroute-to-test-network-connectivity_pl-PL.pdf">Stosowanie komendy ping oraz traceroute do testowania połączeń w sieci - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.2.7-packet-tracer---use-ping-and-traceroute-to-test-network-connectivity_pl-PL.pka">Stosowanie komendy ping oraz traceroute do testowania połączeń w sieci - zadanie</a>
      </p>
      <h2 id="ch13summary">Podsumowanie</h2>
      <p>
        Ten rozdział zamyka warstwę trzecią. Poznaliśmy w nim protokoł ICMP, 
        podstawowe komunikaty oraz ich rodzaje. Dowiedzieliśmy się jaką ważną
        rolę będzie pełnić ten protokół w sieciach opartych na IPv6. 
        Na koniec omówiliśmy sobie sposób działania narzędzi takich jak 
        <em>ping</em>
        czy <em>traceroute</em> oraz w jaki sposób wykorzystują do swojego
        działania komunikaty protokołu ICMP.
      </p>
      <h3 id="1.13.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
         <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.3.1-packet-tracer---use-icmp-to-test-and-correct-network-connectivity_pl-PL.pdf">Używanie ICMP do testowania i korygowania łączności - scenariusz</a>
         <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/13.3.1-packet-tracer---use-icmp-to-test-and-correct-network-connectivity_pl-PL.pka">Używanie ICMP do testowania i korygowania łączności - zadanie</a>
      </p>
      <h3 id="1.13.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/13.3.2-lab---use-ping-and-traceroute-to-test-network-connectivity_pl-PL.pdf">Stosowanie komendy ping oraz traceroute do testowania połączeń w sieci</a>
      </p>
      <h1 id="1.14.transportlayer">1.14. Warstwa transportowa</h1>
      <p>
        Warstwa transportowa jest odpowiedzialna za komunikację pomiędzy
        aplikacjami uruchomionymi na różnych komputerach. Wraz z niższymi 
        warstwami odpowiedzialna jest za komunikację sieciową.
      </p>
      <h2 id="1.14.1.transportationofdata">1.14.1. Dostarczanie danych</h2>
      <p>
        Warstwa transportowa jest odpowiedzialna za takie czynności jak: 
      </p>
      <ul>
        <li>Śledzenie indywidualnych połączeń</li>
        <li>Segmentacje danych i ich ponowne złożenie</li>
        <li>Dodanie nagłówka informacji do danych, tworząc segment</li>
        <li>Identyfikacje, separację oraz zarządzanie wieloma połączeniami</li>
        <li>Wykorzystanie segmentacji oraz multipleksacji do umożliwienia
          prowadzenia wielu połączeń w tej samej sieci.</li>
      </ul>
      <p>
        Warstwa IP nie ma możliwość bezpośredniego dostarczenia danych w
        docelowe miejsce. Określają to protokoły warstwy transportowej są one
        odpowiedzialne za sposób wymiany danych między hostami oraz
        za spełnienie wymagań wykorzystywanych połączeń. Protokołami warstwy
        transportowej są <strong>TCP</strong> oraz <strong>UDP</strong>.
      </p>
      <p>
        Protokoł TCP wybierany jest przez aplikacje wymagające niezawodnego
        połączenia. Funkcjonalnością warstwy transportowej, za które odpowiada
        protokół TCP to:
      </p>
      <ul>
        <li>Numerowanie oraz śledzenie segmentów danych dostarczanych do
          określonych hostów oraz określonych aplikacji</li>
        <li>Potwierdzenie otrzymania danych</li>
        <li>Retransmisję każego niepotwierdzonego fragmentu danych, po
          określonyn czasie.</li>
        <li>Skwencjonowane dane mogą być dostarczane w dowolnej kolejności</li>
        <li>Dostosowanie wysyłania danych do możliwości odbiorcy.</li>
      </ul>
      <p>
        Protokoł UDP dostacza bardzo podstawowywch funkcji dostarczania danych
        między określonymi aplikacjiami, przy minimalnym obciążeniu oraz
        weryfikacji poprawności przesyłanych danych. Cechami, które wyróżniają
        ten protokoł jest:
      </p>
      <ul>
        <li>Protokoł UDP jest bezpołączeniowy.</li>
        <li>Protokół UDP uznawany jest protokoł <em>best-effort</em>, ponieważ
          nie stosuje on potwierdzeń po otrzymaniu danych.</li>
      </ul>
      <p>
        Protokół UDP jest również wykorzystywany dla aplikacji działajacej na
        zasadzie żądanie-odpowiedź, gdzie ilość danych jest niewielka, nie
        ma tam również retransmisji, przez co taka wymiana informacji może
        zostać bardzo szybko zrealizowana. Przykład: transmisja głosu (VoIP),
        komunikacja z DNS. Wymagane cechy:
      </p>
      <ul>
        <li>Szybki</li>
        <li>Minimalne obciążenie</li>
        <li>Nie wymaga potwierdzeń</li>
        <li>Nie wysyła retransmisji</li>
        <li>Dostarcza dane w kolejności w jakiej dotrą do hosta docelowego</li>
      </ul>
      <p>
        Inne aplikacje, którym bardziej zależy na jakość przesyłanych danych
        wybiorą transmisję opartą na protokole TCP. Przykład: Poczta
        elektroniczna (protokoły IMAP/SMTP) czy przeglądanie sieci WWW (HTTP).
        Wymagane cechy:
      </p>
      <ul>
        <li>Rzetelny</li>
        <li>Wysyła potwierdzenia otrzymania danych</li>
        <li>Dokonuje retransmisji zagubionych danych</li>
        <li>Dostarcza dane w kolejności ich wysłania przez hosta źródłowego.</li> 
      </ul>
      <h2 id="1.14.2.tcpheader">1.14.2. Nagłówek TCP</h2>
      <p>
        Podczas ekapsulacji dane z warstwy aplikacji trafiają do wartstwy
        transportowej. Tutaj surowe dane z aplikacji są zamieniane w segmenty
        po dodaniu nagłówka wykorzystywane do transmisji protokołu warstwy
        transportowej. Poniżej znajduje się obraz przedstawiający nagłówek
        TCP.
      </p>
      <p>
        <img src="https://i.ibb.co/7VWBc0Q/tcp-header.png" alt="tcp-header" border="0">
      </p>
      <ul>
        <li><strong>Port źródłowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji źródłowej.</li>
        <li><strong>Port docelowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji docelowej.</li>
        <li><strong>Numer sekwencji</strong> - 32-bitowe pole przechowywujące
          numer porządkowy dla celu ponownego złożenia informacji w kolejności
          w jakiej została wysłana.</li>
        <li><strong>Numer potwierdzenia</strong> - 32-bitowe pole wykorzysywane
          do wskazania danych, które zostały otrzymane oraz następny bajt
          oczekiwany od źródła.</li>
        <li><strong>Długość nagłówka</strong> - 4-bitowe pole bardziej znane
          jako offset danych, wskazuje długość nagłówka segmentu TCP.</li>
        <li><strong>Zarezerowane</strong> - 6-bitowe pole pozostawione do
          poźniejszego wykorzystania.</li>
        <li><strong>Bity kontrolne</strong> - 6-bitowe pole zawierające flagi
          oraz kody bitowe, wskazując cel oraz funkcję tego segmentu TCP.</li>
        <li><strong>Rozmiar okna</strong> - 16-bitowe pole wskazujące liczbę
          bajtów, która może być potwierdzona za jednym razem.</li>
        <li><strong>Suma kontrolna</strong> - 16-bitowe pole używane to
          do ustalenia poprawności segmentu.</li>
        <li><strong>Ważność</strong> - 16-bitowe pole wykorzystywane do
          wskazania ważności (istotności) przesyłanych danych.</li>
      </ul>
      <h2 id="1.14.3.udpheader">1.14.3. Nagłowek UDP</h2>
      <p>
        Segmenty UDP rownież posiadają nagłówki, jednak nie tak rozbudowne
        jak w przypadku TCP. Dla porównania nagłówek UDP zawiera tylko 4 pola.
      </p>
      <p>
        <img src="https://i.ibb.co/9230nLx/udp-header.png" alt="udp-header" border="0">
      </p>
      <ul>
        <li><strong>Port źródłowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji źródłowej.</li>
        <li><strong>Port docelowy</strong> - 16-bitowe pole wykorzystywane do
          identyfikacji aplikacji docelowej.</li>
        <li><strong>Długość nagłówka</strong> - 4-bitowe pole bardziej znane
          jako offset danych, wskazuje długość nagłówka datagramu UDP.</li>
        <li><strong>Suma kontrolna</strong> - 16-bitowe pole używane to
          do ustalenia poprawności datagramu.</li>
      </ul>
      <h2 id="1.14.4.portnumbers">1.14.4. Numery portów</h2>
      <p>
        Protokoły TCP oraz UDP wykorzystują numery portów do zarządzania
        działająch w tym samym czasie połączeń. Port źródłowy wskazuje
        aplikację źródłową na lokalnym hoście natomast port docelowy
        aplikację docelową na hoście zdalnym.
      </p>
      <p>
        Porty znajdują się wewnątrz segmentów warstwy transportowej, Segmenty
        natomiast są enkapsulowane w pakiety IP. Kombinacja adresu IP oraz 
        numeru portu nie ważne, z której strony w transmisji nazwany jest
        <strong>gniazdem</strong>. Gniazda umożliwiają klientom wielkrotne
        połączenia z tym samym serwerem, czy tą samą usługą.
      </p>
      <p>
        Portów ze względu na rozmiar pola portu docelowego i źródłego ma
        długość 16-bitów, to bez modyfikacji nagłówków porty mają zakres
        od <strong>0</strong> do <strong>65535</strong>. Większość portów jest
        już przydzielona i mozna je podzielić na trzy mniejsze zakresy,
      </p>
      <ul>
        <li><strong>Dobrze znane porty</strong> - zakres:
          <strong>0 - 1023</strong> - większość znanych nam usług sieciowych,
          HTTP, FTP czy poczta.</li>
        <li><strong>Porty zarejestrowane</strong> - zakres:
          <strong>1023 - 49151</strong> - Porty przydzielone przez IANA dla
          aplikacji i procesów, znane porty z tego zakresu np.: 2049/TCP NFS
          czy 3306/TCP serwer baz danych MySQL.</li>
        <li><strong>Porty prywatne/dynamiczne</strong> - zakres:
          <strong>49152 - 65535</strong> - Porty do wykorzystywane przez
          klienta jako port źródłowy.</li>
      </ul>
      <p>
        Nie będę wypisywał tutaj jakiś list. Wszystko jest dostępne w
        Internecie lub w dystrybucjach Linuksa w pliku <em>/etc/services</em>.
      </p>
      <p>
        Warto odczasu do czasu zwrócić uwagę na to jakie połaczenia są
        realizowane w naszym systemie w zależności od systemu możemy
        wykorzystać do tego albo polecenie <strong>netstat</strong> dla
        MS Windows lub <strong>ss</strong> dla dystrybucji Linuksa.
      </p>
      <h2 id="1.14.5.tcpcommunicationproces">1.14.5. Procesy komunikacji TCP</h2>
      <p>
        Każdy proces aplikacji serwera jest skonfigurowany w taki sposób, aby
        korzystać z portów. Dwie aplikacje na tym samym serwerze nie mogą mieć
        przypisanych tych samych portów. Aktywna aplikacja z przypisanym
        portem uznaje się za <strong>otwarą</strong>, oznacza to mniej więcej
        tyle, że jej proces przyjmie dane przekazane do tego portu. Oznacza to
        również, że każde żądanie od klientów jest akceptowane i dane
        przekazywane są do procesu aplikacji.
      </p>
      <p>
        Klient nawiązuje połączenie w tzw. schemacie
        <em>Three-Way-Handshake</em>. W wygląda to mniej więcej w taki sposób
      </p>
      <ol>
        <li>Klient incjalizuje połaczenie w modelu klient-serwer z serwerem
          wysyłając do niego segment z ustawioną flagą SYN.</li>
        <li>Serwer odpowiada na próbę inicjalizacji połączenia odsyłając
          do klienta segment z ustawionymi flagami SYN, ACK.</li> 
        <li>Klient przesyła odpowiedź do serwera z ustawiona flagą ACK i w ten
          połączenie zostaje nawiązane.</li>
      </ol>
      <p>
        Zamykanie połączeń odbywa się podobny sposób. Jeśli nie ma więcej
        danych do przesłania, klient wysyła segment z ustawioną flaga FIN.
        Następnie serwer wysyła dwa segementy jeden z odpowiedzią na wysłaną
        flage FIN oraz drugi segment z ustawioną flagą FIN wysłaną do klienta.
        Kiedy klient odbierze taki segment, potwierdza za pomocą flagi ACK,
        jego odebranie i połącznie zostaje zakończone.
      </p>
      <p>
        Flagi kontrone wykorzystywane do zarządzania połączeniami TCP:
      </p>
      <ul>
        <li><strong>URG</strong> - Wskaźnik ważności pola <em>Urgent</em>.</li>
        <li><strong>ACK</strong> - Flaga potwierdzająca wykorzystywana
          normalnej komunikacji, ale również w przy nawiązywaniu i kończeniu
          połączeń.</li>
        <li><strong>PSH</strong> - funkcja push</li>
        <li><strong>RST</strong> - restartuje połączenie kiedy napotkano błąd
          lub minął czas oczekiwania.</li>
        <li><strong>SYN</strong> - Synchonizacja numerów sekwencyjnych,
          flaga wykorzystywana podczas nawiązywania połączenia.</li>
        <li><strong>FIN</strong> - Wysyłający nie ma więcej danych, używane
          do zamykania połączeń</li>
      </ul>
      <h2 id="1.14.6.tcpreliabilityandfc">1.14.6. Niezawodność i kontrola przepływu transmisji TCP</h2>
      <p>
        W przypadku transmisji sieciowej może dojść do zgubienia części danych
        (pakietu) z róznych przyczny, rownie istotna może być ścieżka jaką
        poruszają się pakiety do miejsca docelowego, pakiety z tego samego
        źródła wysłane inną ścieżką mogą dotrzeć do celu poźniej niż inne.
        Wówczas warstwa transportowa otrzymała dane nie pokolei. Podobnie jest
        w przypadku utracenia danych, ponieważ muszą one zostać
        retransmitowane. Jednak zawarty w nagłówkach numer sekwencji pozwoli
        mechnizmom zawartym w protokole TCP złożyć widomość, tak aby nie
        różniła się niczym od tej wysłanej przez nadawcę.
      </p>
      <p>
        Ciekawym mechnizmem może być <strong>SACK</strong>. Załóżmy taki
        przypadek, że mamy ustawione okno na odpowiedź po 10 segemencie, ale
        protokoł TCP uznał, że 3 i 4 segment są uszkodzone i wymagana jest ich
        retransmisja. To w normalnym przypadku nadawca dowiedział by się o tym
        fakcie dopiero po przesłaniu 10 segmentu. No dobrze troche by to
        opóźniło transmisje, ale mamy już nasz 3 i 4 segment, a to nie koniec
        ponieważ okno ustawione na 10 segment, to otrzymamy także segmenty od
        5 do 10. To jeśli uda się ustalić w SACK czyli
        <strong>odpowiedź selektywna</strong>. W momecie gdy nadawca dowiaduje,
        że potrzebna jest retransmisja w dodatkowym polu w segemencie
        potwierdzenia zwracany jest numer sekwencyjny segmentu, który wymaga
        retransmisji ale w dodatkowym polu SACK znajdują się te numery
        sekwencyjne, które odbiorca już ma i uznał je za poprawne.
      </p>
      <p>
        Kontrola przepływu polega na dostosowaniu ilości wysyłanych danych do
        możliwości odbiorcy. W przypadku protokołu TCP, kontrola przepływu
        pomoga utrzymać stabliność i niezawodność tego protokołu. W jedym z
        takich parametrów jest <strong>MSS</strong>, który określa wielkość
        danych niesionych w pakietach. Standardowo dla Etherenetu jest 1460B.
        Maksymalne MTU dla Ethernetu to 1500B, od tego musimy odjąć 20B dla 
        nagłówka IP oraz 20B dla nagłówka TCP. Wiec pozostaje 1460B na dane z
        warstwy aplikacji.
      </p>
      <p>
        Protokół TCP ma również dodatkowe mechanizmy dzięki, którym mocno
        obciażona stacja robocza, nie zostanie zalana segmentami w momencie
        kiedy nie jest wstanie odpowiedzieć, tym mechnizmem zarządza nadawca i
        nazywają sie <em>Congestion Avoidance</em> - unikanie zatorów.
      </p>
      <h2 id="1.14.7.udpcommunication">1.14.7. Komunikacja z wykorzystaniem protokołu UDP</h2> 
      <p>
        Protokół UDP nie zestawia połączenia. Ma on również mały narzut,
        ponieważ jego nagłówek jest mniejszy i nie zarządza on ruchem.
      </p>
      <p>
        UDP nie korzysta z numerów sekwencji tak jak robi to TCP, przez co nie
        możliwości uprządkowania pakietów w takiej samej kolejności w jakiej 
        zostały wysłane.
      </p>
      <p>
        Serwery korzystające z transmisji UDP wykorzystują dobrze znane lub
        zarejestrowane porty. Kiedy datagram UDP dotrze do komputera
        docelowego jest on przekazywany do aplikacji na podstawie przypisanego
        jej numery portu.
      </p>
      <p>
        Klienci transmisji UDP przypisują sobie porty dynamicznie, przeważnie
        z tej ostatniej grupy. Następnie ten port oraz port docelowy są
        używane w nagłówkach datagramów.
      </p>
      <h3 id="1.17.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/14.8.1-packet-tracer---tcp-and-udp-communications_pl-PL.pdf">Komunikacja z użyciem protokołów TCP i UDP - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/14.8.1-packet-tracer---tcp-and-udp-communications_pl-PL.pka">Komunikacja z użyciem protokołów TCP i UDP - zadanie</a>
      </p>
      <h2 id="ch15summary">Podsumowanie</h2>
      <p>
        W tym rodziale dowiedzieliśmy za co jest odpowiedzialna warstwa
        transportowa oraz jakie są jej funkcje. Poznaliśmy dwa protokoły
        tej warstwy - TCP oraz UDP, scharakteryzowaliśmy ich nagłówki.
        Następnie skupiliśmy się na opisaniu funkcjonalności protokołu TCP, na
        koniec krótko został przedstawiony protokół UDP.
      </p> 
      <h1 id="1.15.applicationlayer">1.15. Warstwa aplikacji</h1>
      <p>
        W warstwie aplikacji znajdują się elementy komunikacji sieciowej,
        z którymi użytkownik ma styczność podczas korzystania z zasobów
        Internetu. Na warstwę aplikacji składają się nie tylko aplikacje jakby
        sama nazwa miała wskazywać, ale także stojące za nimi protokoły, czy
        też metody prezentacji treści audio czy wideo, ale także utrzymanie
        połączenia między aplikacjami. W materiałach Cisco jak pamiętamy 
        posługujemy się siedmiowarstowym modelem ISO/OSI, tak więc tutaj
        warstwa aplikacji, jaką możemy znać z modelu TCP/IP jest przedstawiona
        w postaci trzech mniejszych warstw.
      </p>
      <h2 id="1.15.1.aplicationpresentationsession">1.15.1. Warstwy aplikacji, prezentacji i sesji</h2>
      <p>
        Warstwa aplikacji dostarcza interfejsu wykorzystywanego przez aplikacje
        do komunikacji oraz umożliwia korzystanie z sieci do przesyłania
        wiadomości między nimi.
      </p>
      <p>
        W tej warstwie rezydują znane wszystkim protokoły takie jak HTTP, DNS,
        FTP, IMAP, SMTP, ale także taki protokoł jak DHCP.
      </p>
      <p>
        Niższa wartswa prezentacji odpowiedzialna jest za formatowanie i
        prezentacje pozwalając dostosować dane źródłowe do postaci
        kompatybilnej z urządzeniem końcowym. Metody kompresji pozwalające
        na przyspieszenie ładowania zasosbu oraz ewentualną oszczędność miejsca
        jeśli taki zasób miał by zostać przechowany na naszych urządzeniach
        również rezydują w tej warstwie. Ostatnią cechą warstwy prezentacji
        jest zabzpieczenie transmisji przy użyciu metod szyfrowania, takich jak
        dobrze nam znany <strong>TLS</strong>.
      </p>
      <p>
        Warstwa sesji jest natomiast odpowiedzialna za utrzymaniem wirtualnego
        dialogu pomiędzy aplikacjiami, tzw. <strong>sesji</strong>. Warstwa ta
        zajmuje się umożliwieniem jej inicjalizacji celem wymiany informacji
        pomiędzy aplikacjami, jej utrzymaniem oraz ewentualnym restartem jeśl
        będą ku temu przesłanki.
      </p>
      <p>
        W warstwie aplikacji znajdują się protokoły określające standardy
        w wiekszości komunikacji sieciowej. Te protokoły muszą być stosowane
        przez obie strony i ich implementacje powinny być ze sobą kompatybilne,
        aby komunikacja mogła dość do skutku.
      </p>
      <h2 id="1.15.2.p2p">1.15.2. Komunikacja peer-to-peer</h2>
      <p>
        Obecny model komunikacji w Internecie opiera się o model
        <strong>klient-serwer</strong>, jego działanie opiera się na żądaniu
        przez klienta zasobów, które udostępnia serwer. Procesy zarówno
        klienta jak i serwera znajdują się w warstwie klienta. Format żądań
        i odpowiedzi klienta i serwera jest określany przez protokoły warstwy
        aplikacji.
      </p>
      <p>
        W modelu P2P dwoje lub więcej komputerów może współdzielić zasoby takie
        jak pliki czy drukarki bez dedykowanego serwera. W tym modelu każdy
        jest serwerem oraz klientem, dla jednego połączenia dany host może być
        serwerem a w miedzy czasie przy użyciu innego połączenia pobierać plik
        z innego hosta. Popularnymi programami działającymi w trybie 
        <em>peer-to-peer</em> jest klienci sieci BitTorrent, czy usługa Freenet.
      </p>
      <h2 id="1.15.3.webandemail">1.15.3. Protokół HTTP oraz protokoły pocztowe.</h2>
      <p>
        Wpisująć w pasek adresu przeglądarki adres URL żądanej strony,
        przeglądarka nawiąże połączenie z serwerem WWW stojącym za żądaną
        stroną i pobierze ją. Połączenia między przeglądarką a serwerem strony
        zostaną zrealizowane za pomocą protokołu HTTP lub jego szyfrowanej
        wersji jaką jest HTTPS. Jak pamiętamy protokoły określają sposób
        komunikacji. W przypadku protokołu HTTP, jest on dosyć prosty więc
        warto sobie go opisać. 
      </p>
      <ol>
        <li>Po wpisaniu adresu do przeglądarki np. 
          <em>https://www.cisco.com/index.html</em> zostanie on zinterpretowany
          i podzielony na konkretne sekcje określające: protokoł
          (<em>https</em>), nazwę hosta, który udostępnia tą witrynę
          (<em>www.cisco.com</em>) oraz żądany pliki (<em>index.html</em>).
        </li>
        <li>Na drugim etapie przeglądarka wysła do hosta żądanie wskazanego w 
          adresie pliku.  Wcześniej określając adres IP poprzez wykorzystanie
          protokołu DNS.
          Tego typu żądanie określa się mianem żądania <strong>GET</strong>. 
          W ten sposób sesja protokołu HTTP zostaje rozpoczęta.
        </li>
        <li>W odpowiedzi serwer wysła żądaną stronę. W tym momencie możemy
          uznać sesję HTTP uznać za zakończoną.</li>
        <li>Przeglądarką interpretuje otrzymaną stronę i wyświetla wynik
          użytkownikowi.</li>
      </ol>
      <p>
        W drugim kroku wspomniano, że żądanie strony można określić jako
        <em>GET</em>, <em>GET</em> jest jednym z faktycznych komunikatów
        protokołu HTTP. Jest on używany w momencie gdy klient chce pobrać zasób
        z serwera, wówczas taki zasób jest mu udostępniany po przez wysłanie
        go do klienta. Po za klasycznym <em>GET</em>-em mamy do dyspozycji
        komunikat typu <strong>POST</strong>, jego zadaniem jest wysłanie
        osobnych danych na serwer lub do aplikacji, na przykład za pomocą
        formularza na stronie. Innym rodzajem komuniktów jest 
        <strong>PUT</strong>, które zadaniem jest przysłanie plików na serwer
        WWW.
      </p>
      <p>
        Obecnie poza sieciami lokalnymi, nie spotkamy transmisji z użyciem
        protokołu HTTP, ale przy użyciu protkołu HTTPS - bezpieczniejszej
        wersji. Oczywiście mogą zdarzyć się wyjątki, gdzie takie strony jak
        np. ta, kompletnie nie potrzebują HTTPS
      </p>
      <p>
        Nieco innym rodzajem transmisji jest korzystanie z poczty
        elektronicznej. W dużym skrócie, przy poczcie elektronicznej
        wykorzystywane są trzy protokoły, jeden dla wysyłania oraz dwa do
        odbierania poczty. Obecnie nikt nie korzysta z gołych protokółów,
        choć w przypadku poczty jest jak najbardziej możliwe, to na co dzień
        wykorzystuje się programy pocztowe, będące klientami a ich zadaniem
        jest ułatwienie użytkownikowi korzystanie z poczty elektronicznej.
        Uruchamiając taki program, to jeśli posiadamy konfigurację konta
        pocztowego, to z serwera zostanie pobrana poczta ponieważ program
        połączy się albo z <strong>IMAP</strong>-em po porcie TCP/993
        dla transmisji szyfrowanej lub po porcie TCP/143 dla transmisji
        nieszyfrowanej lub też z protokołem <strong>POP3</strong> po porcie
        TCP/995 dla transmisji szyfrowanej oraz TCP/110 dla transmisji
        nieszyfrowanej. Rożnica w tych protokołach polega na tym, że
        protokół POP3 pobiera zawartość naszej skrzynki na serwerze, bez
        pozostawienia jej kopii na nim (chociaż w ustawieniach mozna wymuść,
        aby kopia pozostała na serwerze), z kolei działanie protokołu IMAP
        opiera się na synchronizacji, do klienta trafia ją szczątkowe
        informacje o poczcie na serwerze, w momencie gdy użytkownik kliknie w
        wiadomość zostanie ona pobrana z serwera i wyświetlona.
      </p>
      <p>
        Inaczej jest w przypadku gdy chcemy wysłać wiadomość. W momencie gdy 
        użytkownik
        zdecyduje się na kliknięcie przycisku wyśli zostanie on połączony z
        z serwerem <strong>SMTP</strong> TCP/465 dla transmisji szyfrowanej
        oraz TCP/25 dla transmisji nieszyfrowanej, wskazanym w konfiguracji
        konta. Wiadomość zostanie przekazana do serwera wraz ze wszystkimi
        danymi takimi jak odbiorca czy temat. Na podstawie odbiorcy nasz
        serwer SMTP prześle wiadomość do <strong>odpowiedniego dla odbiorcy
        serwera SMTP</strong>, z tam tąd odbiorca pobierze ją za pomocą jednego
        z wyżej opisanych protokołów.
      </p>
      <h2 id="1.15.4.ipaddressingservices">1.15.4. Usługi adresacji IP</h2>
      <p>
        W obecnych czasach ciężko było by się poruszać po Internecie, przy
        użyciu adresów IP. Dlatego też wynaleziono specjalny rodzaj usługi,
        jaką jest <strong>DNS</strong>. Zadaniem tego protokołu jest
        rozwiązywanie nazw domenowych na adresy IP, DNS wykorzystuje tutaj
        transmisję UDP po porcie 53. Serwery DNS przechowują dane w postaci
        rekordów, rekordy te mają określony typ. Tak więc, rekordy typu:
      </p>
      <ul>
        <li><strong>A</strong> - adres IPv4</li>
        <li><strong>NS</strong> - adres IP serwera autorytatywnego
          (serwera obsługjącego tą domenę) dla domeny</li>
        <li><strong>AAAA</strong> - adres IPv6</li>
        <li><strong>MX</strong> - rekord wskazujący na serwer pocztowy.</li>
      </ul>
      <p>
        System DNS używa tych samych formatów wiadomości między serwerami
        (uwaga, serwery DNS wymieniają informacje wykorzystując transmisję TCP
        na porcie 53, a UDP jak w przypadku wymiany informacji z klientami).
        Ten format zawiera takie informacje jak kolejno:
      </p>
      <ol>
        <li><strong>Zapytanie</strong> - zapytanie do serwera DNS</li>
        <li><strong>Odpowiedź</strong> - opowiedź od serwera DNS</li>
        <li><strong>Autorytatywność</strong> - wskazanie serwera 
          autorytatywnego dla zapytania.</li>
        <li><strong>Dodatkowe</strong> - przechowuje dodatkowe informacje</li>
      </ol>
      <p>
        Klient szukając adresu IP dla nazwy domenowej hosta na początku odpyta
        serwer DNS, który ma ustawiony w swoim systemie. Jeśli nie będzie on
        posiadać odpowiedzi, to wówczas rozpocznie się odpytywanie
        hierarchiczne.
      </p>
      <p>
        Otóż system DNS ma budowę hierarchiczną i cała hierarchia jest zapisana
        w adresie URL strony. Za przykład weźmy naszą wcześniejszą witrynę jaką
        jest <em>www.cisco.com</em>. Jeśli odczytamy ją od prawej do lewej,
        wówczas będziemy mieć rozeznanie w hierarchi DNS. W tym przypadku
        najważniejszą domeną jest <em>.com</em> i serwer tej domeny zawiera
        adres serwera DNS dla subdomeny <em>cisco</em>, a ten z kolei zawiera
        adres hosta <em>www</em>. Tak własnie wygląda rozwiązywanie nazw, gdy
        nasz najbliżej położony DNS, nie posiada odpowiedzi na zadane mu
        pytanie. Warto dodać, że serwery trzymają taką odpowiedź
        (nieautorytatywną, hosta z innej domeny) w pamięci podręcznej, wrazie
        gdyby inny z hostów w sieci pytał o tego hosta.
      </p>
      <p>
        Pomocnym narzędziem, które pozwoli nam odpytać system DNS jest
        polecenie <strong>nslookup</strong>. Polecenie to pozwala na
        <strong>odpytanie serwera DNS z pominięciem pamięci podręcznej
        urządzenia</strong>. Dostępne jest ono w każdym system operacyjnym.
      </p>
      <p>
        Kolejnym przykładem protokołu, który pracuje wraz z adresacją IP jest
        <strong>DHCP</strong>. Jego zadaniem jest automatyczna konfiguracja
        interfejsów sieciowych hostów. Przypisanie im adresów IP oraz
        pozostałych parametrów pozwalających na komunikację w sieci.
        Konfiguracja hosta wykonana przez serwer DHCP uznawana jest za
        dynamiczną z racji tego, że może się zmienić, po określonym czasie.
        W sieci z włączonym DHCP uzyskamy
        <strong>dzierżawę</strong> (adresy IP z serwera DHCP uzyskuje się na
        konkretny, zapisany w konfiguracji serwera czas) adres IP z
        <strong>puli</strong>
        (zakresu adresów, przydzielonych do tego zadania). W wielu sieciach
        stosuje się mieszane podejście do konfiguracji adresów IP, niektóre
        urządzenia takie jak serwery czy urządzenia pośredniczące w
        komunikacji sieciowej, np. przełączniki posiadają statycznie (ręcznie)
        skonfigurowane adresy IP. Można równiez statycznie skonfigurować adresy
        urządzeń wykorzystując DHCP (rezerwacje adresów).
      </p>
      <p>
        W przypadku adresów IPv6, również może działać serwer DHCP. Z tą
        różnicą, że nie konfiguruje on adresu bramy domyślnej, ten parametr
        jest pobierany z komunikatów <em>Router Advertisement</em>
        rozgłaszanych przez router.
      </p>
      <p>
        Wymiana komunikatów między nowymi hostami w sieci serwerem DHCP wygląda
        następująco: 
      </p>
      <ul>
        <li>Kiedy host z ustawioną automatyczną konfiguracją chce skonfigurować
          swój interfejs wysyła pakiet <em>broadcast</em> na port 67 
          zawierający komunikat <em>DHCPDISCOVER</em></li>
        <li>Serwer DHCP odpowiada na oferując dzierżawę klientowi, komunikat
          <em>DHCPOFFER</em>.</li>
        <li>Klient akceptuje ofertę serwera wysyłając do serwera żądanie
          <em>DHCPREQUEST</em></li>
        <li>Jeśli oferta serwera jest jeszcze aktualna serwer odsyła
          <em>DHCPACK</em>, wówczas cały proces można uznać za zakończony.</li>
        <li>Jeśli natomiast oferta dzierżawy nie jest juz aktualna serwer
          wysyła do klienta komunikat <em>DHCPNACK</em>, w tym przypadku
          cała procedurę należy powtórzy i ponownie rozpocząć od poszukiwania
          serwera DHCP.</li>
      </ul>
      <p>
        Dla IPv6 proces wygląd podobnie, różnicą są nazwy komunikatów. W DHCPv6
        mamy <em>SOLICIT</em>, <em>ADVERTISE</em>, <em>INFORMATION REQUEST</em>
        oraz <em>REPLY</em>.
      </p>
      <h3 id=="1.15.4.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/15.4.8-lab---observe-dns-resolution_pl-PL.pdf">Obserwacja procesu odwzorowania nazw DNS</a>
      </p>
      <h2 id="1.15.5.filesharing">1.15.5. Usługi współdzielenia plików</h2>
      <p>
        Jednym z protokołów, które możemy wykorzystać do współdzielenia plików
        jest protokół FTP. FTP jako jedna z nielicznych usług posiada dwa
        porty TCP/21 oraz TCP/20. Pierwszy z nich służy do nawiązania
        nawiązania połączenia z serwerem i przesyłania do niego poleceń
        protokoł FTP. Jeśli zdecydujemy się na wysłanie lub pobranie danych z
        serwera, wówczas pomiędzy naszymi komputerami zostanie otwarte nowe
        połączenie na portcie TCP/20. Warto pamiętać o tym, że w przypadku
        protokołu FTP możliwe jest przesyłanie danych w obu kierunkach. Klient
        może pobierać dane lub ładowanie je na serwer.
      </p>
      <p>
        Innym protokołem jaki możemy wykorzystać udostępniania plików jest
        protokół SMB (<em>Server Message Block</em>), działanie tego protokołu
        opiera się na żądaniach i odpowiedziach. Trzema głównymi funkcjami
        komunikatów SMB jest:
      </p>
      <ul>
        <li>Rozpoczenie oraz zerwanie sesji i autentykacja</li>
        <li>Kontrola plików i drukarek</li>
        <li>Pozwolenie na wysyłanie komunikatów do innych urządzeń (sic)</li>
      </ul>
      <p>
        W przeciwieństwie do protokołu FTP połączenie SMB jest długoterminowe,
        a użytkownicy mogą korzystać z zasobów udostępnianych przez SMB, jakby
        były ich lokalnymi zasobami.
      </p>
      <h2 id="ch15summary">Podsumowanie</h2>
      <p>
        Ten rozdział związany był z warstwą aplikacji. Poznaliśmy definicje
        oraz funkcje warstw prezentacji oraz sesji modelu OSI. Dowiedzieliśmy
        się w jaki sposób funkcjonują najważniejsze protokoły wykorzystywane
        zarówno w sieciach lokalnych jak i w internecie.
      </p>
      <h1 id="1.16.networksecurityfundamentals">1.16. Wprowadzenie do bezpieczeństwa sięci</h1>
      <p>
        Jak możemy sobie zdawać sprawę lub też nie zadaniem sieci w ujęciu
        teleinformatycznym jest umożliwienie komunikacji między jednym a drugim
        węzłem tej sieci. A jak wszystko na świecie, każdy kij ma dwa końce,
        przez co posiadanie możliwości komunikacji, może mieć negatyny wpływ
        na nasze urządzenia, poufne dane a co za tym idzie na nas samych.
        Oczywiście możemy kontragrumentować tę tezę przedstawiając przypadek
        połączeń między zaufanymi węzłami, jednak i one mogą w wyniku
        zaniedbań, ludzkiej omylności lub też celowego działania mogą zostać
        wykorzystane przeciwko nam, nasze zaufanie tylko ułatwi to zadanie.
        W tym rozdziale spróbujemy zapoznać się z rodzajami zagrożeń z jakimi
        możemy się spotkać.
      </p>
      <h2 id="1.16.1.threatsandvulns">1.16.1. Zagrożenia i podatności.</h2>
      <p>
        Zagrozenia mogą wynikać z wielu aspektów. Atakujący mogą wykorzystywać
        podatności w oprogramowaniu czy sprzęcie, jednak nie
        wszystkie ich działania są tak wyrafinowane. Często udaję się odgadnąć
        czyjeś dane logwania. Osoby wykorzystujące luki w oprogramowaniu lub
        w jaki kolwiek sposób będące w stanie zmodyfikować oprogramowanie aby
        uzyskać dostęp do systemu są nazwywane w nomenklaturze Cisco 
        <strong>podmiotem zagrożenia</strong>.
      </p>
      <p>
        Można natomiast określić cztery rodzaje zagrożeń na jakie mogą być
        narażeni użytkownicy sieci w momencie, gdy podmiot zagrożenia uzyska
        do niej dostęp:
      </p>
      <ul>
        <li>Kradzież informacji</li>
        <li>Utrada danych, bądź ich zmiana</li>
        <li>Kradzież tożsamości</li>
        <li>Przerwanie dostępu do usług</li>
      </ul>
      <p>
        <strong>Podatnością</strong> możemy nazwać słaby punkt czy to w
        urządzeniu czy też w oprogramowaniu. Podaności na uzyskanie
        nieautoryzowanego dostępu może posiadać każde urządzeń, które
        podłączamy do sieci. Podaności można uprządkować bazując na genezie jej
        powstania (pominiemy podatności związane, z błędami lub 
        niedociągnięciami programistycznymi, chociaż pierwsze dwa rodzaje w
        niższych wartstwach też je obejmują):
      </p>
      <ul>
        <li><strong>podatność technologiczna</strong> - wynika ze słabości
          samych protokół sieciowych, systemów operacyjnych czy oprogramowania
          (firmware-u) urządzeń sieciowych.</li>
        <li><strong>podatność konfiguracyjna</strong> - wynika z zaniedbań
          podczas wdrażania urządzeń sieciowych lub usług. Opiera się na
          przykład na domyślnych konfiguracjach, nie zmienionych domyślnych
          hasłach dostępu (w przypadku urządzeń sieciowych), ale także na złym
          zarządaniu użytkownikami.</li>
        <li><strong>podaności polityki bezpieczeństwa</strong> - wynikające
          z braku lub niejednoznacności zasad bezpieczeństwa przyjętych 
          w organizacji. Mogą również wynikać z lokalnego prawa, czy też braku
          jasno określonych działań podczas awarii.<li>
      </ul>
      <p>
        Inna bardzo często pomijaną kwestią związaną z bezpieczeństwem sieci,
        jest <strong>bezpieczeństwo fizyczne</strong> zarówno serwerownii 
        jak i pomieszczeń
        biurowych, w których może być przeprowadzany krytyczny dla organizacji
        proces technologiczny lub przetważane są istotne dane. Nie mniej
        jednak tutaj raczej skupimy się na tzw. czynnikach środowiskowych
      </p>
      <p>
        Możemy określić cztery klasy zagrożeń fizycznych, które np. mogą
        prowadzić do zagrożenia przerwania dostępności usług.
      </p>
      <ul>
        <li><strong>zagrożenia sprzętowe</strong> - uszkodzenia serwerów i
          sprzętu sieciowego.</li>
        <li><strong>zagrożenia środowiskowe</strong> - praca urządzeń poza
          zakresem ich temperatur oraz w pomieszczeniach o niewłaściwej
          wilgotności powietrza.</li>
        <li><strong>zagrożenia elektryczne</strong> - zniki zasilania lub
          niewłaściwe parametry fizczne energii elektrycznej, którą są zasilane
          urządzenia.</li>
        <li><strong>zagrożenia konserwacyjne</strong> - brak cześci zamiennych,
          nieumiejętnie przezprowadzone prace serwisowe, złej jakości
          okablowanie oraz niejednoznacze opisy w szafach krosowniczych oraz
          w punktach dystrybucyjnych.</li>
      </ul>
      <h2 id="1.16.2.networkattacks">1.16.2. Ataki sieciowe</h2>
      <p>
        Najczęściej zadaniem <strong>ataku sieciowego</strong> jest uzyskanie
        nieautoryzowanego dostepu do określonego i chronionego zasobu. Można
        wróżnić kilka podstawowych rodzajów ataków sieciowych, które mogą
        wpasowywać się w zagrożenia opisane na początku tego rozdziału.
      </p>
      <ul>
        <li><strong>złośliwe oprogramowanie</strong> - oprogramowanie lub
          fragment kodu, którego celem jest wykonanie dowolnej niepożądanej
          przez nas czynności na komputerze. Wśród nich możemy wyróżnić:
          <ul>
            <li><strong>wirusy</strong> - złośliwy samodzielny program lub
              fragment innego programu. Na skutek nie uwagi użytkownika może
              infekować wiele komputerów, do infekcji wirusem potrzebne jest
              działanie użytkownika, np. uruchomienie zainfekowanego programu.
            </li>
            <li><strong>robaki</strong> - rodzaj wirusa, który nie wymaga
              działania użytkownika do infekcji. Robaki często wykorzystują
              znane podatności w systemach operacyjnych, usługach lub innych
              programach i replikują się na skompromitowanych hostach.</li>
            <li><strong>konie trojańskie</strong> - złośliwe oprogramowanie
              podszywające się pod przydatne programy.</li>
          </ul>
        </li>
        <li><strong>rozpoznanie</strong> - samo w sobie rozpoznanie nie jest
          atakiem, a jego fazą przygotowawczą, chociaż i w tej fazie można
          użyć narzędzi, który przy wysokim poziomie bezpieczeństwa w
          organizacji mogą wywołąć alarm. Do rozpoznania można również
          wykorzystać dane publicznie dostępne w Internecie. Takie jak np.
          adresację IP sieci publicznej wykorzystywanej w organizacji.</li>
        <li><strong>ataki dostępowe</strong> - ataki dostępowe polegają już
          głównie na eksploatacji podatności, ale jak również takie czynności
          jak odgadywanie czy łamanie haseł oraz próba przechwycenia danych
          logowania. Możemy wyróżnić cztery typy takich ataków:
          <ul>
            <li><strong>ataki na hasła</strong> - mogą obejmować odgadywanie,
              łamanie ale jak i również przechwytywanie ciągów znaków w jakich
              zaszyfrowane są hasła (tzw. hash hasła), które poźniej mogą
              zostać złamane.</li>
            <li><strong>Wykorzystanie zaufania</strong> - podmiot zagrożenia
              może wykorzystywać nieautoryzowane uprawnienia w celu zwiększenia
              dostępu do systemu, możliwe przejmując kontrolę nad celem.(sic)
            </li>
            <li><strong>Przekierowanie portów</strong> - podmiot zagrożenia
              wykorzystuje przejęty host A, łącząc się z nim przez SSH
              (port TCP/22), następnie ze względu na to, że host a jest
              uprawniony do połączenia z hostem B przez Telnet (port TCP/23)
              napastnik to wykorzystuje (sic).</li>
            <li><strong>atak Man-in-the-middle</strong> - napastnik znajduje
              gdzieś miedzy na drodze między jednym wezłem a drugim. Zbiera on
              dane wymieniane między tymi hostami, może również je zmieniać
              lub wpływać na ruch między nimi.</li>
          </ul>
        </li>
        <li><strong>ataki odmowy usługi</strong> - atak ten polega nawiązaniu
          tak dużej ilości połączeń z daną aplikacją na serwerze, że ten nie
          będzie w stanie obsłużyć kolejnych, przez co usługa staje się
          niedostępna dla innych osób. Ataki DoS są wyjątkowo łatwe w
          implementacji więc mogą być stosowane przez mniej doświadczone
          osoby. Odmianą ataków odmowy usługi (DoS) są <strong>ataki DDoS</strong>,
          które różnią się rozproszeniem podmiotu zagrożenia na wiele hostów.
          Do ataków DDoS wykorzystuję się sieci przyjętych lub zainfekowanych
          złośliwym oprogramowaniem hostów tzw. <strong>botnet</strong>. Do
          kontroli takiej sieci wykorzystuje się inne przejęte hosty
          tzw. <strong>Command&Control</strong> przez co napastnik może
          pozostać nieuchwytny.</li>
      </ul>
      <h3 id="1.16.2.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/16.2.6-lab---research-network-security-threats_pl-PL.pdf">Badanie zagrożeń bezpieczeństwa sieci</a>
      </p> 
      <h2 id="1.16.3.networksecuring">1.16.3. Zabezpieczanie sieci</h2>
      <p>
        Aby zabezpieczyć się przez opisanymi w tym rozdziale atakami należy
        wdrożyć odpowiednie rozwiązania. Przed zakupem nie wiadomo jak
        drogiego komercyjnego systemu warto na początku zadbać o
        zabezpieczenie takich urządzeń jak serwery, routery, switche oraz
        urządzenia użytkowników końcowych. Po zabezpieczeniu tych urządzeń
        można wówczas pomyśleć o wdrożeniu systemów IPS/IDS,
        systemów AAA (sic) czy filtrów treści. Warto dodać, aby przy wyborze
        rozwiązań jednym z kluczowych składników było to aby jedne rozwiązania
        mogły współpracować z pozostałymi elementami systemu bezpieczeństwa,
        ale
        także rozwiązanimi już obecnie działającymi w naszej sieci.
      </p>
      <p>
        Jedną z tych podstawowych czynności, jakie możemy podjąć czyniąc naszą
        infrastrukturę teleinformatyczną bardziej bezpieczną jest zapewnienie
        kopii zapasowej istotnych dla organizacji danych. Podczas rozważań
        na temat kopii zapasowej należy wziąć pod uwagę cztery poniższe
        zagadnienia: 
      </p>
      <ul>
        <li><strong>Częstotliwość</strong> - Kopie zapasowe należy wykonywać w
              regularnych odstępach czasu
              najlepiej codziennie. Częstotliwość kopii zapasowych powinna być
              ujęta w polityce bezpieczeństwa.
              Wykonywanie pełnych kopii może być czasochonne więc warto
              wydzielić czas (powiedzmy raz w tygodniu) na wykonanie takiej
              kopii, w pozostałe dni można robić kopie tylko tych plików,
              które były ostatnio modyfikowane.</li>
        <li><strong>Przechowywanie kopii</strong> - jeśli organizacja obejmuje
          kilka budynków to warto trzymać te kopie poza budynkiem, w którym
          te dane są przetwarzane. Możemy tutaj posłużyć się zasadą 3-2-1 - 
          minimum 3 kopie, w 2 różnych miejscach, a 1 poza główną siedzibą.
          Jeśli organizacja jest na tyle duża, to może wynająć przestrzeń
          dyskową w lokalnym centrum danych.</li>
        <li><strong>Bezpieczeństwo kopii</strong> - Każda kopia powinna być
          chroniona hasłem. Tak samo jak procedura jej przywrócenia.</li>
        <li><strong>Integralność kopii</strong> - Należy dbać o poprawność
          i integralność kopii zapasowej. Raz na jakiś czas należy jedną
          losową kopię przywrócić w środowisku testowym.</li>
      </ul>
      <p>
        Jedną z najprostszych rzeczy jakie możemy wykonać na urządzeniach
        użytkowników jest sprawdzenie poprawności konfiguracji automatycznych
        aktulizacji. I jeśli brakuje poprawek w systemach to należy je
        niezwłocznie zainstalować. To samo tyczy się programów antywirusowych,
        program ten może aktualizować swoje bazy kilka razy w ciągu dnia.
        Dystrybucje Linuksa posiadają takie rozwiązania jak
        <em>unattended-upgrades</em>, które instalują automatycznie pakiety
        z takich gałezi repozytoriów jak <em>security</em>.
      </p>
      <p>
        Istotne podczas zabepieczenia sieci jest również kontrola użytkownika
        który ma z niej korzystać i nie musi się to tyczyć wyłącznie komputerów
        ale jeśli jest taka możliwość to i urządzeń sieciowych i taką usługą
        może być <strong>serwer AAA</strong>. Najprostszą a zarazem jedną z 
        lepszych jest
        protokół LDAP, zarówno jak i w wolnej implementacji Samba AD czy
        własnościowej MS Windows Active Directory. 
      </p>
      <p>
        Urządzenie, które powinno znaleźć się w każdej sieci to 
        <strong>zapora</strong>. Jej zadaniem jest monitorowanie i zarządzanie
        ruchem na podstawie zdefiniowanych przez administratora reguł. Zapory
        mogą tworzyć specjalny rodzaj sieci tzw. 
        <strong>strefę zdemilitaryzowaną - DMZ</strong>. W tej sieci
        umiesczane są serwery usług, które mają być osiągalne z poziomu sieci
        Internet. DMZ-ty najczęsciej konfigurowane są w taki sposób, że
        użytkownicy sieci lokalnych w organizacji mogą się łączyć bezproblemu
        z tymi serwerami, jednak te same serwery nie są w stanie inicjować
        połączeń z hostami w sieciach lokalnych. Kiedy jeden z tych serwerów
        zostanie przejęty przez napastnika, zostanie on ograniczony tylko do
        DMZ (oczywiście, nie należy takiego włamania lekceważyć) i nie będzie
        w stanie narobić wiecej szkód w innych sieciach. Same zapory
        najczęsciej są skonfigurowane tak aby blokować cały ruch pochodzący
        z Internetu, chyba, że przekierowano porty. Wówczas ruch na tych
        wybranych portach jest możliwy. Dostępnych jest kilka różnych metod
        filtrowania ruchu przez zapory o to cztery z nich
      </p>
      <ul>
        <li><strong>Filtrowanie pakietów</strong> - filtowanie pakietów na
          podstawie adresów IP czy adresów MAC.</li>
        <li><strong>Filtrowanie aplikacji</strong> - filtrowanie pakietów na
          podstawie numerów protów.</li>
        <li><strong>Filtrowanie treści</strong> - filtrowanie całych domen oraz
          pojedynczych stron na podstawie ogólnodostępnych list w internetcie.
        </li>
        <li><strong>Inspekcja stanów pakietów (SPI)</strong> - metoda
          filtrowania pakietów, która pozwala odfiltrować pakiety TCP z
          ustawionymi odpowiednimi flagami, przez co możliwa jest tylko
          przepuszczenie odpowiedzi z Internetu na połączenia, których źródłem
          są hosty wewnętrzne. SPI ma możliwość wykrywania i blokowania
          róznych ataków w tym ataków DoS.</li>
      </ul> 
      <h2 id="1.16.4.devicescurity">1.16.4. Bezpieczeństwo urządzeń</h2>
      <p>
        Poza serwera i urządzeniam użytkowników końcowych, do zabezpieczenia
        pozostały nam jeszcze urządzenia sieciowe takie jak routery czy
        switche. 
      </p>
      <p>
        W przypadku routerów Cisco mamy dyspozycji narzędzie
        <em>Cisco AutoSecure</em>, które pomoże nam przeprowadzić proces
        zabezpieczania urządzenia. Mimo to czynności podejmowane w celu
        zabezpieczenia urządzenia sieciowego nie za bardzo różnią się od
        procesu zabepieczania np. serwera, zaraz po zainstalowaniu na nim
        systemu operacyjnego.
      </p>
      <p>
        Oczywiście na tym poziomie do uzyskania dostępu do urządzenia
        sieciowego będziemy wykorzystywać hasła. Warto zatem mieć na uwadzę
        kilka reguł dotyczących tworzenia bezpiecznych haseł:
      </p>
      <ul>
        <li>Dobre hasło powinno mieć co najmniej 8 znaków, ale lepsze hasła
            zawierają 10 i więcej.</li>
        <li>Hasło powinno być dość złożone, tzn. składać losowych małych,
            wielkich liter, cyfr, znaków specjalnych a jeszcze lepiej jakby
            zawierało spację.</li>
        <li>Najlepiej jakby hasło nie zawiera żadnych informacji, które można
            znaleźć na nasz temat np. daty urodzenia czy imienia naszego
            zwierzaka. Najlepiej omijać także powtórzenia lub często
            stosowane słowa.</li>
        <li>Jeśli korzystamy z całych słów, to warto je urozmaicić wprowadzając
            błędy, podobnie brzmiące litery lub zamias konkretnych liter
            przypominające je cyfry.</li>
        <li>Hasła należy zmieniać co jakiś czas, np. co 6 miesięcy.</li>
        <li>Nie należy nigdzie zapisywać haseł.</li>
      </ul>
      <p>
        Jeśli chcemy stosować spację na urządzenia Cisco, to musimy podać ją
        jako drugi lub kolejny znak. IOS ignoruje początkowe spacje.
      </p>
      <p>
        Teraz znając zasady dotyczące haseł możemy wygenerować hasła i
        następnie ustawić je na naszych urządzeniach do dając przy tym kilka
        dodatkowych ustawień zapisanych poniżej (pierwsze trzy opcje,
        ustawiamy w trybie konfiguracji globalnej):
      </p>
      <ul>
        <li>Szyfrowanie haseł:
          <code class="code-inline">service password-encryption</code>
        </li>
        <li>Minimalna długość hasła:
          <code class="code-inline">security passwords min-length 10</code>
        </li>
        <li>Blokada na N sekund po X prób logowania w ciągu Y sekund:
          <code class="code-inline">login block-for N attempts X within Y</code>
        </li>
        <li>Automatyczne wyjście z trybu privileged EXEC po określonym czasie:
          (uwaga, tę opcję zmieniamy w konfiguracji linii)
          <code class="code-inline">exec-timeout min. sek.</code>
        </li>
      </ul>
      <p>
        Teraz wiedząc jak bezpiczenie ustawić dostęp oparty o hasło do
        urządzeń sieciowych Cisco. Możemy uruchomić bezpiecznych dostęp
        przez SSH. Poniżej polecenie, które trzeba wykonać
        (cztery pierwsze opcje są wykonywane w trybie konfiguracji globalnej):
      </p>
      <ul>
        <li>Ustawienie unikalnej nazwy hosta:
          <code class="code-inline">hostname r1</code>
        </li>
        <li>Ustawienie nazwy domenowej:
          <code class="code-inline">ip domain name example.com</code>
        </li>
        <li>Wygenerowanie kluczy RSA dla SSH o długości X bitów:
          <code class="code-inline">crypto key generate rsa general-keys modulus X</code>
        </li>
        <li>Utworzenie użytkownika w lokalnej bazie użytkowników urządzenia:
          <code class="code-inline">username xf0r3m secret 5up3r74jn3Has|_0</code>
        </li>
        <li>Włączenie uwierzytelniania przy użyciu lokalnej bazy:
          (uwaga, tę opcję wprowadzamy w trybie konfiguracji linii vty)
          <code class="code-inline">login local</code>
        </li>
        <li>Włączenie SSH dla zdalnych połączeń:
          (uwaga, tę opcję wprowadzamy w trybie konfiguracji linii vty)
          <code class="code-inline">transport input ssh</code>
        </li>
      </ul>
      <p>
        Po zapewnieniu prawidłowego dostępu zdalnego możemy wykonać ostatnią
        czynność jaką jest wyłączenie zbędnych usług. Tutaj istotna może być
        wersja IOS, jaką posiadamy na swoich urządzeniach. W starszych
        urządzeniach (z przed IOS-XE) możemy podejrzeć listę otwartych portów
        za pomocą polecenia:<br />
        <code class="code-inline">show control-plane host open-ports</code>.
        Natomiast w nowszych wersjach (od IOS-XE) używa się nieco krótszego
        polecenia:<br />
        <code class="code-inline">show ip ports all</code>
        Te polecenia wydajemy w trybie uprzywilejowanym EXEC bez konfiguracji.
        Chcąc wyłączyć usługę powiedzmy http, musimy przejść do trybu
        konfiguracji globalnej i następnie wydać polecenie:<br />
        <code class="code-inline">no ip http server</code>
      </p>
      <h3 id="1.16.4.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.4.6-packet-tracer---configure-secure-passwords-and-ssh_pl-PL.pdf">Konfiguracja bezpiecznych haseł i SSH - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.4.6-packet-tracer---configure-secure-passwords-and-ssh_pl-PL.pka">Konfiguracja bezpiecznych haseł i SSH - zadanie</a>
      </p>
      <h3 id="1.16.4.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/16.4.7-lab---configure-network-devices-with-ssh_pl-PL.pdf">Konfiguracja urządzeń sieciowych za pomocą SSH</a>
      </p>
      <h2 id="ch16summary">Podsumowanie</h2>
      <p>
        W tym module zapoznaliśmy się z podstawami sieci. Poznaliśmy zagrożenia
        oraz genezę wielu podatności. Dowiedzieliśmy się jakie są podstawowe
        ataki oraz jak niewiele potrzeba, aby utrudnić atakującym dostęp do
        naszych urządzeń. Na koniec podnieślismy poziom bezpieczeństwa haseł
        na naszych urządzeniach Cisco oraz w bezpieczny sposób uruchomiliśmy
        usługę SSH. Poniżej znajdują się ćwiczenia praktyczne do wykonania w
        programie Cisco Packet Tracer oraz bardziej zaawansowane zadanie w
        postaci laboratorium. 
      </p>
      <h3 id="1.16.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.5.1-packet-tracer---secure-network-devices_pl-PL.pdf">Zabezpieczanie urządzeń sieciowych - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/16.5.1-packet-tracer---secure-network-devices_pl-PL.pka">Zabezpieczanie urządzeń sieciowych - zadanie</a>
      </p>
      <h3 id="1.16.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/16.5.2-lab---secure-network-devices_pl-PL.pdf">Zabezpieczenie urządzeń sieciowych</a>
      </p>
      <h1 id="1.17.buildingasmallnetwork">1.17. Budowanie małej sieci</h1>
      <p>
        Ostatni rozdział pierwszego modułu kursu, ma skłonić nas do refleksji
        na temat: Co gdyby trzeba było zbudować taką małą sieć? Oczywiście
        pierwsze pytanie jak się nasuwa: <em>co to znaczy mała?</em> czasmi
        może okazać się, że do budowy takiej sieci wystarczy router klasy SOHO
        i dostęp do ISP. A czasami do małej sieci może zaliczać się nawet
        kilka segmentów. 
      </p>
      <h2 id="1.17.1.desingasmallnetwork">1.17.1. Projektowanie małej sieci</h2>
      <p>
        W tym podrozdziale zastanowimy się nad kilkoma aspektami, które trzeba
        rozważyć podczas projektowania małej sieci.
      </p>
      <p>
        Pierwszym z nich jest <strong>topologia</strong>. Małe sieci są
        zazwyczaj proste, zasięgiem obejmują jeden poziom lub jeden nieduży
        budynek. Takie sieci posiadają zazwyczaj jedno połączenie do ISP,
        mogą posiadać łącze zapasowe w postaci połączenia np. z siecią
        komórkową, jednak przełączanie między tymi sieciami może odbywać się
        w sposób ręczny. Takie sieci są zarządzane zazwyczaj przez osoby
        z zewnątrz, lub co może być rzadkością posiadają oni własnego
        administratora IT. 
      </p>
      <p>
        Jeśli już decydujemy się, że będziemy budować sieć komputerową to
        należy zastanowić się nad doborem urządzeń. Istnieją cztery
        postawowe czynnki, które należy wziąć pod uwagę podczas wybierania
        urządzeń dla naszej sieci:
      </p>
      <ul>
        <li>Koszt urządzenia</li>
        <li>Wydajność oraz typ portów/interfejsów</li>
        <li>Możliwości rozbudowy</li>
        <li>Funkcje i usługi oferowane przez firmware</li>
      </ul>
      <p>
        Tworząc projekt sieci, nie można zapomnieć o adresacji IP i jej
        ewentualnym podziale. Jeśli już będziemy dzielić adresy klasy
        prywatnej na mniejsze podsieci, to warto oprzeć się na klasach
        urządzeń i ich połączeniach. Dla przykładu powinniśmy wydzielić
        osobną klasę dla serwerów i urządzeń sieciowych, ale tutaj ciekawą 
        opcją
        mogą być komputery użytkowników, często są to laptopy, którą mogą mieć 
        więcej niż jedno połączenie. Warto mieć to
        na uwadze zastanawiając się nad podziałem adresów IP.
      </p>
      <p>
        Jeśli opieramy swoją sieć o połączenia kablowe, raczej będzie to kabel
        UTP, ponieważ jest prostszy w obsłudze, to warto pomyśleć o 
        nadmiarowości połaczeń, na przykład na jednego użytkownika przypadały
        dwa gniazda sieciowe. Warto również mieć w zanadrzu zapasowy 
        przełącznik oraz router.
      </p>
      <p>
        Ostatnim zagadnieniem jest zarządzanie ruchem, w przypadku małej sieci
        nie jest to może priorytetowy temat do czasu, aż ktoś nie zacznie nam
        wysycać łącza np. pobierając duży plik z Internetu. Wówczas najlepszym
        sposobem jest inwestycja w przełączniki, którymi możemy zarządzać, tam
        jest możliwość nie tyle wdrożenia QoS oczywiście jest to możliwe co
        przypisania konkretnej przepustowości dla danego hosta w obu kierunkach.
      </p>
      <p>
        Nie mniej jednak przełączniki i routery powinny być skonfigurowane w
        taki sposób aby priorytetyzować ruch zgodnie z zapotrzebowaniem 
        wykorzystywanych w tej sieci protokół, tak więc dobrze skonfigurowane
        sieci posiadają wdrożony QoS (<em>Quality of Service</em> -
        priorytetyzację ruchu) (sic).
      </p>
      <h2 id="1.17.2.smallnetworkprotocols">1.17.2. Protokoły wykorzystywane w małych sieciach</h2>
      <p>
        Najczęsciej wykorzystywanymi protokołami w małej sieci będzie na pewno
        protokoł HTTP lub HTTPS w bezpieczniejszej wersji. Protokoły pocztowe
        również mogą mieć miejsce, jak i protokoły SMB w celu wymiany plików
        z innymi współużytkownikami sieci. Do administracji mogą być
        wykorzystywane protokoły HTTPS jak i SSH. Protokoły takie DHCP oraz
        DNS muszą działać inaczej sieć może być trudna w użytkowaniu.
        Najczęściej są one zapewniane przez takie urządzenia jak routery,
        przynajmniej te klasy SOHO. Warto wspomnieć, że wiele usług może
        wykorzystywać jeden ten sam serwer fizyczny.
      </p>
      <p>
        Inna kwestią jest wdrożenie w sieci usług głosowych oraz video czatu.
        Tutaj musimy się zastanowić czy nasza infrastruktura jest w obsłużyć
        tego typu ruch oraz musimy wybrać jedną z trzech technologii:
      </p>
      <ul>
        <li><strong>VoIP</strong> - tańszy odpowiednik dla telefonów IP, 
          oczywiście kosztem jakoś jak i funkcjonalności.</li>
        <li><strong>Telefony IP</strong> - wymagają serwerów do sygnalizacji
          oraz utrzymywania połączeń.</li>
        <li><strong>Aplikacje czasu rzeczywistego</strong> - wszelkie aplikacje
          dla videoczatów oraz komunikatory głosowe. Wymagają one małych
          opóźnień w sieci oraz wdrożenia mechanizmów QoS. Niektóre z nich
          mogą być oparte o protokoły <em>Real-Time Transport Protocol</em>
          (RTP) oraz <em>Real-Time Transport Control Protocol</em> (RTCP).</li> 
      </ul>
      <h2 id="1.17.3.smallnetworkexpanding">1.17.3. Rozbudowa małej sieci</h2>
      <p>
        Może zajść taka potrzeba, że małą sieć będzie trzeba rozbudować i
        warto mieć to na uwadze już podczas projektowania małej sieci. Po co?
        Aby wyrobić w na przykład nawyk prowadzenia
        <strong>dokumentacji sieci</strong> zarówno topologii logicznej, jak
        i fizycznej, w której można znaleźć opisy połączeń oraz lokalizacje
        gdzie można znaleźć router i przełączniki. Jak i prowadzenie 
        <strong>spisu posiadanych urządzeń</strong>, które działają w sieci.
      </p>
      <p>
        Dośc istotnym czynnikiem związanym z rozbudową sieci jest to jakim
        <strong>budżetem</strong> dysponujemy, być może będziemy musieli z
        czegoś zrezygnować lub wręcz przeciwnie będzimy mogli wdrożyć więcej
        przydatnych innowacji. Ważnym czynnikiem determinującym rozbudowę
        może być <strong>analiza ruchu</strong> przy użyciu ogólnodostępnych
        narzędzi takicj jak np. <em>Wireshark</em>. 
      </p>
      <p>
        Aby analiza ruchu była miarodajna musi zostać przeprowadzona w
        odpowiedni sposób. Poniżej znajduje się kilka reguł w jaki sposób
        zbierać pakiety, tak aby dały jak najlepszy obraz tego co się dzieje
        w sieci podczas normalnego dnia pracy, kiedy użytkownicy korzystają 
        z jej zasobów:
      </p>
      <ul>
        <li>Zbieranie pakietów powinno odbywać podczas najwiekszego piku z
          użycia jej zasobów. Powiedzmy gdzieś godzinę od rozpoczęcia pracy
          w dniu kiedy większość pracowników jest obecna w siedzibie firmy.
        </li>
        <li>Przeprowadzenie zbierania pakietów powinno odbyć się w różnych
          segmentach sieci, tak aby móc uchwycić ruch specyficzny dla tego
          segmentu.</li>
        <li>Analiza ruchu powinna być oceniana na podstawie ruchu wychodzącego,
          przychodzącego oraz rodzaju przesyłanego ruchu (np. wykorzystywanych
          protokołów).</li>
      </ul>
      <p>
        Analiza dokonana przy zastosowaniu powyższych metod może dać nam dobrą
        wskazówkę w jaki sposób tym ruchem możemy zarządzać.
      </p>
      <h2 id="1.17.4.verifyconectivity">1.17.4. Weryfikacja łączności</h2>
      <p>
        Weryfikację łączności możemy stosować w momencie budowania sieci, kiedy
        jesteśmy pewni, że wszelakie okablowanie jest podłączone. Weryfikacja
        łączności na wczesnym etapie budowy sieci, może przyspieszyć
        uruchomienie jej w całości.
      </p>
      <p>
        Najprostszym narzędziem jest polecenie <strong>ping</strong>, opiera
        się ono protokół ICMP i jest dostępne w wiekszości systemów
        operacyjnych podłączonych do sieci. W przypadku systemów Cisco IOS,
        również jest ono dostępne ma ono nieco inną formę odpowiedzi niż
        standardowe narzędzia znane z dystrybucji Linuksa czy systemów MS
        Windows. Wysyłane jest komuników i na każde z nich możemy otrzymać
        albo kropkę (<strong>.</strong>) w przypadku braku odpowiedzi lub
        też wykrzyknik (<strong>!</strong>) jeśli taka odpowiedź zostanie
        otrzymana. Możemy rownież uzyskać dużą literę <strong>U</strong>,
        która oznacza, że sieć hosta, do którego wysłaliśmy to zapytanie jest
        nie osiągalna (równoznaczne z <em>destination unreachable</em>).
        Polecenie <em>ping</em> jest uruchamiane z adresem docelowego hosta
        jako pierwszym argumentem. W przypadku IOS jest tak samo, ale jeśli
        uruchomimy to polecenie bez argumentu, to wówczas przejdzie ono
        do trybu rozszerzenego, w którym to będziemy mogli skonfigurować
        więcej parameterów poza samym podaniem adresu docelowego, np. źródłowy
        interfejs.
      </p>
      <p>
        Innym poleceniem które może być przydatne podczas weryfikacji
        łączności w IOS jest <strong>traceroute</strong>, nazwa ta obowiązuje
        również w Uniksach, w przypadku systemu MS Windows jest 
        <em>tracert</em>. Zadaniem tego polecenia jest przeanalizowanie trasy
        do hosta docelowego. Narzędzia te mogą posłużyć do analizy czy wina
        w braku łączności z Internetem leży po stronie naszej konfiguracji czy
        naszego usługodawcy.
      </p>
      <p>
        Jeśli korzystamy z powyższych poleceń na zwykłym PC-cie, to warto
        pamiętać, że te polecenia posiadają komunikaty pomocy nie zależnie
        od systemu. W Uniksach dodatkowo istnieje nieco bardziej obszerny plik
        pomocy tzw. <em>strona podręcznika</em>.
      </p>
      <h2 id="1.17.5.displaynetconfigcommands">1.17.5. Polecenia wyświetlania konfiguracji sieciowej</h2>
      <p>
        Podczas budowania małej sieci, gdziej pod koniec prac nad nią przyjdzie
        nam zacząć podłączać do niej hosty, wówczas możemy potrzebować sposóbów
        na sprawdzenie ich konfiguracji sieciowej.
      </p>
      <p>
        Najczęsciej podłączanym przez nas hostem będzie MS Windows 10 i w
        ustawieniach karty sieciowej w aplecie "Centrum udostępniania i sieci"
        możemy sprawdzić parametry konfiguracji sieciowej takie jak adres IP,
        maska, adres bramy czy adresy serwerów DNS. Możemy również wyświetlić
        te informacje w wierszu polecenia, za pomoca polecenia
        <strong>ipconfig</strong>. Polecenie posiada kilka przydatnych
        opcji takich jak:
      </p>
      <ul>
        <li><strong>/all</strong> - wyświetla bardziej szczegółowe informacje</li>
        <li><strong>/release</strong>,<strong>/renew</strong> - zwolnienie
          używanego adresu IP oraz ponowna prośba o przydzielenie adresu IP.</li>
        <li><strong>/displaydns</strong> - wyświetlenie wpisów w pamięci
          podręcznej systemowego DNS.</li>
      </ul>
      <p>
        Może tak się zdarzyć, że chcąc wdrożyć pewne usługi w sieci organizacji
        będziemy mieć stycznosć z dystrybucjami Linuksa. Tutaj do wyświetlenia
        adresu IP używa się polecenia <strong>ip a</strong> do wyświetlania
        bramy wykorzystujemy polecenie <strong>ip route</strong> adres bramy
        będzie wówczas widnieć we wpisie dla sieci (pierwsza kolumna)
        <em>0.0.0.0</em>. Natomiast adresy serwerów DNS możemy zobaczyć,
        poprzez wyświetlenie zawartości pliku <em>/etc/resolv.conf</em>.
      </p>
      <p>
        W systemach MacOS na komputerach firmy Apple, listę dostępnych
        interfejsów możemy wyświetlić w terminalu za pomocą polecenia
        <strong>networksetup -listallnetworkservices</strong>. Po ustaleniu
        interfejsu wydajemy polecenie
        <strong>networksetup -getinfo <em>nazwa interfejsu</em></strong>.
      </p>
      <p>
        Innym przydatnym narzędziem może być sprawdzenie 
        <strong>tablicy ARP</strong>. Tablica
        ARP ma to do siebie, że komputer w sieci nie odpowiada na <em>ping</em>,
        ponieważ może być tak skonfigurowany za pomocą pakietu programu
        antywirusowego, aby nie odpowiadał na te żądania. To jeśli adres IP
        hosta ma dowiązany MAC w naszej tablicy ARP, to znaczy, że jest on
        poprawnie skonfigurowany tylko nie odpowiada na <em>ping</em>. Tablicę
        ARP możemy wyświetlić za pomoca polecenia <strong>arp -a</strong> w
        przypadku systemów MS Windows, w przypadku dystrybucji Linuksa
        jest <strong>ip neighbor</strong>. Tablice ARP możemy wyczyścić
        w systemach MS Windows za pomocą polecenia
        <strong>netsh interface ip delete arpcache</strong>. To polecenie
        może wymagać uprawnień administratora.
      </p>
      <p>
        W systemie Cisco IOS ze względu, że są to urządzenia sieciowe, mamy
        do dyspozycji kilka różnych poleceń poniżej (są one dostępne w
        trybie uprzywilejowanym EXEC):
      </p>
      <ul>
        <li><strong>show running-config</strong> - wyświetla obecnie używaną
          konfigurację oraz ustawienia.</li>
        <li><strong>show interface</strong> - wyświetla status interfejsów
          oraz ewentualne komunikaty o błędach.</li>
        <li><strong>show ip interface</strong> - wyświetla informacje dla
          z warstwy 3 dla interfejsu.</li>
        <li><strong>show arp</strong> - wyświetla tablice arp urządzenia.</li>
        <li><strong>show ip route</strong> - wyświetla tablice routing
          urządzenia.</li>
        <li><strong>show protocols</strong> - wyświetla listę dostępnych
          protokołów warstwy 3.</li>
        <li><strong>show version</strong> - zwraca informacje o pamięci
          urządzenia, dostępnych interfejsach oraz licencji.</li>
      </ul>
      <p>
        Innym wartym uwagi narzędziem jest protokół Cisco <strong>CDP</strong>,
        z jego pomocą możemy z identyfikować inne urządzenia Cisco podłączone
        do tego, na którym wydajemy polecenia tego protokołu. Ten protokół jest
        nieroutowalny, tak więc zobaczymy urządzenia zajdujące się w tej samej
        domenie rozgłoszeniowej. Aby sprawdzić z jakie są inne urządzenia
        Cisco w naszej sieci należy wydać polecnie:
        <code class="code-inline">show cdp neighbors</code> lub
        <code class="code-inline">show cdp neighbors detail</code>.
      </p>
      <p>
        W przypadku polecenia
        <code class="code-inline">show ip interface</code> możemy dodać na
        końcu jeszcze słowo kluczowe <strong>brief</strong> aby uzyskać więcej
        informacji.
      </p>
      <h3 id="1.17.5.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.5.9-packet-tracer---interpret-show-command-output_pl-PL.pdf">Interpretacja wyjścia polecenia show - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.5.9-packet-tracer---interpret-show-command-output_pl-PL.pka">Interpretacja wyjścia polecenia show - zadanie</a>
      </p>
      <h2 id="1.17.6.troubleshootingmethodologies">1.17.6. Metodologia rozwiązywania problemów</h2>
      <p>
        Czasami może tak się zdarzyć, że coś nie będzie działać lub coś
        przestanie działać. Naszym zadaniem jest znalezienie usterki oraz
        jej usunięcie. Czasami nie jest takie proste jakby się mogło wydawać,
        i niektóre problemy mogą być bardziej lub mniej złożone, wiadome jest,
        że ile jest usterek to tyle samo może być sposób na ich usunięcie.
        Poniżej jednak znajduje się lista kroków, które wprowadzają nieco
        organizacji w metodologię rozwiązywania problemów i to nie tylko
        sieciowych.
      </p>
      <ol>
        <li><strong>Zidentyfikuj problem</strong> - Tutaj możemy użyć wszelkich
          możliwych środków, które mogą przybliżyć nas do natury problemu.
          Istotna może być rozmowa z innymi użytkownikami.</li>
        <li><strong>Określenie możliwych przyczyn problemu</strong> - po
          zidentyfikowaniu problemu, powinniśmy ustalić możliwe przyczyny jego
          powstania, co mogło i kiedy się stać, że ten problem wystąpił.</li>
        <li><strong>Spróbuj potwierdzić swoje ustalenia</strong> - tutaj musimy
          ustalić, które z naszych przypuszeń powstania problemów, jest tą
          prawdziwą genezą usterki.</li>
        <li><strong>Określ plan rozwiązania problemu oraz ustal właściwe
          rozwiązanie</strong> - skoro wiemy co spowodowało usterkę, to należy
          opracować rozwiązanie problemu oraz sposób w jaki to zrobimy, aby
          jeszcze nie pogorszyć sytuacji.</li>
        <li><strong>Zweryfikuj poprawność wprowadzonych rozwiązań, wdróż
          rozwiązania zardcze</strong> - Po hipotetycznym pozbyciu się
          problemu musimy ustalić, czy naszy rozwiązanie działa i czy
          przypadkiem nie ma wpływu na inne rozwiązania. Warto również
          skonfrontować się z przyczyną problemu i wdrożyć odpowiednie środki
          zaracze, aby problem się nie powtarzał.</li>
        <li><strong>Udokumentuj to</strong> - warto prowadzić bazę wiedzy lub
          chociaż notatki, wrazi gdyby podobny problem wystąpił gdzieś
          indziej.</li>
      </ol>
      <p>
        Oczywiście zdaję sobie sprawę z tego, że nie zawsze uda się trzymać
        tego planu. Warto jednak moim zdaniem wziąć sobie do serca ostatnią
        zasadę. Właśnie dzięki niej ta strona w ogole powstała i dlatego też
        dalej ją prowadzę.
      </p>
      <p>
        Drugą sprawą jest fakt, że pewnych problemów nie uda nam się rozwiązać,
        z różnych przyczyn. Warto mieć to na uwadze i poinformować o tym
        przełożonych oraz innych pracowników. Oszczędzimy sobie setek pytań 
        o...
      </p>
      <p>
        Cisco IOS posiada narzędzie, które może pomóc nam znaleźć problem lub
        jego przyczynę, jednak należy traktować go jako ostatateczność. Do
        dyspozycji mamy polecenie <strong>debug</strong>. Wprowadza ono
        urządzenie w stan debugowania, przez co każdy pakiet jest analizowany,
        a rozszerzeone komunikaty diagnostyczne o przychodzących pakietach jakie
        zostały
        przetworzone przez te urządzenie mogą pojawiać się na konsoli. Jednak
        warto mieć to na uwadzę, że uruchomienie tego trybu spowoduje znaczne
        spowolnienie transmisji przez nie, ponieważ przez większość czasu
        będzie ono zajęte analizowaniem pakietów. Tryb debugowania włączamy
        polecenie <code class="code-inline">debug</code> w trybie
        uprzywilejowanym EXEC, a wyłączamy za pomocą polecenia
        <code class="code-inline">no debug</code>.
      </p>
      <h2 id="1.17.7.troubleshootingscenarios">1.17.7. Rozwiązania typowych problemów</h2>
      <p>
        Poniżej znalazły się rozwiązania typowych problemów jakie możemy
        napotkać nie tylko konfigurując małą sieć. Takie problemy mogą się
        pojawić zawsze gdy konfigurujemy czy urządzenie końcowe czy też
        urządzenie pośredniczące w komunikacji sieciowej.
      </p>
      <p>
        Pierwszym z nich mogą być problemy z autonegocjacją interfejsów
        sieciowych oraz błedne przyjęte uzgodnie odnośnie kierunku transmisji
        (<em>duplex</em>). Tutaj najczęściej przyczną może być fatalnej jakość
        medium transmisjne, np. kabel UTP, źle zarobione końcówki RJ-45 lub
        uszkodzone urządzenie, które chcemy podłączyć. Urządzenia Cisco mogą
        wyłączać również porty, jeśli dochodzi na do błędów.
      </p>
      <p>
        Następnym przypadkiem jest przypadek błędnej adresacji interfejsów.
        Do rozwiązania tego problemu możemy wykorzystać poznane wcześniej
        polecenia jak <code class="code-inline">show ip interface brief</code>.
      </p>
      <p>
        Problem z brakiem łączności z internetem można powiązać z brakiem
        lub błędnym przypisaniem adresu bramy do hosta. Za pomocą poleceń
        <code class="code-inline">ipconfig</code> lub
        <code class="code-inline">show ip route</code> w przypadku urządzeń
        sieciowych. Warto również sprawdzić czy serwer DHCP dobrze ustawia
        ten parametr.
      <p>
      <p>
        Problemy z rozwiązywaniem nazw również mogą powodować błędnę adresy
        w konfiguracji hostów. Tak jak we wcześniejszym przypadku serwer DHCP
        może przydzielć adres serwera DNS, który już nie istnieje. W przypadku
        systemów MS Windows, aby sprawdzić adres serwera DNS należy wydać
        polecenie <code class="code-inline">ipconfig /all</code> do dyspozycji
        mamy również takie narzędzie jak
        <code class="code-inline">nslookup</code>
      </p>
      <h3 id="1.17.7.lab">Laboratorium</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/17.7.6-lab---troubleshoot-connectivity-issues_pl-PL.pdf">Rozwiązywanie problemów z łącznością</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/laby/17.8.1-lab---design-and-build-a-small-network_pl-PL.pdf">Projektowanie i budowanie sieci małej firmy</a>
      </p>
      <h3 id="1.17.7.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.7.7-packet-tracer---troubleshoot-connectivity-issues_pl-PL.pdf">Rozwiązywanie problemów z łącznością - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.7.7-packet-tracer---troubleshoot-connectivity-issues_pl-PL.pka">Rozwiązywanie problemów z łącznością_- zadanie</a>
        
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.3-packet-tracer---troubleshooting-challenge_pl-PL.pdf">Wyzwanie dotyczące rozwiązywania problemów - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.3-packet-tracer---troubleshooting-challenge_pl-PL.pka">Wyzwanie dotyczące rozwiązywania problemów - zadanie</a>
      </p>
      <h2 id="ch17summary">Podsumowanie</h2>
      <p>
        W tym rodziale dowiedzieliśmy się w jaki sposób projektować małe sieci
        czy weryfikować konfigurację sieciową hostów znajdujących się nie
        tylko w małych sieciach, ale podłączonych do sieci ogólnie. Poznalismy
        również zasady jakim należy kierować się podczas chęci rozbudowy
        takiej małej sieci. Na koniec usystematyzowaliśmy swoją wiedze na
        temat metodologi rozwiązywania problemów oraz poznaliśmy scenariusze
        typowych błędów jakie możemy napotkać. Ten rozdział zamyka pierwszy
        moduł kursu Cisco CCNA. Poniżej znajduje się 50 pytań teoretycznych,
        których można spodziewać się na egzaminie z pierwszego modułu.
      </p>
      <h3 id="1.17.pka">Zadanie praktyczne - Packet Tracer</h3>
      <p>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.2-packet-tracer---skills-integration-challenge_pl-PL.pdf">Zadanie podsumowujące umiejętności - scenariusz</a>
        <a href="https://f-tx2550-m5.morketsmerke.org/~xf0r3m/cisco/module_1/pt/17.8.2-packet-tracer---skills-integration-challenge_pl-PL.pka">Zadanie podsumowujące umiejętności - zadanie</a>
      </p>
      <h1 id="1.examplepartialexam">Przykładowy egzamin cząstkowy - Tematy: 16-17</h1>
      <p>
        <a href="Cisco_-_CCNA_-_ITN_-_przykladowy_egzamin_czastkowy.html">Cisco - CCNA - ITN - przykładowy egzamin_czastkowy.html</a>
      </p>
      <h1 id="1.mockexam">Przykładowy egzamin próbny - ITN</h1>
      <p>
        Przed przystąpieniem do egzaminu finałowego, będziemy mogli a wręcz
        musieli podejść do egzaminu próbnego. Egzamin próbny jest bardzo
        podobny do egzaminy finalnego, gdyż jego zakres obejmuje całość
        przerobionego na kursie materiału.
      </p>
      <p>
        <a href="Cisco_-_CCNA_-_ITN_-_przykladowy_egzamin_probny.html">Cisco - CCNA - ITN - przykładowy egzamin próbny</a>
      </p>
      <h1 id="1.finalexam">Egzamin finałowy - ITN</h1>
      <p>
        Egzamin finałowy może składać z testu, w którym do wyboru możemy
        mieć pytania jednokrotnego lub wielokrotnego wyboru wymagające 2 lub 3
        odpowiedzi. Mogą również zdarzyć się zadania polegające na
        przyporządkowaniu słów kluczowych, terminów, a nawet adresów do
        poszczególnych pól, jakimś opisem. W przypadku adresów możemy mieć
        rownież polecenie, gdzie będzie trzeba przyporządkować do adresów
        opis w stylu adres <em>broadcast</em> podsieci 1. Mając podane adres
        np. hostów oraz maskę w notacji CIDR.
      </p>
      <p>
        W pytanich wielkrotnego wyboru, istnieje pewnego rodzaju haczyk. Czy
        też zmuszenie zdającego do posiadania podstaw do zazanaczenia takich
        odpowiedzi (w postaci wiedzy), że jeśli zaznaczym jedną dobrą
        odpowiedź i jedną złą, to wówczas za całe to zadanie mamy 0 punktów.
        Dlatego też, jeśli niemamy pewności do pozostałych, a jednej jesteśmy
        pewnii to lepiej zaznaczyć tę jedną i iść dalej. Taki mechanizm, żeby
        nie zgadywać.
      </p>
      <p>
        Ilość pytań na egzaminie wacha się między 50, a 60 pytaniami, na
        zdanie których mamy 2 i pół godziny. W tym egzaminie nie uświadczymy
        zadań praktycznych wykonywanych w Packet Tracerze, tak jak to miało
        miejsce w egzaminach cząstkowych.
      </p>
      <p>
        Czy są szanse na zdanie egzaminu, bazując tylko na tym materiale?
        Jeśli czytelnik, nie posiada żadnej wiedzy na temat sieci to raczej
        w to wątpie. Materiał ten ma za zadanie jedynie odświeżenie wiedzy
        zdobytej podczas kursu. Coś na zasadzie intensywnego powtórzenia.
        Problemy również mogą mieć osoby posiadające już jakąś wiedzę oraz
        doświadczenie w praktycznej konfiguracji sieci. Wymaga się od
        zdającego, zmiany sposobu myślenia na rozumienia pewnych pojęć tak
        jak sobie życzy tego Cisco. Z jednej strony przygotowuje nas to pracy
        z konkretną technologią, jednak nie od dziś wiadomo, że raczej z
        jedną nie będziemy zawsze i wszędzie pracować. Dlatego też zapoznanie
        się z materiałamia dostępnymi na kursie może być wymagane.
      </p>
      <h1 id="1.ptsa">Finałowy egzamin praktyczny - Packet Tracer - ITN</h1>
      <p>
        Egzamin praktyczy jest podobny do ćwiczeń, które wykonywaliśmy 
        w trakcie tego kursu. W przypadku tegorocznego zdania możemy dostać
        podłączoną już sieć która wymaga konfiguracji. Ale zanim do niej
        przejdziemy dostajemy na początku zadanie z określeniem odpowiedniej
        adresacji. Na przykład 192.168.1.0/24 i wytyczne mówią, aby podzielić
        tę pulę na podsieci o X ilości hostów przy jak najmniejszym zmarnowaniu
        adresów. Np. 30 hostów w sieci i dla sieci powiedzmy <em>administracji</em>
        mamy wykorzystać 4-tą podsieć z tego podziału. Następnie od 5-tej
        podsieci, podzielić pule na jescze mniejsze zawierające 12 czy 14
        hostów i dla sieci <em>działu IT</em> wykorzystać podsieć 7 czy 8.
        Z tych podsieci mogą być również wytyczne, aby wykorzystać ostatni
        adres dla interfejsu routera, następny, przedostatni dla przełącznika
        i na koniec dowolne, inne dla hostów w tej sieci. Tak wygląda
        adresacja IPv4 w przypadku IPv6, adresy są już przypisane w tabeli.
        Tabele należy uzupełnić, aby nie pogubić się podczas konfiguracji
        urządzeń. Nie uzupełniamy jej w zadaniu. Nie ma takiej możliwości.
        Tak się kończy krok pierwszy.
      </p>
      <p>
        Krok drugi polega na skonfigurowaniu interfejsów hostów w sieciach.
        Dla IPv4 oraz IPv6. Nie jest on zbyt wymagających.
      </p>
      <p>
        Krok trzeci polega na konfiguracji routera. Do konfiguracji możemy
        mieć:
      </p>
      <ul>
        <li>Nazwę urządzenia.</li>
        <li>Zabezpieczenie dostępu do urządzenia. Tj. zabezpieczenie połączeń
          konsolowych, zabezpieczenie trybu uprzywilejowanyego EXEC za
          pomocą szyfrowanego hasła. Hasła musimy wymyśleć sami. Tutaj należy
          pamiętać o banerze. Warto zabepieczyć je jak najbardziej się da,
          najwyżej, niektóre z poleceń nie zostaną ocenione.</li>
        <li>Zaszyfowanie haseł.</li>
        <li>Ustawienie min. 10 znaków dla nowych haseł.</li>
        <li>Konfigurację dostępu przez SSH, przy czym może być informacja
          sugerująca utworzenie klucza RSA, ale nie będzie informacji na
          temat domeny. Bez tej informacji klucz nie zostanie utworzym. W tym
          celu musimy wykonać wszystkie kroki, aby to polecenie wykonało się
          poprawnie.</li>
        <li>Utworzyć użytkownika w lokalnej bazie na podstawie informacji
          podanych w zadaniu oraz użycie lokalnej bazy uwierzytelniania
          użytkowników łączycych się po SSH.</li>
        <li>Na koniec należy skonfigurować interfejsy w raz z ich podniesiem
          oraz z opisem <em>description</em>. Tutaj ważne może być włącznie
          routingu dla IPv6.</li>
      </ul>
      <p>
        Krok czwarty (prawdopodobnie ostatni) polega na konfiguracji
        przełącznika i przy czym ta konfiguracja jest banalna. Musimy
        skonfigurować go do dostępu za pomocą protokołu Telnet z możliwością
        połączenia się z nim z innej sieci (tej drugiej) niż lokalna.
      </p>
      <p>
        Ostatnią rzeczą jaką należy wykonać przed złożeniem zadania, jest
        sprawdzenia łączności oraz czy faktycznie mamy możliwość połączenia
        się z przełącznikiem po przez Telnet z sieci zdalnej.
      </p>
      <p>
        W trakcie egzaminy praktycznego mamy zablokowane zakładki CLI lub
        w ogóle dostęp do urządzeń z poziomu osobnego okna Packet Tracera.
        Z urządzeniami należy łączyć się poprzez dowolnego hosta korzystając
        z połaczenia szeregowego oraz terminala. Egzamin ten oraz jego
        scenariusz jest tylko i wyłącznie w języku angielskim.
      </p>
      <h1>Koniec modułu pierwszego</h1>
    </div>
      	</body>
</html>
